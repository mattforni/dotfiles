exports.id=521,exports.ids=[521],exports.modules={1629:(e,t,s)=>{s.d(t,{FocusWebviewProvider:()=>FocusWebviewProvider});var r=s(9496),o=s(5255),i=s(8887),n=s(4155),a=s(8834),u=s(5367),h=s(8452),c=s(4092),l=s(4321),p=s(3646),d=s(2674),f=s(4794),m=s(9529),g=s(2061),R=s(7469),b=s(5798);const w=new b.ke("focus/pr/openWorktree"),y=new b.ke("focus/pr/switchToBranch"),C=new b.jH("focus/didChange",!0);class FocusWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._pullRequests=[],this._issues=[],this._disposable=r.Disposable.from(this.container.subscription.onDidChange(this.onSubscriptionChanged,this),this.container.git.onDidChangeRepositories((()=>{this.host.refresh(!0)})))}dispose(){this._disposable.dispose()}registerCommands(){return[(0,m.xR)(o.Gh.RefreshFocus,(()=>this.host.refresh(!0)))]}onFocusChanged(e){e?setTimeout((()=>{(0,g.v)("gitlens:focus:focused",e)}),0):(0,g.v)("gitlens:focus:focused",e)}onMessageReceived(e){switch(e.method){case y.method:(0,b.mq)(y,e,(e=>this.onSwitchBranch(e)));break;case w.method:(0,b.mq)(w,e,(e=>this.onOpenWorktree(e)))}}findSearchedPullRequest(e){return this._pullRequests?.find((t=>t.pullRequest.id===e.id))}async getRemoteBranch(e){const t=e.pullRequest,s=e.repoAndRemote,o=s.repo.folder.uri,i=await s.repo.getMainRepository();if(null==i)return void r.window.showWarningMessage(`Unable to find main repository(${o.toString()}) for PR #${t.id}`);const a=t.refs.base.owner,u=r.Uri.parse(t.refs.base.url),h=t.refs.head.branch,c=r.Uri.parse(t.refs.head.url),p=c.toString(),[,d,m]=(0,f.Sk)(p);let g,R;if([g]=await i.getRemotes({filter:e=>e.matches(d,m)}),null!=g)R=`${g.name}/${h}`,await this.container.git.fetch(i.path,{remote:g.name});else{const e=await r.window.showInformationMessage(`Unable to find a remote for '${p}'. Would you like to add a new remote?`,{modal:!0},{title:"Yes"},{title:"No",isCloseAffordance:!0});if("Yes"!==e?.title)return;const s=t.refs.head.owner;if(await(0,n.IH)(i,s,p,{confirm:!1,fetch:!0,reveal:!1}),[g]=await i.getRemotes({filter:e=>e.url===p}),null==g)return;R=`${g.name}/${h}`;const o=t.refs.base.repo,l=`pr/${u.toString()===c.toString()?h:R}`;this.container.git.setConfig(i.path,`branch.${l}.github-pr-owner-number`,`${a}#${o}#${t.id}`)}return{remote:g,reference:(0,l.xB)(R,i.path,{refType:"branch",name:R,remote:!0})}}async onSwitchBranch({pullRequest:e}){const t=this.findSearchedPullRequest(e);if(null==t||t.isCurrentBranch)return Promise.resolve();if(null!=t.branch)return a.gu(t.branch.repoPath,t.branch);const s=await this.getRemoteBranch(t);return null==s?Promise.resolve():a.gu(s.remote.repoPath,s.reference)}async onOpenWorktree({pullRequest:e}){const t=this.findSearchedPullRequest(e);if(null==t?.repoAndRemote)return;const s=r.Uri.parse(e.refs.base.url),i=t.repoAndRemote.repo.folder;return(0,m.P0)(o.Gh.OpenOrCreateWorktreeForGHPR,{base:{repositoryCloneUrl:{repositoryName:e.refs.base.repo,owner:e.refs.base.owner,url:s}},githubRepository:{rootUri:i.uri},head:{ref:e.refs.head.branch,sha:e.refs.head.sha,repositoryCloneUrl:{repositoryName:e.refs.head.repo,owner:e.refs.head.owner,url:r.Uri.parse(e.refs.head.url)}},item:{number:parseInt(e.id,10)}})}onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(this._etagSubscription=e.etag,this.notifyDidChangeState(!0))}async getState(e){const t=await this.container.git.access(i.x.Focus);if(!0!==t.allowed)return{timestamp:Date.now(),access:t};const s=await this.getRichRepos(),r=s.filter((e=>e.isGitHub));const o=function(e){return e.filter((e=>e.isConnected&&e.isGitHub))}(r);if(!(o.length>0))return{timestamp:Date.now(),access:t,repos:r.map((e=>q(e)))};const n=o.map((e=>q(e))),a=Promise.allSettled([this.getMyPullRequests(o),this.getMyIssues(o)]);async function u(){const[e,s]=await a;return{timestamp:Date.now(),access:t,repos:n,pullRequests:(0,R.Sb)(e)?.map((e=>({pullRequest:(0,c.l1)(e.pullRequest),reasons:e.reasons,isCurrentBranch:e.isCurrentBranch??!1,isCurrentWorktree:e.isCurrentWorktree??!1,hasWorktree:e.hasWorktree??!1,hasLocalBranch:e.hasLocalBranch??!1}))),issues:(0,R.Sb)(s)?.map((e=>({issue:(0,h.y$)(e.issue),reasons:e.reasons})))}}if(e)return queueMicrotask((async()=>{const e=await u();this.host.notify(C,{state:e})})),{timestamp:Date.now(),access:t,repos:n};return await u()}async includeBootstrap(){return this.getState(!0)}async getRichRepos(e){if(null==this._repos||!0===e){const e=[],t=[];for(const s of this.container.git.openRepositories){const r=await s.getRichRemote();null==r||e.findIndex((e=>e.remote===r))>-1||(t.push(s.onDidChange(this.onRepositoryChanged,this)),e.push({repo:s,remote:r,isConnected:await r.provider.isConnected(),isGitHub:"GitHub"===r.provider.name}))}this._repositoryEventsDisposable&&(this._repositoryEventsDisposable.dispose(),this._repositoryEventsDisposable=void 0),this._repositoryEventsDisposable=r.Disposable.from(...t),this._repos=e}return this._repos}async onRepositoryChanged(e){e.changed(p.I6.RemoteProviders,p.du.Any)&&(await this.getRichRepos(!0),this.notifyDidChangeState())}async getMyPullRequests(e){const t=[];for(const s of e){const e=(await s.repo.getRemotes()).map((e=>e.name)),r=s.remote,o=await this.container.git.getMyPullRequests(r);if(null!=o)for(const r of o){if(0===r.reasons.length)continue;const o={...r,repoAndRemote:s,isCurrentWorktree:!1,isCurrentBranch:!1},i=e.map((e=>`${e}/${o.pullRequest.refs.head.branch}`)),n=await(0,d.K)(o.repoAndRemote.repo,o.pullRequest.refs.head.branch,i);o.hasWorktree=null!=n,o.isCurrentWorktree=!0===n?.opened;const a=await(0,u.fb)(s.repo,o.pullRequest.refs.head.branch,i);a&&(o.branch=a,o.hasLocalBranch=!0,o.isCurrentBranch=a.current),t.push(o)}}function s(e){let t=0;return e.reasons.includes("authored")?t+=1e3:e.reasons.includes("assigned")?t+=900:e.reasons.includes("review-requested")?t+=800:e.reasons.includes("mentioned")&&(t+=700),e.pullRequest.reviewDecision===c.pD.Approved?e.pullRequest.mergeableState===c.Cz.Mergeable?t+=100:e.pullRequest.mergeableState===c.Cz.Conflicting?t+=90:t+=80:e.pullRequest.reviewDecision===c.pD.ChangesRequested&&(t+=70),t}return this._pullRequests=t.sort(((e,t)=>{const r=s(e),o=s(t);return r===o?e.pullRequest.date.getTime()-t.pullRequest.date.getTime():(o??0)-(r??0)})),this._pullRequests}async getMyIssues(e){const t=[];for(const{remote:s}of e){const e=await this.container.git.getMyIssues(s);null!=e&&t.push(...e.filter((e=>e.reasons.length>0)))}return this._issues=t.sort(((e,t)=>t.issue.updatedDate.getTime()-e.issue.updatedDate.getTime())),this._issues}async notifyDidChangeState(e){this.host.notify(C,{state:await this.getState(e)})}}function q(e){return{repo:e.repo.path,isGitHub:e.isGitHub,isConnected:e.isConnected}}}};