exports.id=457,exports.ids=[457],exports.modules={5186:(t,e,r)=>{var n=r(3698),i=r(2505),o=r(6417),s=Function.bind,a=s.bind(s);function u(t,e,r){var n=a(o,null).apply(null,r?[e,r]:[e]);t.api={remove:n},t.remove=n,["before","error","after","wrap"].forEach((function(n){var o=r?[e,n,r]:[e,n];t[n]=t.api[n]=a(i,null).apply(null,o)}))}function l(){var t={registry:{}},e=n.bind(null,t);return u(e,t),e}var c=!1;function h(){return c||(console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'),c=!0),l()}h.Singular=function(){var t={registry:{}},e=n.bind(null,t,"h");return u(e,t,"h"),e}.bind(),h.Collection=l.bind(),t.exports=h,t.exports.Hook=h,t.exports.Singular=h.Singular,t.exports.Collection=h.Collection},2505:t=>{t.exports=function(t,e,r,n){var i=n;t.registry[r]||(t.registry[r]=[]);"before"===e&&(n=function(t,e){return Promise.resolve().then(i.bind(null,e)).then(t.bind(null,e))});"after"===e&&(n=function(t,e){var r;return Promise.resolve().then(t.bind(null,e)).then((function(t){return i(r=t,e)})).then((function(){return r}))});"error"===e&&(n=function(t,e){return Promise.resolve().then(t.bind(null,e)).catch((function(t){return i(t,e)}))});t.registry[r].push({hook:n,orig:i})}},3698:t=>{t.exports=function t(e,r,n,i){if("function"!=typeof n)throw new Error("method for before hook must be a function");i||(i={});if(Array.isArray(r))return r.reverse().reduce((function(r,n){return t.bind(null,e,n,r,i)}),n)();return Promise.resolve().then((function(){return e.registry[r]?e.registry[r].reduce((function(t,e){return e.hook.bind(null,t,i)}),n)():n(i)}))}},6417:t=>{t.exports=function(t,e,r){if(!t.registry[e])return;var n=t.registry[e].map((function(t){return t.orig})).indexOf(r);if(-1===n)return;t.registry[e].splice(n,1)}},6574:(t,e,r)=>{function n(){return"object"==typeof navigator&&"userAgent"in navigator?navigator.userAgent:"object"==typeof process&&"version"in process?`Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`:"<environment undetectable>"}r.r(e),r.d(e,{GitHubApi:()=>GitHubApi});var i=r(5186);function o(t){return"[object Object]"===Object.prototype.toString.call(t)}function s(t){var e,r;return!1!==o(t)&&(void 0===(e=t.constructor)||!1!==o(r=e.prototype)&&!1!==r.hasOwnProperty("isPrototypeOf"))}function a(t,e){const r=Object.assign({},t);return Object.keys(e).forEach((n=>{s(e[n])?n in t?r[n]=a(t[n],e[n]):Object.assign(r,{[n]:e[n]}):Object.assign(r,{[n]:e[n]})})),r}function u(t){for(const e in t)void 0===t[e]&&delete t[e];return t}function l(t,e,r){if("string"==typeof e){let[t,n]=e.split(" ");r=Object.assign(n?{method:t,url:n}:{url:t},r)}else r=Object.assign({},e);var n;r.headers=(n=r.headers)?Object.keys(n).reduce(((t,e)=>(t[e.toLowerCase()]=n[e],t)),{}):{},u(r),u(r.headers);const i=a(t||{},r);return t&&t.mediaType.previews.length&&(i.mediaType.previews=t.mediaType.previews.filter((t=>!i.mediaType.previews.includes(t))).concat(i.mediaType.previews)),i.mediaType.previews=i.mediaType.previews.map((t=>t.replace(/-preview/,""))),i}const c=/\{[^}]+\}/g;function h(t){return t.replace(/^\W+|\W+$/g,"").split(/,/)}function d(t,e){return Object.keys(t).filter((t=>!e.includes(t))).reduce(((e,r)=>(e[r]=t[r],e)),{})}function m(t){return t.split(/(%[0-9A-Fa-f]{2})/g).map((function(t){return/%[0-9A-Fa-f]/.test(t)||(t=encodeURI(t).replace(/%5B/g,"[").replace(/%5D/g,"]")),t})).join("")}function p(t){return encodeURIComponent(t).replace(/[!'()*]/g,(function(t){return"%"+t.charCodeAt(0).toString(16).toUpperCase()}))}function g(t,e,r){return e="+"===t||"#"===t?m(e):p(e),r?p(r)+"="+e:e}function f(t){return null!=t}function y(t){return";"===t||"&"===t||"?"===t}function w(t,e){var r=["+","#",".","/",";","?","&"];return t.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,(function(t,n,i){if(n){let t="";const i=[];if(-1!==r.indexOf(n.charAt(0))&&(t=n.charAt(0),n=n.substr(1)),n.split(/,/g).forEach((function(r){var n=/([^:\*]*)(?::(\d+)|(\*))?/.exec(r);i.push(function(t,e,r,n){var i=t[r],o=[];if(f(i)&&""!==i)if("string"==typeof i||"number"==typeof i||"boolean"==typeof i)i=i.toString(),n&&"*"!==n&&(i=i.substring(0,parseInt(n,10))),o.push(g(e,i,y(e)?r:""));else if("*"===n)Array.isArray(i)?i.filter(f).forEach((function(t){o.push(g(e,t,y(e)?r:""))})):Object.keys(i).forEach((function(t){f(i[t])&&o.push(g(e,i[t],t))}));else{const t=[];Array.isArray(i)?i.filter(f).forEach((function(r){t.push(g(e,r))})):Object.keys(i).forEach((function(r){f(i[r])&&(t.push(p(r)),t.push(g(e,i[r].toString())))})),y(e)?o.push(p(r)+"="+t.join(",")):0!==t.length&&o.push(t.join(","))}else";"===e?f(i)&&o.push(p(r)):""!==i||"&"!==e&&"?"!==e?""===i&&o.push(""):o.push(p(r)+"=");return o}(e,t,n[1],n[2]||n[3]))})),t&&"+"!==t){var o=",";return"?"===t?o="&":"#"!==t&&(o=t),(0!==i.length?t:"")+i.join(o)}return i.join(",")}return m(i)}))}function v(t){let e,r=t.method.toUpperCase(),n=(t.url||"/").replace(/:([a-z]\w+)/g,"{$1}"),i=Object.assign({},t.headers),o=d(t,["method","baseUrl","url","headers","request","mediaType"]);const s=function(t){const e=t.match(c);return e?e.map(h).reduce(((t,e)=>t.concat(e)),[]):[]}(n);var a;n=(a=n,{expand:w.bind(null,a)}).expand(o),/^http/.test(n)||(n=t.baseUrl+n);const u=d(o,Object.keys(t).filter((t=>s.includes(t))).concat("baseUrl"));if(!/application\/octet-stream/i.test(i.accept)&&(t.mediaType.format&&(i.accept=i.accept.split(/,/).map((e=>e.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,`application/vnd$1$2.${t.mediaType.format}`))).join(",")),t.mediaType.previews.length)){const e=i.accept.match(/[\w-]+(?=-preview)/g)||[];i.accept=e.concat(t.mediaType.previews).map((e=>`application/vnd.github.${e}-preview${t.mediaType.format?`.${t.mediaType.format}`:"+json"}`)).join(",")}return["GET","HEAD"].includes(r)?n=function(t,e){const r=/\?/.test(t)?"&":"?",n=Object.keys(e);return 0===n.length?t:t+r+n.map((t=>"q"===t?"q="+e.q.split("+").map(encodeURIComponent).join("+"):`${t}=${encodeURIComponent(e[t])}`)).join("&")}(n,u):"data"in u?e=u.data:Object.keys(u).length&&(e=u),i["content-type"]||void 0===e||(i["content-type"]="application/json; charset=utf-8"),["PATCH","PUT"].includes(r)&&void 0===e&&(e=""),Object.assign({method:r,url:n,headers:i},void 0!==e?{body:e}:null,t.request?{request:t.request}:null)}function b(t,e,r){return v(l(t,e,r))}const C=function t(e,r){const n=l(e,r),i=b.bind(null,n);return Object.assign(i,{DEFAULTS:n,defaults:t.bind(null,n),merge:l.bind(null,n),parse:v})}(null,{method:"GET",baseUrl:"https://api.github.com",headers:{accept:"application/vnd.github.v3+json","user-agent":`octokit-endpoint.js/7.0.6 ${n()}`},mediaType:{format:"",previews:[]}});var $=r(6292);class Deprecation extends Error{constructor(t){super(t),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="Deprecation"}}var R=r(778),P=r.n(R);const G=P()((t=>console.warn(t))),S=P()((t=>console.warn(t)));class RequestError extends Error{constructor(t,e,r){let n;super(t),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="HttpError",this.status=e,"headers"in r&&void 0!==r.headers&&(n=r.headers),"response"in r&&(this.response=r.response,n=r.response.headers);const i=Object.assign({},r.request);r.request.headers.authorization&&(i.headers=Object.assign({},r.request.headers,{authorization:r.request.headers.authorization.replace(/ .*$/," [REDACTED]")})),i.url=i.url.replace(/\bclient_secret=\w+/g,"client_secret=[REDACTED]").replace(/\baccess_token=\w+/g,"access_token=[REDACTED]"),this.request=i,Object.defineProperty(this,"code",{get:()=>(G(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")),e)}),Object.defineProperty(this,"headers",{get:()=>(S(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")),n||{})})}}function H(t){const e=t.request&&t.request.log?t.request.log:console;(s(t.body)||Array.isArray(t.body))&&(t.body=JSON.stringify(t.body));let r,n,i={};return(t.request&&t.request.fetch||globalThis.fetch||$.ZP)(t.url,Object.assign({method:t.method,body:t.body,headers:t.headers,redirect:t.redirect,...t.body&&{duplex:"half"}},t.request)).then((async o=>{n=o.url,r=o.status;for(const t of o.headers)i[t[0]]=t[1];if("deprecation"in i){const r=i.link&&i.link.match(/<([^>]+)>; rel="deprecation"/),n=r&&r.pop();e.warn(`[@octokit/request] "${t.method} ${t.url}" is deprecated. It is scheduled to be removed on ${i.sunset}${n?`. See ${n}`:""}`)}if(204!==r&&205!==r){if("HEAD"===t.method){if(r<400)return;throw new RequestError(o.statusText,r,{response:{url:n,status:r,headers:i,data:void 0},request:t})}if(304===r)throw new RequestError("Not modified",r,{response:{url:n,status:r,headers:i,data:await U(o)},request:t});if(r>=400){const e=await U(o),s=new RequestError(function(t){if("string"==typeof t)return t;if("message"in t)return Array.isArray(t.errors)?`${t.message}: ${t.errors.map(JSON.stringify).join(", ")}`:t.message;return`Unknown error: ${JSON.stringify(t)}`}(e),r,{response:{url:n,status:r,headers:i,data:e},request:t});throw s}return U(o)}})).then((t=>({status:r,url:n,headers:i,data:t}))).catch((e=>{if(e instanceof RequestError)throw e;if("AbortError"===e.name)throw e;throw new RequestError(e.message,500,{request:t})}))}async function U(t){const e=t.headers.get("content-type");return/application\/json/.test(e)?t.json():!e||/^text\/|charset=utf-8$/.test(e)?t.text():function(t){return t.arrayBuffer()}(t)}const q=function t(e,r){const n=e.defaults(r);return Object.assign((function(e,r){const i=n.merge(e,r);if(!i.request||!i.request.hook)return H(n.parse(i));const o=(t,e)=>H(n.parse(n.merge(t,e)));return Object.assign(o,{endpoint:n,defaults:t.bind(null,n)}),i.request.hook(o,i)}),{endpoint:n,defaults:t.bind(null,n)})}(C,{headers:{"user-agent":`octokit-request.js/6.2.8 ${n()}`}});var D=class extends Error{constructor(t,e,r){super("Request failed due to following response errors:\n"+r.errors.map((t=>` - ${t.message}`)).join("\n")),this.request=t,this.headers=e,this.response=r,this.name="GraphqlResponseError",this.errors=r.errors,this.data=r.data,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}},F=["method","baseUrl","url","headers","request","query","mediaType"],E=["query","method","url"],M=/\/api\/v3\/?$/;function A(t,e){const r=t.defaults(e);return Object.assign(((t,e)=>function(t,e,r){if(r){if("string"==typeof e&&"query"in r)return Promise.reject(new Error('[@octokit/graphql] "query" cannot be used as variable name'));for(const t in r)if(E.includes(t))return Promise.reject(new Error(`[@octokit/graphql] "${t}" cannot be used as variable name`))}const n="string"==typeof e?Object.assign({query:e},r):e,i=Object.keys(n).reduce(((t,e)=>F.includes(e)?(t[e]=n[e],t):(t.variables||(t.variables={}),t.variables[e]=n[e],t)),{}),o=n.baseUrl||t.endpoint.DEFAULTS.baseUrl;return M.test(o)&&(i.url=o.replace(M,"/api/graphql")),t(i).then((t=>{if(t.data.errors){const e={};for(const r of Object.keys(t.headers))e[r]=t.headers[r];throw new D(i,e,t.data)}return t.data.data}))}(r,t,e)),{defaults:A.bind(null,r),endpoint:r.endpoint})}A(q,{headers:{"user-agent":`octokit-graphql.js/5.0.6 ${n()}`},method:"POST",url:"/graphql"});const k=/^v1\./,x=/^ghs_/,_=/^ghu_/;async function T(t){const e=3===t.split(/\./).length,r=k.test(t)||x.test(t),n=_.test(t);return{type:"token",token:t,tokenType:e?"app":r?"installation":n?"user-to-server":"oauth"}}async function I(t,e,r,n){const i=e.endpoint.merge(r,n);return i.headers.authorization=function(t){return 3===t.split(/\./).length?`bearer ${t}`:`token ${t}`}(t),e(i)}const B=function(t){if(!t)throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");if("string"!=typeof t)throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");return t=t.replace(/^(token|bearer) +/i,""),Object.assign(T.bind(null,t),{hook:I.bind(null,t)})};var O="4.2.4",j=class{static defaults(t){return class extends(this){constructor(...e){const r=e[0]||{};super("function"!=typeof t?Object.assign({},t,r,r.userAgent&&t.userAgent?{userAgent:`${r.userAgent} ${t.userAgent}`}:null):t(r))}}}static plugin(...t){var e;const r=this.plugins;return(e=class extends(this){}).plugins=r.concat(t.filter((t=>!r.includes(t)))),e}constructor(t={}){const e=new i.Collection,r={baseUrl:q.endpoint.DEFAULTS.baseUrl,headers:{},request:Object.assign({},t.request,{hook:e.bind(null,"request")}),mediaType:{previews:[],format:""}};var o;if(r.headers["user-agent"]=[t.userAgent,`octokit-core.js/${O} ${n()}`].filter(Boolean).join(" "),t.baseUrl&&(r.baseUrl=t.baseUrl),t.previews&&(r.mediaType.previews=t.previews),t.timeZone&&(r.headers["time-zone"]=t.timeZone),this.request=q.defaults(r),this.graphql=(o=this.request,A(o,{method:"POST",url:"/graphql"})).defaults(r),this.log=Object.assign({debug:()=>{},info:()=>{},warn:console.warn.bind(console),error:console.error.bind(console)},t.log),this.hook=e,t.authStrategy){const{authStrategy:r,...n}=t,i=r(Object.assign({request:this.request,log:this.log,octokit:this,octokitOptions:n},t.auth));e.wrap("request",i.hook),this.auth=i}else if(t.auth){const r=B(t.auth);e.wrap("request",r.hook),this.auth=r}else this.auth=async()=>({type:"unauthenticated"});this.constructor.plugins.forEach((e=>{Object.assign(this,e(this,t))}))}};j.VERSION=O,j.plugins=[];var N=r(9496),L=r(1177),Y=r(7338),V=r(4575),z=r(2380),W=r(4321),Q=r(2075),K=r(7925),X=r(2800),J=r(5148),Z=r(4241),tt=r(4336),et=r(8227),rt=r(6004),nt=r(6398),it=r(4627),ot=r(4550),st=r(3878),at=Object.defineProperty,ut=Object.getOwnPropertyDescriptor,lt=(t,e,r,n)=>{for(var i,o=n>1?void 0:n?ut(e,r):e,s=t.length-1;s>=0;s--)(i=t[s])&&(o=(n?i(e,r,o):i(o))||o);return n&&o&&at(e,r,o),o};const ct=Object.freeze({values:[]}),ht=Object.freeze({ranges:[]}),dt="\nassignees(first: 10) {\n\tnodes {\n\t\tlogin\n\t\tavatarUrl\n\t\turl\n\t}\n}\nauthor {\n\tlogin\n\tavatarUrl\n\turl\n}\nbaseRefName\nbaseRefOid\nbaseRepository {\n\tname\n\towner {\n\t\tlogin\n\t}\n\turl\n}\nchecksUrl\nisDraft\nisCrossRepository\nisReadByViewer\nheadRefName\nheadRefOid\nheadRepository {\n\tname\n\towner {\n\t\tlogin\n\t}\n\turl\n}\npermalink\nnumber\ntitle\nstate\nadditions\ndeletions\nupdatedAt\nclosedAt\nmergeable\nmergedAt\nmergedBy {\n\tlogin\n}\nrepository {\n\tisFork\n\towner {\n\t\tlogin\n\t}\n}\nreviewDecision\nreviewRequests(first: 10) {\n\tnodes {\n\t\tasCodeOwner\n\t\tid\n\t\trequestedReviewer {\n\t\t\t... on User {\n\t\t\t\tlogin\n\t\t\t\tavatarUrl\n\t\t\t\turl\n\t\t\t}\n\t\t}\n\t}\n}\ntotalCommentsCount\n",mt="\n... on Issue {\n\tassignees(first: 100) {\n\t\tnodes {\n\t\t\tlogin\n\t\t\turl\n\t\t\tavatarUrl\n\t\t}\n\t}\n\tauthor {\n\t\tlogin\n\t\tavatarUrl\n\t\turl\n\t}\n\tcomments {\n\t  totalCount\n\t}\n\tnumber\n\ttitle\n\turl\n\tcreatedAt\n\tclosedAt\n\tclosed\n\tupdatedAt\n\tlabels(first: 20) {\n\t\tnodes {\n\t\t\tcolor\n\t\t\tname\n\t\t}\n\t}\n\treactions(content: THUMBS_UP) {\n\t  totalCount\n\t}\n\trepository {\n\t\tname\n\t\towner {\n\t\t\tlogin\n\t\t}\n\t}\n}\n";class GitHubApi{_onDidReauthenticate=new N.EventEmitter;get onDidReauthenticate(){return this._onDidReauthenticate.event}_disposable;constructor(t){this._disposable=J.D.onDidChangeAny((t=>{(J.D.changedAny(t,["http.proxy","http.proxyStrictSSL"])||J.D.changed(t,["outputLevel","proxy"]))&&this.resetCaches()}))}dispose(){this._disposable.dispose()}resetCaches(){this._proxyAgent=null,this._octokits.clear(),this._enterpriseVersions.clear()}_proxyAgent=null;get proxyAgent(){if(!Y.$L)return null===this._proxyAgent&&(this._proxyAgent=(0,L.Nx)()),this._proxyAgent}async getAccountForCommit(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getAccountForCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: GitObjectID!\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $ref) {\n\t\t\t... on Commit {\n\t\t\t\tauthor {\n\t\t\t\t\tname\n\t\t\t\t\temail\n\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,ref:i},s),l=u?.repository?.object?.author;if(null==l)return;return{provider:t,name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||pt(o)?l.avatarUrl??void 0:l.email&&null!=o?.baseUrl?await this.createEnterpriseAvatarUrl(t,e,o.baseUrl,l.email,o.avatarSize):void 0}}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,s)}}async getAccountForEmail(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getAccountForEmail(\n\t$emailQuery: String!\n\t$avatarSize: Int\n) {\n\tsearch(type: USER, query: $emailQuery, first: 1) {\n\t\tnodes {\n\t\t\t... on User {\n\t\t\t\tname\n\t\t\t\temail\n\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,emailQuery:`in:email ${i}`},s),l=u?.search?.nodes?.[0];if(null==l)return;return{provider:t,name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||pt(o)?l.avatarUrl??void 0:l.email&&null!=o?.baseUrl?await this.createEnterpriseAvatarUrl(t,e,o.baseUrl,l.email,o.avatarSize):void 0}}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,s)}}async getDefaultBranch(t,e,r,n,i){const o=(0,rt.UH)();try{const s="query getDefaultBranch(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tdefaultBranchRef {\n\t\t\tname\n\t\t}\n\t}\n}",a=await this.graphql(t,e,s,{...i,owner:r,repo:n},o),u=a?.repository?.defaultBranchRef?.name??void 0;if(null==u)return;return{provider:t,name:u}}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,o)}}async getIssueOrPullRequest(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getIssueOrPullRequest(\n\t$owner: String!\n\t$repo: String!\n\t$number: Int!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tissueOrPullRequest(number: $number) {\n\t\t\t__typename\n\t\t\t... on Issue {\n\t\t\t\tcreatedAt\n\t\t\t\tclosed\n\t\t\t\tclosedAt\n\t\t\t\ttitle\n\t\t\t\turl\n\t\t\t}\n\t\t\t... on PullRequest {\n\t\t\t\tcreatedAt\n\t\t\t\tclosed\n\t\t\t\tclosedAt\n\t\t\t\ttitle\n\t\t\t\turl\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,number:i},s),l=u?.repository?.issueOrPullRequest;if(null==l)return;return{provider:t,type:l.type,id:String(i),date:new Date(l.createdAt),title:l.title,closed:l.closed,closedDate:null==l.closedAt?void 0:new Date(l.closedAt),url:l.url}}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,s)}}async getPullRequestForBranch(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getPullRequestForBranch(\n\t$owner: String!\n\t$repo: String!\n\t$branch: String!\n\t$limit: Int!\n\t$include: [PullRequestState!]\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tref(qualifiedName: $branch) {\n\t\t\tassociatedPullRequests(first: $limit, orderBy: {field: UPDATED_AT, direction: DESC}, states: $include) {\n\t\t\t\tnodes {\n\t\t\t\t\tauthor {\n\t\t\t\t\t\tlogin\n\t\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t\t\turl\n\t\t\t\t\t}\n\t\t\t\t\tpermalink\n\t\t\t\t\tnumber\n\t\t\t\t\ttitle\n\t\t\t\t\tstate\n\t\t\t\t\tupdatedAt\n\t\t\t\t\tclosedAt\n\t\t\t\t\tmergedAt\n\t\t\t\t\trepository {\n\t\t\t\t\t\tisFork\n\t\t\t\t\t\towner {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,branch:`refs/heads/${i}`,limit:10},s),l=u?.repository?.ref?.associatedPullRequests?.nodes?.filter((t=>null!=t&&(!t.repository.isFork||t.repository.owner.login===r)));if(null==l||0===l.length)return;return l.length>1&&l.sort(((t,e)=>(t.repository.owner.login===r?-1:1)-(e.repository.owner.login===r?-1:1)||("OPEN"===t.state?-1:1)-("OPEN"===e.state?-1:1)||new Date(e.updatedAt).getTime()-new Date(t.updatedAt).getTime())),(0,st.fromGitHubPullRequest)(l[0],t)}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,s)}}async getPullRequestForCommit(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getPullRequestForCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: GitObjectID!\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $ref) {\n\t\t\t... on Commit {\n\t\t\t\tassociatedPullRequests(first: 2, orderBy: {field: UPDATED_AT, direction: DESC}) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t\t\t\turl\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpermalink\n\t\t\t\t\t\tnumber\n\t\t\t\t\t\ttitle\n\t\t\t\t\t\tstate\n\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\tclosedAt\n\t\t\t\t\t\tmergedAt\n\t\t\t\t\t\trepository {\n\t\t\t\t\t\t\tisFork\n\t\t\t\t\t\t\towner {\n\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,ref:i},s),l=u?.repository?.object?.associatedPullRequests?.nodes?.filter((t=>null!=t&&(!t.repository.isFork||t.repository.owner.login===r)));if(null==l||0===l.length)return;return l.length>1&&l.sort(((t,e)=>(t.repository.owner.login===r?-1:1)-(e.repository.owner.login===r?-1:1)||("MERGED"===t.state?-1:1)-("MERGED"===e.state?-1:1)||new Date(e.updatedAt).getTime()-new Date(t.updatedAt).getTime())),(0,st.fromGitHubPullRequest)(l[0],t)}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,s)}}async getRepositoryMetadata(t,e,r,n,i){const o=(0,rt.UH)();try{const s="query getRepositoryMetadata(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\towner {\n\t\t\tlogin\n\t\t}\n\t\tname\n\t\tparent {\n\t\t\towner {\n\t\t\t\tlogin\n\t\t\t}\n\t\t\tname\n\t\t}\n\t}\n}",a=await this.graphql(t,e,s,{...i,owner:r,repo:n},o),u=a?.repository??void 0;if(null==u)return;return{provider:t,owner:u.owner.login,name:u.name,isFork:null!=u.parent,parent:null!=u.parent?{owner:u.parent.owner.login,name:u.parent.name}:void 0}}catch(e){if(e instanceof V.Ww)return;throw this.handleException(e,t,o)}}async getBlame(t,e,r,n,i){const o=(0,rt.UH)();try{const s="query getBlameRanges(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String!\n) {\n\tviewer { name }\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\t...on Commit {\n\t\t\t\tblame(path: $path) {\n\t\t\t\t\tranges {\n\t\t\t\t\t\tstartingLine\n\t\t\t\t\t\tendingLine\n\t\t\t\t\t\tcommit {\n\t\t\t\t\t\t\toid\n\t\t\t\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\tadditions\n\t\t\t\t\t\t\tchangedFiles\n\t\t\t\t\t\t\tdeletions\n\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcommitter {\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i},o);if(null==a)return ht;const u=a.repository?.object?.blame?.ranges;return null==u||0===u.length?{ranges:[],viewer:a.viewer?.name}:{ranges:u,viewer:a.viewer?.name}}catch(t){if(t instanceof V.Ww)return ht;throw this.handleException(t,void 0,o)}}async getBranches(t,e,r,n){const i=(0,rt.UH)();try{const o='query getBranches(\n\t$owner: String!\n\t$repo: String!\n\t$branchQuery: String\n\t$cursor: String\n\t$limit: Int = 100\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(query: $branchQuery, refPrefix: "refs/heads/", first: $limit, after: $cursor) {\n\t\t\tpageInfo {\n\t\t\t\tendCursor\n\t\t\t\thasNextPage\n\t\t\t}\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\toid\n\t\t\t\t\t...on Commit {\n\t\t\t\t\t\tauthoredDate\n\t\t\t\t\t\tcommittedDate\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',s=await this.graphql(void 0,t,o,{owner:e,repo:r,branchQuery:n?.query,cursor:n?.cursor,limit:Math.min(100,n?.limit??100)},i);if(null==s)return ct;const a=s.repository?.refs;return null==a?ct:{paging:{cursor:a.pageInfo.endCursor,more:a.pageInfo.hasNextPage},values:a.nodes}}catch(t){if(t instanceof V.Ww)return ct;throw this.handleException(t,void 0,i)}}async getCommit(t,e,r,n){const i=(0,rt.UH)();try{const o=await this.request(void 0,t,"GET /repos/{owner}/{repo}/commits/{ref}",{owner:e,repo:r,ref:n},i),s=o?.data;if(null==s)return;const{commit:a}=s;return{oid:s.sha,parents:{nodes:s.parents.map((t=>({oid:t.sha})))},message:a.message,additions:s.stats?.additions,changedFiles:s.files?.length,deletions:s.stats?.deletions,author:{avatarUrl:s.author?.avatar_url??void 0,date:a.author?.date??(new Date).toString(),email:a.author?.email??void 0,name:a.author?.name??""},committer:{date:a.committer?.date??(new Date).toString(),email:a.committer?.email??void 0,name:a.committer?.name??""},files:s.files}}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,i)}}async getCommitForFile(t,e,r,n,i){if((0,W.D3)(n))return this.getCommit(t,e,r,n);const o=await this.getCommits(t,e,r,n,{limit:1,path:i});if(0===o.values.length)return;return{...await this.getCommit(t,e,r,o.values[0].oid)??o.values[0],viewer:o.viewer}}async getCommitBranches(t,e,r,n,i){const o=(0,rt.UH)();try{const s='query getCommitBranches(\n\t$owner: String!\n\t$repo: String!\n\t$since: GitTimestamp!\n\t$until: GitTimestamp!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(first: 20, refPrefix: "refs/heads/") {\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\t... on Commit {\n\t\t\t\t\t\thistory(first: 3, since: $since until: $until) {\n\t\t\t\t\t\t\tnodes { oid }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',a=await this.graphql(void 0,t,s,{owner:e,repo:r,since:i.toISOString(),until:i.toISOString()},o),u=a?.repository?.refs?.nodes;if(null==u)return[];const l=[];for(const t of u)for(const e of t.target.history.nodes)if(e.oid===n){l.push(t.name);break}return l}catch(t){if(t instanceof V.Ww)return[];throw this.handleException(t,void 0,o)}}async getCommitCount(t,e,r,n){const i=(0,rt.UH)();try{const o="query getCommitCount(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tref(qualifiedName: $ref) {\n\t\t\ttarget {\n\t\t\t\t... on Commit {\n\t\t\t\t\thistory(first: 1) {\n\t\t\t\t\t\ttotalCount\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,ref:n},i),a=s?.repository?.ref?.target.history.totalCount;return a}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,i)}}async getCommitOnBranch(t,e,r,n,i,o){const s=(0,rt.UH)();try{const a="query getCommitOnBranch(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$since: GitTimestamp!\n\t$until: GitTimestamp!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tref(qualifiedName: $ref) {\n\t\t\ttarget {\n\t\t\t\t... on Commit {\n\t\t\t\t\thistory(first: 3, since: $since until: $until) {\n\t\t\t\t\t\tnodes { oid }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(void 0,t,a,{owner:e,repo:r,ref:`refs/heads/${n}`,since:o.toISOString(),until:o.toISOString()},s),l=u?.repository?.ref.target.history.nodes;if(null==l)return[];const c=[];for(const t of l)if(t.oid===i){c.push(n);break}return c}catch(t){if(t instanceof V.Ww)return[];throw this.handleException(t,void 0,s)}}async getCommits(t,e,r,n,i){const o=(0,rt.UH)();if(1===i?.limit&&null==i?.path)return this.getCommitsCoreSingle(t,e,r,n);try{const s="query getCommits(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String\n\t$author: CommitAuthor\n\t$after: String\n\t$before: String\n\t$limit: Int = 100\n\t$since: GitTimestamp\n\t$until: GitTimestamp\n) {\n\tviewer { name }\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: $limit, author: $author, path: $path, after: $after, before: $before, since: $since, until: $until) {\n\t\t\t\t\tpageInfo {\n\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\tendCursor\n\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\thasPreviousPage\n\t\t\t\t\t}\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t... on Commit {\n\t\t\t\t\t\t\toid\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\t\t\t\tadditions\n\t\t\t\t\t\t\tchangedFiles\n\t\t\t\t\t\t\tdeletions\n\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcommitter {\n\t\t\t\t\t\t\t\t date\n\t\t\t\t\t\t\t\t email\n\t\t\t\t\t\t\t\t name\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}";let a;if(null!=i?.authors)if(1===i.authors.length){const[t]=i.authors;a={id:t.id,emails:t.email?[t.email]:void 0}}else{const t=i.authors.filter((t=>t.email)).map((t=>t.email));a=t.length?{emails:t}:void 0}const u=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,after:i?.after,before:i?.before,path:i?.path,author:a,limit:Math.min(100,i?.limit??100),since:"string"==typeof i?.since?i?.since:i?.since?.toISOString(),until:"string"==typeof i?.until?i?.until:i?.until?.toISOString()},o),l=u?.repository?.object?.history;return null==l?ct:{paging:null!=l.pageInfo.endCursor?{cursor:l.pageInfo.endCursor??void 0,more:l.pageInfo.hasNextPage}:void 0,values:l.nodes,viewer:u?.viewer.name}}catch(t){if(t instanceof V.Ww)return ct;throw this.handleException(t,void 0,o)}}async getCommitsCoreSingle(t,e,r,n){const i=(0,rt.UH)();try{const o="query getCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\tviewer { name }\n\trepository(name: $repo owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t...on Commit {\n\t\t\t\toid\n\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\tmessage\n\t\t\t\tadditions\n\t\t\t\tchangedFiles\n\t\t\t\tdeletions\n\t\t\t\tauthor {\n\t\t\t\t\tavatarUrl\n\t\t\t\t\tdate\n\t\t\t\t\temail\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t\tcommitter {\n\t\t\t\t\tdate\n\t\t\t\t\temail\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,ref:n},i);if(null==s)return ct;const a=s.repository?.object;return null!=a?{values:[a],viewer:s.viewer.name}:ct}catch(t){if(t instanceof V.Ww)return ct;throw this.handleException(t,void 0,i)}}async getCommitRefs(t,e,r,n,i){const o=(0,rt.UH)();try{const s="query getCommitRefs(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$after: String\n\t$before: String\n\t$first: Int\n\t$last: Int\n\t$path: String\n\t$since: GitTimestamp\n\t$until: GitTimestamp\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: $first, last: $last, path: $path, since: $since, until: $until, after: $after, before: $before) {\n\t\t\t\t\tpageInfo { startCursor, endCursor, hasNextPage, hasPreviousPage }\n\t\t\t\t\ttotalCount\n\t\t\t\t\tnodes { oid }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i?.path,first:i?.first,last:i?.last,after:i?.after,before:i?.before,since:i?.since,until:i?.until},o),u=a?.repository?.object?.history;if(null==u)return;return{pageInfo:u.pageInfo,totalCount:u.totalCount,values:u.nodes}}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,o)}}async getNextCommitRefs(t,e,r,n,i,o){const s=await this.getCommitDate(t,e,r,o);if(null==s)return[];let a=await this.getCommitRefs(t,e,r,n,{path:i,first:1,since:s});if(null==a)return[];const u=`${a.pageInfo.startCursor.split(" ",1)[0]} ${a.totalCount}`;let l;if([,l]=u.split(" ",2),l=Math.min(parseInt(l,10),5),a=await this.getCommitRefs(t,e,r,n,{path:i,last:l,before:u}),null==a)return[];const c=[];for(const{oid:t}of a.values){if(t===o)break;c.push(t)}return c.reverse()}async getCommitDate(t,e,r,n){const i=(0,rt.UH)();try{const o="query getCommitDate(\n\t$owner: String!\n\t$repo: String!\n\t$sha: GitObjectID!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $sha) {\n\t\t\t... on Commit { committer { date } }\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,sha:n},i),a=s?.repository?.object?.committer.date;return a}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,i)}}async getContributors(t,e,r){const n=(0,rt.UH)();try{const i=await this.request(void 0,t,"GET /repos/{owner}/{repo}/contributors",{owner:e,repo:r,per_page:100},n),o=i?.data;return null==o?[]:i.data}catch(t){if(t instanceof V.Ww)return[];throw this.handleException(t,void 0,n)}}async getDefaultBranchName(t,e,r){const n=(0,rt.UH)();try{const i="query getDefaultBranch(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tdefaultBranchRef {\n\t\t\tname\n\t\t}\n\t}\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o)return;return o.repository?.defaultBranchRef?.name??void 0}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,n)}}async getCurrentUser(t,e,r){const n=(0,rt.UH)();try{const i="query getCurrentUser(\n\t$owner: String!\n\t$repo: String!\n) {\n\tviewer { name, email, login, id }\n\trepository(owner: $owner, name: $repo) { viewerPermission }\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o)return;return{name:o.viewer?.name,email:o.viewer?.email,username:o.viewer?.login,id:o.viewer?.id}}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,n)}}async getRepositoryVisibility(t,e,r){const n=(0,rt.UH)();try{const i="query getRepositoryVisibility(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tvisibility\n\t}\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o?.repository?.visibility)return;return"PUBLIC"===o.repository.visibility?z.q4.Public:z.q4.Private}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,n)}}async getTags(t,e,r,n){const i=(0,rt.UH)();try{const o='query getTags(\n\t$owner: String!\n\t$repo: String!\n\t$tagQuery: String\n\t$cursor: String\n\t$limit: Int = 100\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(query: $tagQuery, refPrefix: "refs/tags/", first: $limit, after: $cursor, orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {\n\t\t\tpageInfo {\n\t\t\t\tendCursor\n\t\t\t\thasNextPage\n\t\t\t}\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\toid\n\t\t\t\t\t...on Tag {\n\t\t\t\t\t\tmessage\n\t\t\t\t\t\ttagger { date }\n\t\t\t\t\t\ttarget {\n\t\t\t\t\t...on Commit {\n\t\t\t\t\t\t\t\toid\n\t\t\t\t\t\tauthoredDate\n\t\t\t\t\t\tcommittedDate\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',s=await this.graphql(void 0,t,o,{owner:e,repo:r,tagQuery:n?.query,cursor:n?.cursor,limit:Math.min(100,n?.limit??100)},i);if(null==s)return ct;const a=s.repository?.refs;return null==a?ct:{paging:{cursor:a.pageInfo.endCursor,more:a.pageInfo.hasNextPage},values:a.nodes}}catch(t){if(t instanceof V.Ww)return ct;throw this.handleException(t,void 0,i)}}async resolveReference(t,e,r,n,i){const o=(0,rt.UH)();try{if(!i){const i="query resolveReference(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\toid\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,i,{owner:e,repo:r,ref:n},o);return s?.repository?.object?.oid??void 0}const s="query resolveReference(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: 1, path: $path) {\n\t\t\t\t\tnodes { oid }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i},o);return a?.repository?.object?.history.nodes?.[0]?.oid??void 0}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,o)}}async searchCommits(t,e,r){const n=(0,rt.UH)(),i=Math.min(100,r?.limit??100);let o,s,a;null!=r?.cursor?([o,s,a]=r.cursor.split(" ",3),o=parseInt(o,10),s=parseInt(s,10),a=parseInt(a,10)):(o=1,s=i,a=0);try{const i=await this.request(void 0,t,"GET /search/commits",{q:e,sort:r?.sort,order:r?.order,per_page:s,page:o},n),u=i?.data;if(null==u||0===u.items.length)return;const l=u.items.map((t=>({oid:t.sha,parents:{nodes:t.parents.map((t=>({oid:t.sha})))},message:t.commit.message,author:{avatarUrl:t.author?.avatar_url??void 0,date:t.commit.author?.date??t.commit.author?.date??(new Date).toString(),email:t.author?.email??t.commit.author?.email??void 0,name:t.author?.name??t.commit.author?.name??""},committer:{date:t.commit.committer?.date??t.committer?.date??(new Date).toString(),email:t.committer?.email??t.commit.committer?.email??void 0,name:t.committer?.name??t.commit.committer?.name??""}}))),c=a+u.items.length,h=u.incomplete_results||u.total_count>c;return{pageInfo:{startCursor:`${o} ${s} ${a}`,endCursor:h?`${o+1} ${s} ${c}`:void 0,hasPreviousPage:u.total_count>0&&o>1,hasNextPage:h},totalCount:u.total_count,values:l}}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,n)}}async searchCommitShas(t,e,r){const n=(0,rt.UH)(),i=Math.min(100,r?.limit??100);let o,s,a;null!=r?.cursor?([o,s,a]=r.cursor.split(" ",3),o=parseInt(o,10),s=parseInt(s,10),a=parseInt(a,10)):(o=1,s=i,a=0);try{const i=await this.request(void 0,t,"GET /search/commits",{q:e,sort:r?.sort,order:r?.order,per_page:s,page:o},n),u=i?.data;if(null==u||0===u.items.length)return;const l=a+u.items.length,c=u.incomplete_results||u.total_count>l;return{pageInfo:{startCursor:`${o} ${s} ${a}`,endCursor:c?`${o+1} ${s} ${l}`:void 0,hasPreviousPage:u.total_count>0&&o>1,hasNextPage:c},totalCount:u.total_count,values:u.items.map((t=>({sha:t.sha,authorDate:new Date(t.commit.author.date).getTime(),committerDate:new Date(t.commit.committer?.date??t.commit.author.date).getTime()})))}}catch(t){if(t instanceof V.Ww)return;throw this.handleException(t,void 0,n)}}_enterpriseVersions=new Map;async getEnterpriseVersion(t,e,r){let n=this._enterpriseVersions.get(e);if(null!=n)return n;if(null===n)return;const i=(0,rt.UH)();try{const o=await this.request(t,e,"GET /meta",r,i),s=o?.data?.installed_version;n=s?(0,ot.mL)(s):null}catch(t){n=null}return this._enterpriseVersions.set(e,n),n??void 0}_octokits=new Map;octokit(t,e){let r=this._octokits.get(t);if(null==r){let n;if(Y.$L){let e=function(t,e){if(null!=e.headers){const{"user-agent":t,...r}=e.headers;t&&(e.headers=r)}return(0,L.he)(t,e)};n=j.defaults({auth:`token ${t}`,request:{fetch:e}})}else n=j.defaults({auth:`token ${t}`,request:{agent:this.proxyAgent}});r=new n(e),this._octokits.set(t,r),(tt.Yd.logLevel===et.i.Debug||tt.Yd.isDebugging)&&r.hook.wrap("request",(async(t,e)=>{const r=(0,nt.k)(`[GITHUB] ${e.method} ${e.url}`,{log:!1});try{return await t(e)}finally{let t;try{if("string"==typeof e.query){const r=/(^[^({\n]+)/.exec(e.query);t=` ${r?.[1].trim()??e.query}`}}catch{}r?.stop({message:t})}}))}return r}async graphql(t,e,r,n,i){try{return await(0,L.a_)(t?.getIgnoreSSLErrors()??!1,(()=>this.octokit(e).graphql(r,n)))}catch(r){if(r instanceof D){switch(r.errors?.[0]?.type){case"NOT_FOUND":throw new V.Ww(r);case"FORBIDDEN":throw new V._7("github",V.Jx.Forbidden,r);case"RATE_LIMITED":{let t;const n=r.headers?.["x-ratelimit-reset"];throw null!=n&&(t=parseInt(n,10),Number.isNaN(t)&&(t=void 0)),new V.yx(r,e,t)}}tt.Yd.isDebugging&&N.window.showErrorMessage(`GitHub request failed: ${r.errors?.[0]?.message??r.message}`)}else r instanceof RequestError?this.handleRequestError(t,e,r,i):tt.Yd.isDebugging&&N.window.showErrorMessage(`GitHub request failed: ${r.message}`);throw r}}async request(t,e,r,n,i){try{return await(0,L.a_)(t?.getIgnoreSSLErrors()??!1,(()=>this.octokit(e).request(r,n)))}catch(r){throw r instanceof RequestError?this.handleRequestError(t,e,r,i):tt.Yd.isDebugging&&N.window.showErrorMessage(`GitHub request failed: ${r.message}`),r}}handleRequestError(t,e,r,n){switch(r.status){case 404:case 410:case 422:throw new V.Ww(r);case 401:throw new V._7("github",V.Jx.Unauthorized,r);case 403:if(r.message.includes("rate limit")){let t;const n=r.response?.headers?.["x-ratelimit-reset"];throw null!=n&&(t=parseInt(n,10),Number.isNaN(t)&&(t=void 0)),new V.yx(r,e,t)}throw new V._7("github",V.Jx.Forbidden,r);case 500:return tt.Yd.error(r,n),void(null!=r.response&&(t?.trackRequestException(),(0,K.vF)(`${t?.name??"GitHub"} failed to respond and might be experiencing issues.${t?.custom?"":" Please visit the [GitHub status page](https://githubstatus.com) for more information."}`)));case 502:if(tt.Yd.error(r,n),r.message.includes("timeout"))return t?.trackRequestException(),void(0,K.s$)(t?.name??"GitHub");break;default:if(r.status>=400&&r.status<500)throw new V.Bn(r)}tt.Yd.error(r,n),tt.Yd.isDebugging&&N.window.showErrorMessage(`GitHub request failed: ${r.response?.errors?.[0]?.message??r.message}`)}handleException(t,e,r){return tt.Yd.error(t,r),t instanceof V._7&&this.showAuthenticationErrorMessage(t,e),t}async showAuthenticationErrorMessage(t,e){if(t.reason===V.Jx.Unauthorized||t.reason===V.Jx.Forbidden){const r="Reauthenticate";await N.window.showErrorMessage(`${t.message}. Would you like to try reauthenticating${t.reason===V.Jx.Forbidden?" to provide additional access":""}?`,r)===r&&(await(e?.reauthenticate()),this._onDidReauthenticate.fire())}else N.window.showErrorMessage(t.message)}async createEnterpriseAvatarUrl(t,e,r,n,i){i=i??16;const o=await this.getEnterpriseVersion(t,e,{baseUrl:r});if((0,ot.L5)(o,">= 3.0.0")){let o;const s=(0,Q.at)(n);null!=s&&N.Uri.parse(r).authority===s.authority&&(null!=s.userId?o=`${r}/enterprise/avatars/u/${encodeURIComponent(s.userId)}?s=${i}`:null!=s.login&&(o=`${r}/enterprise/avatars/${encodeURIComponent(s.login)}?s=${i}`)),null==o&&(o=`${r}/enterprise/avatars/u/e?email=${encodeURIComponent(n)}&s=${i}`);const a=await(0,L.a_)(t?.getIgnoreSSLErrors()??!1,(()=>(0,L.he)(o,{method:"GET",headers:{Authorization:`Bearer ${e}`}})));if(a.ok){const t=(0,it.US)(new Uint8Array(await a.arrayBuffer()));return`data:${a.headers.get("content-type")};base64,${t}`}}return`https://avatars.githubusercontent.com/u/e?email=${encodeURIComponent(n)}&s=${i}`}async searchMyPullRequests(t,e,r){const n=(0,rt.UH)();try{let i=function(e,r){return{pullRequest:(0,st.fromGitHubPullRequestDetailed)(e,t),reasons:r?[r]:[]}};const o=`query searchPullRequests(\n\t$authored: String!\n\t$assigned: String!\n\t$reviewRequested: String!\n\t$mentioned: String!\n) {\n\tauthored: search(first: 100, query: $authored, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${dt}\n\t\t\t}\n\t\t}\n\t}\n\tassigned: search(first: 100, query: $assigned, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${dt}\n\t\t\t}\n\t\t}\n\t}\n\treviewRequested: search(first: 100, query: $reviewRequested, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${dt}\n\t\t\t}\n\t\t}\n\t}\n\tmentioned: search(first: 100, query: $mentioned, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${dt}\n\t\t\t}\n\t\t}\n\t}\n}`;let s=r?.search?.trim()??"";if(r?.user&&(s+=` user:${r.user}`),null!=r?.repos&&r.repos.length>0){const t="  repo:";s+=`${t}${r.repos.join(t)}`}const a="is:pr is:open archived:false",u=await this.graphql(t,e,o,{authored:`${s} ${a} author:@me`.trim(),assigned:`${s} ${a} assignee:@me`.trim(),reviewRequested:`${s} ${a} review-requested:@me`.trim(),mentioned:`${s} ${a} mentions:@me`.trim(),baseUrl:r?.baseUrl},n);if(void 0===u)return[];return gt([...u.assigned.nodes.map((t=>i(t,"assigned"))),...u.reviewRequested.nodes.map((t=>i(t,"review-requested"))),...u.mentioned.nodes.map((t=>i(t,"mentioned"))),...u.authored.nodes.map((t=>i(t,"authored")))],(t=>t.pullRequest.url))}catch(e){throw this.handleException(e,t,n)}}async searchMyIssues(t,e,r){const n=(0,rt.UH)(),i=`query searchIssues(\n\t\t\t\t$authored: String!\n\t\t\t\t$assigned: String!\n\t\t\t\t$mentioned: String!\n\t\t\t) {\n\t\t\t\tauthored: search(first: 100, query: $authored, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${mt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassigned: search(first: 100, query: $assigned, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${mt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmentioned: search(first: 100, query: $mentioned, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${mt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`;let o=r?.search?.trim()??"";if(r?.user&&(o+=` user:${r.user}`),null!=r?.repos&&r.repos.length>0){const t="  repo:";o+=`${t}${r.repos.join(t)}`}const s="type:issue is:open archived:false";try{let a=function(e,r){return{issue:(0,st.fromGitHubIssueDetailed)(e,t),reasons:r?[r]:[]}};const u=await this.graphql(t,e,i,{authored:`${o} ${s} author:@me`.trim(),assigned:`${o} ${s} assignee:@me`.trim(),mentioned:`${o} ${s} mentions:@me`.trim(),baseUrl:r?.baseUrl},n);if(void 0===u)return[];return gt([...u.assigned.nodes.map((t=>a(t,"assigned"))),...u.mentioned.nodes.map((t=>a(t,"mentioned"))),...u.authored.nodes.map((t=>a(t,"authored")))],(t=>t.issue.url))}catch(e){throw this.handleException(e,t,n)}}}function pt(t){return null==t?.baseUrl||"https://api.github.com"===t.baseUrl}function gt(t,e){return(0,X.uw)(t,e,((t,e)=>(0!==e.reasons.length&&t.reasons.push(...e.reasons),t)))}lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForCommit",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForEmail",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getDefaultBranch",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getIssueOrPullRequest",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForBranch",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForCommit",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getRepositoryMetadata",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getBlame",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getBranches",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommit",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitForFile",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitBranches",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitCount",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitOnBranch",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommits",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitRefs",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getNextCommitRefs",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getContributors",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getDefaultBranchName",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCurrentUser",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getRepositoryVisibility",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getTags",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"resolveReference",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommits",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommitShas",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getEnterpriseVersion",1),lt([(0,Z.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"searchMyPullRequests",1),lt([(0,Z.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"searchMyIssues",1)},5168:(t,e,r)=>{r.r(e),r.d(e,{GitHubGitProvider:()=>GitHubGitProvider});var n=r(9496),i=r(6150),o=r(5255),s=r(3148),a=r(4575),u=r(8887),l=r(6592),c=r(2380),h=r(7462),d=r(5367),m=r(6450),p=r(439),g=r(1719),f=r(7881),y=r(5069),w=r(4321),v=r(3050),b=r(3646),C=r(827),$=r(9502),R=r(3961),P=r(7552),G=r(6934),S=r(5148),H=r(2061),U=r(5432),q=r(4241),D=r(3105),F=r(4336),E=r(6004),M=r(3700),A=r(7469),k=r(9701),x=r(6700);async function _(t){try{const t=n.extensions.getExtension("ms-vscode.remote-repositories")??n.extensions.getExtension("GitHub.remotehub");if(null==t)throw F.Yd.log("GitHub Repositories extension is not installed or enabled"),new a.R5("GitHub Repositories","GitHub.remotehub");return t.isActive?t.exports:await t.activate()}catch(e){if(F.Yd.error(e,"Unable to get required api from the GitHub Repositories extension"),a.R5,t)return;throw e}}var T=(t=>(t[t.Branch=0]="Branch",t[t.RemoteBranch=1]="RemoteBranch",t[t.Tag=2]="Tag",t[t.Commit=3]="Commit",t))(T||{}),I=r(3878),B=Object.defineProperty,O=Object.getOwnPropertyDescriptor,j=(t,e,r,n)=>{for(var i,o=n>1?void 0:n?O(e,r):e,s=t.length-1;s>=0;s--)(i=t[s])&&(o=(n?i(e,r,o):i(o))||o);return n&&o&&B(e,r,o),o};const N=/"/g,L=Object.freeze([]),Y=Object.freeze({values:[]}),V=Promise.resolve(void 0),z=["repo","read:user","user:email"],W=/^[^/](?!.*\/\.)(?!.*\.\.)(?!.*\/\/)(?!.*@\{)[^\000-\037\177 ~^:?*[\\]+[^./]$/;class GitHubGitProvider{constructor(t){this.container=t,this._disposables.push(this.container.events.on("git:cache:reset",(t=>t.data.repoPath?this.resetCache(t.data.repoPath,...t.data.caches??L):this.resetCaches(...t.data.caches??L)),n.authentication.onDidChangeSessions(this.onAuthenticationSessionsChanged,this)))}descriptor={id:c.pq.GitHub,name:"GitHub",virtual:!0};supportedSchemes=new Set([o.sN.Virtual,o.sN.GitHub,o.sN.PRs]);_onDidChange=new n.EventEmitter;get onDidChange(){return this._onDidChange.event}_onDidChangeRepository=new n.EventEmitter;get onDidChangeRepository(){return this._onDidChangeRepository.event}_onDidCloseRepository=new n.EventEmitter;get onDidCloseRepository(){return this._onDidCloseRepository.event}_onDidOpenRepository=new n.EventEmitter;get onDidOpenRepository(){return this._onDidOpenRepository.event}_branchesCache=new Map;_repoInfoCache=new Map;_tagsCache=new Map;_disposables=[];dispose(){this._disposables.forEach((t=>{t.dispose()}))}onAuthenticationSessionsChanged(t){"github"===t.provider.id&&(this._sessionPromise=void 0,this.ensureSession(!1,!0))}onRepositoryChanged(t,e){this._branchesCache.delete(t.path),this._tagsCache.delete(t.path),this._repoInfoCache.delete(t.path),this._onDidChangeRepository.fire(e)}async discoverRepositories(t,e){if(!this.supportedSchemes.has(t.scheme))return[];try{const{remotehub:r}=await this.ensureRepositoryContext(t.toString(),!0),n=r.getVirtualWorkspaceUri(t);return null==n?[]:this.openRepository(void 0,n,!0,void 0,e?.silent)}catch(e){return e.message.startsWith("No provider registered with")&&(F.Yd.error(e,"No GitHub provider registered with Remote Repositories (yet); queuing pending discovery"),this._pendingDiscovery.add(t),this.ensurePendingRepositoryDiscovery()),[]}}_pendingDiscovery=new Set;_pendingTimer;ensurePendingRepositoryDiscovery(){null==this._pendingTimer&&0!==this._pendingDiscovery.size&&(this._pendingTimer=setTimeout((async()=>{try{const t=await _();for(const e of this._pendingDiscovery){if(null==t.getProvider(e))return this._pendingTimer=void 0,void this.ensurePendingRepositoryDiscovery();this._pendingDiscovery.delete(e)}this._pendingTimer=void 0,setTimeout((()=>this._onDidChange.fire()),1),0!==this._pendingDiscovery.size&&this.ensurePendingRepositoryDiscovery()}catch{this._pendingTimer=void 0,this.ensurePendingRepositoryDiscovery()}}),250))}updateContext(){(0,H.v)("gitlens:hasVirtualFolders",this.container.git.hasOpenRepositories(this.descriptor.id))}openRepository(t,e,r,i,o){return[new b._j(this.container,this.onRepositoryChanged.bind(this),this.descriptor,t,e,r,i??!n.window.state.focused,o)]}async supports(t){switch(t){case u.A.Stashes:case u.A.Worktrees:case u.A.StashOnlyStaged:return!1;default:return!0}}async visibility(t){const e=await this.getRemotes(t,{sort:!0});if(0===e.length)return[c.q4.Local,void 0];for await(const t of(0,A.rX)(e.map((t=>this.getRemoteVisibility(t)))))if("fulfilled"===t.status&&t.value[0]===c.q4.Public)return[c.q4.Public,(0,v.Ym)(t.value[1])];return[c.q4.Private,(0,v.Ym)(e)]}async getRemoteVisibility(t){if("github"===t.provider?.id){const{github:e,metadata:r,session:n}=await this.ensureRepositoryContext(t.repoPath);return[await e.getRepositoryVisibility(n.accessToken,r.repo.owner,r.repo.name)??c.q4.Private,t]}return[c.q4.Private,t]}async getOpenScmRepositories(){return[]}async getScmRepository(t){}async getOrOpenScmRepository(t){}canHandlePathOrUri(t,e){if(this.supportedSchemes.has(t))return"string"==typeof e?e:e.toString()}getAbsoluteUri(t,e){if("string"==typeof e){if(!(0,M.tE)(e))throw n.window.showErrorMessage(`Unable to get absolute uri between ${"string"==typeof t?t:t.toString(!0)} and ${e}; Base path '${e}' must be a uri`),new Error(`Base path '${e}' must be a uri`);e=n.Uri.parse(e,!0)}if("string"==typeof t&&!(0,M.tE)(t)){const r=(0,M.AH)(t);if(!(0,M.YP)(r))return n.Uri.joinPath(e,r)}const r=this.getRelativePath(t,e);return n.Uri.joinPath(e,r)}async getBestRevisionUri(t,e,r){return r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e)}getRelativePath(t,e){if("string"==typeof e){if(!(0,M.tE)(e))throw n.window.showErrorMessage(`Unable to get relative path between ${"string"==typeof t?t:t.toString(!0)} and ${e}; Base path '${e}' must be a uri`),new Error(`Base path '${e}' must be a uri`);e=n.Uri.parse(e,!0)}let r;if("string"==typeof t){if(!(0,M.tE)(t))return t=(0,M.AH)(t),r=(0,M.YP)(t)&&t.startsWith(e.path)?t.slice(e.path.length):t,r.charCodeAt(0)===o.mN.Slash&&(r=r.slice(1)),r;t=n.Uri.parse(t,!0)}return r=(0,M.AH)((0,M.Gf)(e.path.slice(1),t.path.slice(1))),r}getRevisionUri(t,e,r){const n=this.createProviderUri(t,r,e);return r===p.Ii?n.with({query:"~"}):n}async getWorkingUri(t,e){return this.createVirtualUri(t,void 0,e.path)}async addRemote(t,e,r,n){}async pruneRemote(t,e){}async removeRemote(t,e){}async applyChangesToWorkingFile(t,e,r){}async branchContainsCommit(t,e,r){return!1}async checkout(t,e,r){}resetCache(t,...e){(0===e.length||e.includes("branches"))&&this._branchesCache.delete(t),(0===e.length||e.includes("tags"))&&this._tagsCache.delete(t),0===e.length&&this._repoInfoCache.delete(t)}resetCaches(...t){(0===t.length||t.includes("branches"))&&this._branchesCache.clear(),(0===t.length||t.includes("tags"))&&this._tagsCache.clear(),0===t.length&&this._repoInfoCache.clear()}async excludeIgnoredUris(t,e){return e}async fetch(t,e){}async pull(t,e){}async push(t,e){}async findRepositoryUri(t,e){const r=(0,E.UH)();try{const e=await this.ensureRemoteHubApi();return e.getProviderRootUri(t).with({scheme:o.sN.Virtual})}catch(t){return a.R5,void F.Yd.error(t,r)}}async getAheadBehindCommitCount(t,e){}async getBlame(t,e){const r=(0,E.UH)();if(e?.isDirty)return;let n="blame";null!=t.sha&&(n+=`:${t.sha}`);const i=await this.container.tracker.getOrAdd(t);if(null!=i.state){const t=i.state.getBlame(n);if(null!=t)return F.Yd.debug(r,`Cache hit: '${n}'`),t.item}F.Yd.debug(r,`Cache miss: '${n}'`),null==i.state&&(i.state=new x.p2);const o=this.getBlameCore(t,i,n,r);if(null!=i.state){F.Yd.debug(r,`Cache add: '${n}'`);const t={item:o};i.state.setBlame(n,t)}return o}async getBlameCore(t,e,r,i){try{const e=await this.ensureRepositoryContext(t.repoPath);if(null==e)return;const{metadata:r,github:i,remotehub:s,session:a}=e,u=s.getVirtualUri(s.getProviderRootUri(t)),l=this.getRelativePath(t,u);if(t.scheme===o.sN.Virtual){const[e,r]=await Promise.allSettled([n.workspace.fs.stat(t),n.workspace.fs.stat(t.with({scheme:o.sN.GitHub}))]);if("fulfilled"!==e.status||"fulfilled"!==r.status||e.value.mtime!==r.value.mtime)return}const c=t.sha&&"HEAD"!==t.sha?t.sha:(await r.getRevision()).revision,h=await i.getBlame(a.accessToken,r.repo.owner,r.repo.name,c,l),d=new Map,p=new Map,g=[];for(const e of h.ranges){const r=e.commit,{viewer:n=a.account.label}=h,i=null!=n&&r.author.name===n?"You":r.author.name,o=null!=n&&r.committer.name===n?"You":r.committer.name;let s=d.get(i);null==s&&(s={name:i,lineCount:0},d.set(i,s)),s.lineCount+=e.endingLine-e.startingLine+1;let c=p.get(r.oid);null==c&&(c=new m.aM(this.container,t.repoPath,r.oid,new m._j(i,r.author.email,new Date(r.author.date),r.author.avatarUrl),new m._j(o,r.committer.email,new Date(r.author.date)),r.message.split("\n",1)[0],r.parents.nodes[0]?.oid?[r.parents.nodes[0]?.oid]:[],r.message,new f.K8(u.toString(),l,f.NV.Modified),{changedFiles:r.changedFiles??0,additions:r.additions??0,deletions:r.deletions??0},[]),p.set(r.oid,c));for(let t=e.startingLine;t<=e.endingLine;t++){const e={sha:r.oid,originalLine:t,line:t};c.lines.push(e),g[t-1]=e}}const y=new Map([...d.entries()].sort(((t,e)=>e[1].lineCount-t[1].lineCount)));return{repoPath:t.repoPath,authors:y,commits:p,lines:g}}catch(t){if(null!=e.state&&!String(t).includes("No provider registered with")){const n=t?.toString()??"";F.Yd.debug(i,`Cache replace (with empty promise): '${r}'`);const o={item:V,errorMessage:n};return e.state.setBlame(r,o),e.setBlameFailure(),V}return}}async getBlameContents(t,e){}async getBlameForLine(t,e,r,n){const i=(0,E.UH)();if(!r?.isDirty){if(!n?.forceSingleLine){const r=await this.getBlame(t);if(null==r)return;let n=r.lines[e];if(null==n){if(r.lines.length!==e)return;n=r.lines[e-1]}const i=r.commits.get(n.sha);if(null==i)return;return{author:{...r.authors.get(i.author.name),lineCount:i.lines.length},commit:i,line:n}}try{const r=await this.ensureRepositoryContext(t.repoPath);if(null==r)return;const{metadata:n,github:i,remotehub:o,session:s}=r,a=o.getVirtualUri(o.getProviderRootUri(t)),u=this.getRelativePath(t,a),l=t.sha&&"HEAD"!==t.sha?t.sha:(await n.getRevision()).revision,c=await i.getBlame(s.accessToken,n.repo.owner,n.repo.name,l,u),h=e+1,d=c.ranges.find((t=>t.startingLine===h));if(null==d)return;const p=d.commit,{viewer:g=s.account.label}=c,y=null!=g&&p.author.name===g?"You":p.author.name,w=null!=g&&p.committer.name===g?"You":p.committer.name,v=new m.aM(this.container,t.repoPath,p.oid,new m._j(y,p.author.email,new Date(p.author.date),p.author.avatarUrl),new m._j(w,p.committer.email,new Date(p.author.date)),p.message.split("\n",1)[0],p.parents.nodes[0]?.oid?[p.parents.nodes[0]?.oid]:[],p.message,new f.K8(a.toString(),u,f.NV.Modified),{changedFiles:p.changedFiles??0,additions:p.additions??0,deletions:p.deletions??0},[]);for(let t=d.startingLine;t<=d.endingLine;t++){const e={sha:p.oid,originalLine:t,line:t};v.lines.push(e)}return{author:{name:y,lineCount:d.endingLine-d.startingLine+1},commit:v,line:{sha:p.oid,originalLine:d.startingLine,line:d.startingLine}}}catch(t){return void F.Yd.error(i,t)}}}async getBlameForLineContents(t,e,r,n){}async getBlameForRange(t,e){const r=await this.getBlame(t);if(null!=r)return this.getBlameRange(r,t,e)}async getBlameForRangeContents(t,e,r){const n=await this.getBlameContents(t,r);if(null!=n)return this.getBlameRange(n,t,e)}getBlameRange(t,e,r){if(0===t.lines.length)return{allLines:t.lines,...t};if(0===r.start.line&&r.end.line===t.lines.length-1)return{allLines:t.lines,...t};const n=t.lines.slice(r.start.line,r.end.line+1),i=new Set(n.map((t=>t.sha))),o=r.start.line+1,s=r.end.line+1,a=new Map,u=new Map;for(const e of t.commits.values()){if(!i.has(e.sha))continue;const t=e.with({lines:e.lines.filter((t=>t.line>=o&&t.line<=s))});u.set(e.sha,t);let r=a.get(t.author.name);null==r&&(r={name:t.author.name,lineCount:0},a.set(r.name,r)),r.lineCount+=t.lines.length}const l=new Map([...a.entries()].sort(((t,e)=>e[1].lineCount-t[1].lineCount)));return{repoPath:e.repoPath,authors:l,commits:u,lines:n,allLines:t.lines}}async getBranch(t){const{values:[e]}=await this.getBranches(t,{filter:t=>t.current});return e}async getBranches(t,e){if(null==t)return Y;const r=(0,E.UH)();let n=e?.cursor?void 0:this._branchesCache.get(t);if(null==n){async function o(){try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=await r.getRevision(),s=0===o.type?o.name:void 0,a=[];let u=e?.cursor;const l=null==u;for(;;){const e=await n.getBranches(i.accessToken,r.repo.owner,r.repo.name,{cursor:u});for(const r of e.values){const e=new Date("author-date"===S.D.get("advanced.commitOrdering")?r.target.authoredDate:r.target.committedDate),n=r.target.oid;a.push(new d.XI(t,r.name,!1,r.name===s,e,n,{name:`origin/${r.name}`,missing:!1}),new d.XI(t,`origin/${r.name}`,!0,!1,e,n))}if(!e.paging?.more||!l)return{...e,values:a};u=e.paging.cursor}}catch(e){return F.Yd.error(e,r),this._branchesCache.delete(t),Y}}n=o.call(this),null==e?.cursor&&this._branchesCache.set(t,n)}let i=await n;return null!=e?.filter&&(i={...i,values:i.values.filter(e.filter)}),null!=e?.sort&&(0,d.YF)(i.values,"boolean"==typeof e.sort?void 0:e.sort),i}async getChangedFilesCount(t,e){if(!e)return;const r=await this.getCommit(t,e);if(null==r?.stats)return;const{stats:n}=r,i=(0,m.By)(n.changedFiles);return{additions:n.additions,deletions:n.deletions,changedFiles:i}}async getCommit(t,e){if(null==t)return;const r=(0,E.UH)();try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=await n.getCommit(i.accessToken,r.repo.owner,r.repo.name,e);if(null==o)return;const{viewer:s=i.account.label}=o,a=null!=s&&o.author.name===s?"You":o.author.name,u=null!=s&&o.committer.name===s?"You":o.committer.name;return new m.aM(this.container,t,o.oid,new m._j(a,o.author.email,new Date(o.author.date),o.author.avatarUrl),new m._j(u,o.committer.email,new Date(o.committer.date)),o.message.split("\n",1)[0],o.parents.nodes.map((t=>t.oid)),o.message,o.files?.map((e=>new f.K8(t,e.filename??"",(0,I.fromCommitFileStatus)(e.status)??f.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0})))??[],{changedFiles:o.changedFiles??0,additions:o.additions??0,deletions:o.deletions??0},[])}catch(t){return void F.Yd.error(t,r)}}async getCommitBranches(t,e,r){if(null==t||null==r?.commitDate)return[];const n=(0,E.UH)();try{const{metadata:n,github:i,session:o}=await this.ensureRepositoryContext(t);let s;return s=r?.branch?await i.getCommitOnBranch(o.accessToken,n.repo.owner,n.repo.name,r?.branch,e,r?.commitDate):await i.getCommitBranches(o.accessToken,n.repo.owner,n.repo.name,e,r?.commitDate),s}catch(t){return F.Yd.error(t,n),[]}}async getCommitCount(t,e){if(null==t)return;const r=(0,E.UH)();try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t);return await n.getCommitCount(i?.accessToken,r.repo.owner,r.repo.name,e)}catch(t){return void F.Yd.error(t,r)}}async getCommitForFile(t,e,r){if(null==t)return;const n=(0,E.UH)();try{const{metadata:n,github:i,remotehub:o,session:s}=await this.ensureRepositoryContext(t),a=this.getRelativePath(e,o.getProviderRootUri(e)),u=r?.ref&&"HEAD"!==r.ref?r.ref:(await n.getRevision()).revision,l=await i.getCommitForFile(s.accessToken,n.repo.owner,n.repo.name,u,a);if(null==l)return;const{viewer:c=s.account.label}=l,h=null!=c&&l.author.name===c?"You":l.author.name,d=null!=c&&l.committer.name===c?"You":l.committer.name,p=l.files?.map((e=>new f.K8(t,e.filename??"",(0,I.fromCommitFileStatus)(e.status)??f.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),g=p?.find((t=>t.path===a));return new m.aM(this.container,t,l.oid,new m._j(h,l.author.email,new Date(l.author.date),l.author.avatarUrl),new m._j(d,l.committer.email,new Date(l.committer.date)),l.message.split("\n",1)[0],l.parents.nodes.map((t=>t.oid)),l.message,{file:g,files:p},{changedFiles:l.changedFiles??0,additions:l.additions??0,deletions:l.deletions??0},[])}catch(t){return void F.Yd.error(t,n)}}async getCommitsForGraph(t,e,r){const n=r?.limit??S.D.get("graph.defaultItemLimit")??5e3,i=S.D.get("graph.commitOrdering",void 0,"date"),o=S.D.get("graph.avatars",void 0,!0),[s,a,u,l,c,h]=await Promise.allSettled([this.getLog(t,{all:!0,ordering:i,limit:n}),this.getBranch(t),this.getBranches(t,{filter:t=>t.remote}),this.getRemotes(t),this.getTags(t),this.getCurrentUser(t)]),d=new Map,m=(0,A.Sb)(a),p=new Map,g=new Map;null!=m&&(p.set(m.name,m),null!=m.sha&&g.set(m.sha,[m.name]));const f=(0,A.Sb)(u)?.values;if(null!=f)for(const t of f){if(p.set(t.name,t),null==t.sha)continue;const e=g.get(t.sha);null==e?g.set(t.sha,[t.name]):e.push(t.name)}const y=new Set,w=(0,A.Sb)(l)[0],v=null!=w?new Map([[w.name,w]]):new Map,b=new Map,C=(0,A.Sb)(c)?.values;if(null!=C)for(const t of C){if(null==t.sha)continue;const e=b.get(t.sha);null==e?b.set(t.sha,[t.name]):e.push(t.name)}return this.getCommitsForGraphCore(t,e,(0,A.Sb)(s),m,p,g,w,v,b,(0,A.Sb)(h),d,y,{...r,useAvatars:o})}async getCommitsForGraphCore(t,e,r,n,i,o,a,u,l,c,h,p,g){const f={...g?.include,stats:!0},b=new Map;if(null==r)return{repoPath:t,avatars:h,ids:p,includes:f,branches:i,remotes:u,downstreams:b,rows:[]};const C=(r.pagedCommits?.()??r.commits)?.values();if(null==C)return{repoPath:t,avatars:h,ids:p,includes:f,branches:i,remotes:u,downstreams:b,rows:[]};const R=[];let P,G,S,H,U,q,F,E,M,A,x=!1,_=!1;const T=n.upstream?.name;for(const r of C){if(p.add(r.sha),x=r.sha===n.sha,x)if(S={webviewItem:`gitlens:branch${x?"+current":""}${null!=n?.upstream?"+tracking":""}`,webviewItemValue:{type:"branch",ref:(0,w.xB)(n.name,t,{id:n.id,refType:"branch",name:n.name,remote:!1,upstream:n.upstream})}},U=[{id:n.id,name:n.name,isCurrentHead:!0,context:(0,k.BH)(S),upstream:null!=n.upstream?{name:n.upstream.name,id:(0,d.Vx)(t,!0,n.upstream.name)}:void 0}],null!=n.upstream){if(E=(0,d.Vx)(t,!0,n.name),P=((g?.useAvatars?a.provider?.avatarUri:void 0)??(0,v.dM)(this.container,a,e))?.toString(!0),S={webviewItem:"gitlens:branch+remote",webviewItemValue:{type:"branch",ref:(0,w.xB)(n.name,t,{id:E,refType:"branch",name:n.name,remote:!0,upstream:{name:a.name,missing:!1}})}},q=[{id:E,name:n.name,owner:a.name,url:a.url,avatarUrl:P,context:(0,k.BH)(S),current:!0}],null!=T){let t=b.get(T);null==t&&(t=[],b.set(T,t)),t.push(n.name)}}else q=[];else{U=[],q=[];const n=o.get(r.sha);if(null!=n)for(const r of n)E=(0,d.Vx)(t,!0,r),G=(0,d.S3)(r),P=((g?.useAvatars?a.provider?.avatarUri:void 0)??(0,v.dM)(this.container,a,e))?.toString(!0),S={webviewItem:"gitlens:branch+remote",webviewItemValue:{type:"branch",ref:(0,w.xB)(r,t,{id:E,refType:"branch",name:r,remote:!0,upstream:{name:a.name,missing:!1}})}},q.push({id:E,name:G,owner:a.name,url:a.url,avatarUrl:P,context:(0,k.BH)(S)})}F=[];const i=l.get(r.sha);if(null!=i)for(const e of i)A=(0,$.YU)(t,e),S={webviewItem:"gitlens:tag",webviewItemValue:{type:"tag",ref:(0,w.xB)(e,t,{id:A,refType:"tag",name:e})}},F.push({id:A,name:e,annotated:!0,context:(0,k.BH)(S)});if(r.author.email&&!h.has(r.author.email)){const t=r.getCachedAvatarUri();null!=t&&h.set(r.author.email,t.toString(!0))}_="You"===r.author.name,H={row:(0,k.BH)({webviewItem:`gitlens:commit${x?"+HEAD":""}+current`,webviewItemValue:{type:"commit",ref:(0,w.xB)(r.sha,t,{refType:"revision",message:r.message})}}),avatar:(0,k.BH)({webviewItem:"gitlens:contributor"+(_?"+current":""),webviewItemValue:{type:"contributor",repoPath:t,name:_&&null!=c?.name?c.name:r.author.name,email:r.author.email,current:_}})},R.push({sha:r.sha,parents:r.parents,author:r.author.name,email:r.author.email??"",date:r.committer.date.getTime(),message:(0,s.X)(r.message&&String(r.message).length?r.message:r.summary),type:r.parents.length>1?y.e.MergeCommit:y.e.Commit,heads:U,remotes:q,tags:F,contexts:H}),null!=r.stats&&(null==M&&(M=new Map),M.set(r.sha,{files:(0,m.By)(r.stats.changedFiles),additions:r.stats.additions,deletions:r.stats.deletions}))}return"HEAD"===g?.ref?g.ref=(0,D.Ps)(r.commits.values())?.sha:null!=g?.ref&&(g.ref=void 0),{repoPath:t,avatars:h,ids:p,includes:f,branches:i,remotes:u,downstreams:b,rows:R,id:g?.ref,paging:{limit:r.limit,startingCursor:r.startingCursor,hasMore:r.hasMore},more:async s=>{const d=await(r.more?.(s));return this.getCommitsForGraphCore(t,e,d,n,i,o,a,u,l,c,h,p,g)}}}async getContributors(t,e){if(null==t)return[];const r=(0,E.UH)();try{const{metadata:e,github:r,session:n}=await this.ensureRepositoryContext(t),i=await r.getContributors(n.accessToken,e.repo.owner,e.repo.name),o=await this.getCurrentUser(t),s=[];for(const e of i)"User"===e.type&&s.push(new g.V(t,e.name,e.email,e.contributions,void 0,(0,R.o)(o,e.name,e.email,e.login),void 0,e.login,e.avatar_url,e.node_id));return s}catch(t){return F.Yd.error(t,r),[]}}async getCurrentUser(t){if(!t)return;const e=(0,E.UH)(),r=this._repoInfoCache.get(t);let n=r?.user;if(null!=n)return n;if(null!==n)try{const{metadata:e,github:i,session:o}=await this.ensureRepositoryContext(t);return n=await i.getCurrentUser(o.accessToken,e.repo.owner,e.repo.name),this._repoInfoCache.set(t,{...r,user:n??null}),n}catch(n){return F.Yd.error(n,e),void this._repoInfoCache.set(t,{...r,user:null})}}async getDefaultBranchName(t,e){if(null==t)return;const r=(0,E.UH)();try{const{metadata:e,github:r,session:n}=await this.ensureRepositoryContext(t);return await r.getDefaultBranchName(n.accessToken,e.repo.owner,e.repo.name)}catch(t){return void F.Yd.error(t,r)}}async getDiffForFile(t,e,r){}async getDiffForFileContents(t,e,r){}async getDiffForLine(t,e,r,n){}async getDiffStatus(t,e,r,n){}async getFileStatusForCommit(t,e,r){if(r===p.Ii||(0,w.l3)(r))return;const n=await this.getCommitForFile(t,e,{ref:r});return null!=n?n.findFile(e):void 0}async getLastFetchedTimestamp(t){}async getLog(t,e){if(null==t)return;const r=(0,E.UH)(),n=this.getPagingLimit(e?.limit);try{const{metadata:r,github:i,session:o}=await this.ensureRepositoryContext(t),s=e?.ref&&"HEAD"!==e.ref?e.ref:(await r.getRevision()).revision,a=await i.getCommits(o.accessToken,r.repo.owner,r.repo.name,s,{all:e?.all,authors:e?.authors,after:e?.cursor,limit:n,since:e?.since?new Date(e.since):void 0}),u=new Map,{viewer:l=o.account.label}=a;for(const e of a.values){const r=null!=l&&e.author.name===l?"You":e.author.name,n=null!=l&&e.committer.name===l?"You":e.committer.name;let i=u.get(e.oid);null==i&&(i=new m.aM(this.container,t,e.oid,new m._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new m._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,e.files?.map((e=>new f.K8(t,e.filename??"",(0,I.fromCommitFileStatus)(e.status)??f.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),u.set(e.oid,i))}const c={repoPath:t,commits:u,sha:s,range:void 0,count:u.size,limit:n,hasMore:a.paging?.more??!1,endingCursor:a.paging?.cursor,query:r=>this.getLog(t,{...e,limit:r})};return c.hasMore&&(c.more=this.getLogMoreFn(c,e)),c}catch(t){return void F.Yd.error(t,r)}}async getLogRefsOnly(t,e){const r=await this.getLog(t,e);if(null!=r)return new Set([...r.commits.values()].map((t=>t.ref)))}getLogMoreFn(t,e){return async r=>{const n=null!=r&&"object"==typeof r?r.until:void 0;let i="number"==typeof r?r:void 0;if(n&&(0,D.G)(t.commits.values(),(t=>t.ref===n)))return t;i=this.getPagingLimit(i);const o=await this.getLog(t.repoPath,{...e,limit:i,cursor:t.endingCursor});if(null==o)return{...t,hasMore:!1,more:void 0};const s=new Map([...t.commits,...o.commits]),a={repoPath:t.repoPath,commits:s,sha:t.sha,range:void 0,count:s.size,limit:null==n?(t.limit??0)+i:void 0,hasMore:null!=n||o.hasMore,startingCursor:(0,D.Z$)(t.commits)?.[0],endingCursor:o.endingCursor,pagedCommits:()=>{for(const e of t.commits.keys())o.commits.delete(e);return o.commits},query:t.query};return a.hasMore&&(a.more=this.getLogMoreFn(a,e)),a}}async getLogForFile(t,e,r){if(null==t)return;const n=(0,E.UH)(),i=this.getRelativePath(e,t);if(null!=t&&t===i)throw new Error(`File name cannot match the repository path; path=${i}`);(r={reverse:!1,...r}).renames=!1,r.all=!1;let o="log";null!=r.ref&&(o+=`:${r.ref}`),r.limit=this.getPagingLimit(r?.limit),r.limit&&(o+=`:n${r.limit}`),r.renames&&(o+=":follow"),r.reverse&&(o+=":reverse"),r.since&&(o+=`:since=${r.since}`),r.skip&&(o+=`:skip${r.skip}`),r.cursor&&(o+=`:cursor=${r.cursor}`);const s=await this.container.tracker.getOrAdd(h.YY.fromFile(i,t,r.ref));if(!r.force&&null==r.range){if(null!=s.state){const i=s.state.getLog(o);if(null!=i)return F.Yd.debug(n,`Cache hit: '${o}'`),i.item;if(null!=r.ref||null!=r.limit){const i=s.state.getLog(`log${r.renames?":follow":""}${r.reverse?":reverse":""}`);if(null!=i){if(null==r.ref)return F.Yd.debug(n,`Cache hit: ~'${o}'`),i.item;F.Yd.debug(n,`Cache ?: '${o}'`);let s=await i.item;if(null!=s&&!s.hasMore&&s.commits.has(r.ref)){F.Yd.debug(n,`Cache hit: '${o}'`);let i=!0,a=0;const u=new Map((0,D.DZ)(s.commits.entries(),(([t,e])=>{if(i){if(t!==r?.ref)return;i=!1}if(a++,!(null!=r?.limit&&a>r.limit))return[t,e]}))),l={...r};return s={...s,limit:r.limit,count:u.size,commits:u,query:r=>this.getLogForFile(t,e,{...l,limit:r})},s}}}}F.Yd.debug(n,`Cache miss: '${o}'`),null==s.state&&(s.state=new x.p2)}const a=this.getLogForFileCore(t,i,s,o,n,r);if(null!=s.state&&null==r.range){F.Yd.debug(n,`Cache add: '${o}'`);const t={item:a};s.state.setLog(o,t)}return a}async getLogForFileCore(t,e,r,n,i,o){if(null==t)return;const s=this.getPagingLimit(o?.limit);try{const r=await this.ensureRepositoryContext(t);if(null==r)return;const{metadata:n,github:i,remotehub:a,session:u}=r,l=this.getAbsoluteUri(e,t),c=this.getRelativePath(l,a.getProviderRootUri(l)),h=o?.ref&&"HEAD"!==o.ref?o.ref:(await n.getRevision()).revision,d=await i.getCommits(u.accessToken,n.repo.owner,n.repo.name,h,{all:o?.all,after:o?.cursor,path:c,limit:s,since:o?.since?new Date(o.since):void 0}),p=new Map,{viewer:g=u.account.label}=d;for(const e of d.values){const r=null!=g&&e.author.name===g?"You":e.author.name,n=null!=g&&e.committer.name===g?"You":e.committer.name;let i=p.get(e.oid);if(null==i){const o=e.files?.map((e=>new f.K8(t,e.filename??"",(0,I.fromCommitFileStatus)(e.status)??f.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),s=(0,M.Mh)(c)?void 0:o?.find((t=>t.path===c))??new f.K8(t,c,f.NV.Modified,void 0,void 0,1===e.changedFiles?{additions:e.additions??0,deletions:e.deletions??0,changes:0}:void 0);i=new m.aM(this.container,t,e.oid,new m._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new m._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,{file:s,files:o},{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),p.set(e.oid,i)}}const y={repoPath:t,commits:p,sha:h,range:void 0,count:p.size,limit:s,hasMore:d.paging?.more??!1,endingCursor:d.paging?.cursor,query:r=>this.getLogForFile(t,e,{...o,limit:r})};return y.hasMore&&(y.more=this.getLogForFileMoreFn(y,e,o)),y}catch(t){if(null!=r.state&&null==o?.range&&!o?.reverse){const e=t?.toString()??"";F.Yd.debug(i,`Cache replace (with empty promise): '${n}'`);const o={item:V,errorMessage:e};return r.state.setLog(n,o),V}return}}getLogForFileMoreFn(t,e,r){return async n=>{const i=null!=n&&"object"==typeof n?n.until:void 0;let o="number"==typeof n?n:void 0;if(i&&(0,D.G)(t.commits.values(),(t=>t.ref===i)))return t;o=this.getPagingLimit(o);const s=await this.getLogForFile(t.repoPath,e,{...r,limit:null==i?o:0,cursor:t.endingCursor});if(null==s)return{...t,hasMore:!1,more:void 0};const a=new Map([...t.commits,...s.commits]),u={repoPath:t.repoPath,commits:a,sha:t.sha,range:t.range,count:a.size,limit:null==i?(t.limit??0)+o:void 0,hasMore:null!=i||s.hasMore,endingCursor:s.endingCursor,query:t.query};return u.hasMore&&(u.more=this.getLogForFileMoreFn(u,e,r)),u}}async getMergeBase(t,e,r,n){}async getMergeStatus(t){}async getRebaseStatus(t){}async getNextComparisonUris(t,e,r,n=0){if(!r)return;const i=(0,E.UH)();try{const i=await this.ensureRepositoryContext(t);if(null==i)return;const{metadata:o,github:s,remotehub:a,session:u}=i,l=this.getRelativePath(e,a.getProviderRootUri(e)),c=(await o.getRevision()).revision;"HEAD"===r&&(r=c);const d=await s.getNextCommitRefs(u.accessToken,o.repo.owner,o.repo.name,c,l,r);return{current:0===n?h.YY.fromFile(l,t,r):new h.YY(await this.getBestRevisionUri(t,l,d[n-1])),next:new h.YY(await this.getBestRevisionUri(t,l,d[n]))}}catch(t){throw F.Yd.error(t,i),t}}async getOldestUnpushedRefForFile(t,e){}async getPreviousComparisonUris(t,e,r,n=0,i=!1){if(r===p.Ii)return;const o=(0,E.UH)();r===p.CL&&(r=void 0);try{const i=await this.ensureRepositoryContext(t);if(null==i)return;const{metadata:o,github:s,remotehub:a,session:u}=i,l=this.getRelativePath(e,a.getProviderRootUri(e)),c=null!=r?1:0,d=await s.getCommitRefs(u.accessToken,o.repo.owner,o.repo.name,r&&"HEAD"!==r?r:(await o.getRevision()).revision,{path:l,first:c+n+1});if(null==d)return;const m=0===n?h.YY.fromFile(l,t,r):new h.YY(await this.getBestRevisionUri(t,l,d.values[c+n-1]?.oid??p.Ii));if(null==m||m.sha===p.Ii)return;return{current:m,previous:new h.YY(await this.getBestRevisionUri(t,l,d.values[c+n]?.oid??p.Ii))}}catch(t){throw F.Yd.error(t,o),t}}async getPreviousComparisonUrisForLine(t,e,r,n,i=0){if(n===p.Ii)return;const o=(0,E.UH)();try{const o=await this.ensureRepositoryContext(t);if(null==o)return;const{remotehub:s}=o;let a,u=this.getRelativePath(e,s.getProviderRootUri(e)),l=h.YY.fromFile(u,t,n),c=r,d=r,m=r;for(let e=0;e<Math.max(0,i)+2;e++){const e=await this.getBlameForLine(a??l,m,void 0,{forceSingleLine:!0});if(null==e)break;n=e.commit.sha,u=e.commit.file?.path??e.commit.file?.originalPath??u,m=e.line.originalLine-1;const r=h.YY.fromFile(u,t,n);null==a?(a=r,d=m):(l=a,c=d,a=r,d=m)}if(null==l)return;return{current:l,previous:a,line:(c??r)+1}}catch(t){throw F.Yd.error(t,o),t}}async getIncomingActivity(t,e){}async getRemotes(t,e){if(null==t)return[];const r=(0,P.v)(S.D.get("remotes",null)),i=n.Uri.parse(t,!0),[,o,s]=i.path.split("/",3),a=`https://github.com/${o}/${s}.git`,u="github.com",l=`${o}/${s}`;return[new v.ss(t,"origin","https",u,l,(0,P.B)(this.container,r)(a,u,l),[{type:v.XG.Fetch,url:a},{type:v.XG.Push,url:a}])]}async getRevisionContent(t,e,r){const i=r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e);return n.workspace.fs.readFile(i)}async getStash(t){}async getStatusForFile(t,e){}async getStatusForFiles(t,e){}async getStatusForRepo(t){if(null==t)return;const e=await this.ensureRepositoryContext(t);if(null==e)return;const r=await e.metadata.getRevision();return null!=r?new C.Hk(t,r.name,r.revision,[],{ahead:0,behind:0},r.type===T.Branch||r.type===T.RemoteBranch?`origin/${r.name}`:void 0):void 0}async getTags(t,e){if(null==t)return Y;const r=(0,E.UH)();let n=e?.cursor?void 0:this._tagsCache.get(t);if(null==n){async function o(){try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=[];let s=e?.cursor;const a=null==s;let u,l;for(;;){const e=await n.getTags(i.accessToken,r.repo.owner,r.repo.name,{cursor:s});for(const r of e.values)u=r.target.authoredDate??r.target.target?.authoredDate??r.target.tagger?.date,l=r.target.committedDate??r.target.target?.committedDate??r.target.tagger?.date,o.push(new $.gE(t,r.name,r.target.target?.oid??r.target.oid,r.target.message??r.target.target?.message??"",null!=u?new Date(u):void 0,null!=l?new Date(l):void 0));if(!e.paging?.more||!a)return{...e,values:o};s=e.paging.cursor}}catch(e){return F.Yd.error(e,r),this._tagsCache.delete(t),Y}}n=o.call(this),null==e?.cursor&&this._tagsCache.set(t,n)}let i=await n;return null!=e?.filter&&(i={...i,values:i.values.filter(e.filter)}),null!=e?.sort&&(0,$.Pj)(i.values,"boolean"==typeof e.sort?void 0:e.sort),i}async getTreeEntryForRevision(t,e,r){if(null==t||!e)return;if("HEAD"===r){const e=await this.ensureRepositoryContext(t);if(null==e)return;const n=await e.metadata.getRevision();r=n?.revision}const i=r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e),o=await n.workspace.fs.stat(i);return null!=o?{path:this.getRelativePath(i,t),commitSha:r,size:o.size,type:(o.type&n.FileType.Directory)===n.FileType.Directory?"tree":"blob"}:void 0}async getTreeForRevision(t,e){if(null==t)return[];if("HEAD"===e){const r=await this.ensureRepositoryContext(t);if(null==r)return[];const n=await r.metadata.getRevision();e=n?.revision}const r=e?this.createProviderUri(t,e):this.createVirtualUri(t,e),i=await n.workspace.fs.readDirectory(r);if(null==i)return[];const o=[];for(const[t,s]of i){const i=this.getAbsoluteUri(t,r);o.push({path:this.getRelativePath(t,i),commitSha:e,size:0,type:(s&n.FileType.Directory)===n.FileType.Directory?"tree":"blob"})}return[]}async getUniqueRepositoryId(t){}async hasBranchOrTag(t,e){const[{values:r},{values:n}]=await Promise.all([this.getBranches(t,{filter:e?.filter?.branches,sort:!1}),this.getTags(t,{filter:e?.filter?.tags,sort:!1})]);return 0!==r.length||0!==n.length}async hasCommitBeenPushed(t,e){return!0}isTrackable(t){return this.supportedSchemes.has(t.scheme)}async isTracked(t){if(!this.isTrackable(t)||null==this.container.git.getRepository(t))return!1;const e=t.with({scheme:o.sN.GitHub});return null!=await n.workspace.fs.stat(e)}async getDiffTool(t){}async openDiffTool(t,e,r){}async openDirectoryCompare(t,e,r,n){}async resolveReference(t,e,r,n){if(!e||e===p.Ii||null==r&&(0,w.D3)(e)||null!=r&&(0,w.l3)(e))return e;let i;if(null!=r)i=this.getRelativePath(r,t);else if(!(0,w.yo)(e)||e.endsWith("^3"))return e;const o=await this.ensureRepositoryContext(t);if(null==o)return e;const{metadata:s,github:a,session:u}=o,l=await a.resolveReference(u.accessToken,s.repo.owner,s.repo.name,e,i);return null!=l?l:i?p.Ii:e}async richSearchCommits(t,e,r){if(null==t)return;const n=(0,E.UH)(),i=(0,G.pD)(e),o=i.get("commit:");if(null!=o){const e=await this.getCommit(t,o[0]);if(null==e)return;return{repoPath:t,commits:new Map([[e.sha,e]]),sha:e.sha,range:void 0,count:1,limit:1,hasMore:!1}}const s=await this.getQueryArgsFromSearchQuery(e,i,t);if(0===s.length)return;const a=this.getPagingLimit(r?.limit);try{const{metadata:n,github:i,session:o}=await this.ensureRepositoryContext(t),u=`repo:${n.repo.owner}/${n.repo.name}+${s.join("+").trim()}`,l=await i.searchCommits(o.accessToken,u,{cursor:r?.cursor,limit:a,sort:"date"===r?.ordering?"committer-date":"author-date"===r?.ordering?"author-date":void 0});if(null==l)return;const c=new Map,h=o.account.label;for(const e of l.values){const r=null!=h&&e.author.name===h?"You":e.author.name,n=null!=h&&e.committer.name===h?"You":e.committer.name;let i=c.get(e.oid);null==i&&(i=new m.aM(this.container,t,e.oid,new m._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new m._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,e.files?.map((e=>new f.K8(t,e.filename??"",(0,I.fromCommitFileStatus)(e.status)??f.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),c.set(e.oid,i))}const d={repoPath:t,commits:c,sha:void 0,range:void 0,count:c.size,limit:a,hasMore:l.pageInfo?.hasNextPage??!1,endingCursor:l.pageInfo?.endCursor??void 0,query:e=>this.getLog(t,{...r,limit:e})};if(d.hasMore){let t=function(n){return async i=>{i=this.getPagingLimit(i);const o=await this.richSearchCommits(n.repoPath,e,{...r,limit:i,cursor:n.endingCursor});if(null==o)return{...n,hasMore:!1,more:void 0};const s=new Map([...n.commits,...o.commits]),a={repoPath:n.repoPath,commits:s,sha:n.sha,range:void 0,count:s.size,limit:(n.limit??0)+i,hasMore:o.hasMore,endingCursor:o.endingCursor,query:n.query};return a.hasMore&&(a.more=t.call(this,a)),a}};d.more=t.call(this,d)}return d}catch(t){return void F.Yd.error(t,n)}}async searchCommits(t,e,r){e={matchAll:!1,matchCase:!1,matchRegex:!0,...e};const n=(0,G.FL)(e);try{const i=new Map,o=(0,G.pD)(e),s=o.get("commit:");if(null!=s){const p=await Promise.allSettled(s.map((e=>this.getCommit(t,e.replace(N,"")))));let g=0;for(const f of p){const y=(0,A.Sb)(f);null!=y&&i.set(y.sha,{i:g++,date:Number("author-date"===r?.ordering?y.author.date:y.committer.date)})}return{repoPath:t,query:e,comparisonKey:n,results:i}}const a=await this.getQueryArgsFromSearchQuery(e,o,t);if(0===a.length)return{repoPath:t,query:e,comparisonKey:n,results:i};const{metadata:u,github:c,session:h}=await this.ensureRepositoryContext(t),d=`repo:${u.repo.owner}/${u.repo.name}+${a.join("+").trim()}`;async function m(o,s){if(r?.cancellation?.isCancellationRequested)return{repoPath:t,query:e,comparisonKey:n,results:i};o=this.getPagingLimit(o??S.D.get("advanced.maxSearchItems"));const a=await c.searchCommitShas(h.accessToken,d,{cursor:s,limit:o,sort:"date"===r?.ordering?"committer-date":"author-date"===r?.ordering?"author-date":void 0});if(null==a||r?.cancellation?.isCancellationRequested)return{repoPath:t,query:e,comparisonKey:n,results:i};for(const t of a.values)i.set(t.sha,{i:i.size,date:Number("author-date"===r?.ordering?t.authorDate:t.committerDate)});return s=a.pageInfo?.endCursor??void 0,{repoPath:t,query:e,comparisonKey:n,results:i,paging:a.pageInfo?.hasNextPage?{limit:o,hasMore:!0}:void 0,more:async t=>m.call(this,t,s)}}return m.call(this,r?.limit)}catch(w){if(w instanceof l.l0)throw w;throw new l.l0(w)}}async validateBranchOrTagName(t,e){return W.test(t)}async validateReference(t,e){return!0}async stageFile(t,e){}async stageDirectory(t,e){}async unStageFile(t,e){}async unStageDirectory(t,e){}async ensureRepositoryContext(t,e){let r=n.Uri.parse(t,!0);if(!/^github\+?/.test(r.authority))throw new a.kX(t,a.sh.NotAGitHubRepository);if(!e){const e=this.container.git.getRepository(r);if(null==e)throw new a.kX(t,a.sh.NotAGitHubRepository);r=e.uri}let i=this._remotehub;if(null==i)try{i=await this.ensureRemoteHubApi()}catch(e){throw a.R5,new a.kX(t,a.sh.RemoteHubApiNotFound,e)}const o=await(i?.getMetadata(r));if("github"!==o?.provider.id)throw new a.kX(t,a.sh.NotAGitHubRepository);let s,u;try{[s,u]=await Promise.all([this.ensureGitHub(),this.ensureSession()])}catch(e){if(e instanceof a._7)throw new a.kX(t,e.reason===a.Jx.UserDidNotConsent?a.sh.GitHubAuthenticationDenied:a.sh.GitHubAuthenticationNotFound,e);throw new a.kX(t)}if(null==s)throw new a.kX(t);return{github:s,metadata:o,remotehub:i,session:u}}_github;async ensureGitHub(){if(null==this._github){const t=await this.container.github;null!=t&&this._disposables.push(t.onDidReauthenticate((()=>{this.ensureSession(!0)}))),this._github=t}return this._github}_remotehub;_remotehubPromise;async ensureRemoteHubApi(t){if(null==this._remotehubPromise&&(this._remotehubPromise=_(),this._remotehubPromise.then((t=>this._remotehub=t),(()=>this._remotehub=void 0))),!t)return this._remotehubPromise;try{return await this._remotehubPromise}catch{return}}_sessionPromise;async ensureSession(t=!1,e=!1){if(t||null==this._sessionPromise){async function r(){let i=this.container.storage.get(`provider:authentication:skip:${this.descriptor.id}`,!1);try{if(t)return i=!1,this.container.storage.delete(`provider:authentication:skip:${this.descriptor.id}`),await n.authentication.getSession("github",z,{forceNewSession:!0});if(!i&&!e)return await n.authentication.getSession("github",z,{createIfNone:!0});const r=await n.authentication.getSession("github",z,{createIfNone:!1,silent:e});if(null!=r)return r;throw new Error("User did not consent")}catch(o){if(o instanceof Error&&o.message.includes("User did not consent")){if(!e&&(await this.container.storage.store(`provider:authentication:skip:${this.descriptor.id}`,!0),!i))return t||queueMicrotask((async()=>{const t="Re-enable";await n.window.showInformationMessage("GitLens has been disabled. Authentication is required for GitLens to work with remote GitHub repositories.",t)===t&&this.ensureSession(!0)})),t=!1,r.call(this);throw new a._7("github",a.Jx.UserDidNotConsent)}throw F.Yd.error(o),new a._7("github",void 0,o)}}this._sessionPromise=r.call(this)}return this._sessionPromise}createVirtualUri(t,e,r){let i;if("string"==typeof e)e&&(i=(0,w.D3)(e)?{v:1,ref:{id:e,type:2}}:{v:1,ref:{id:e,type:4}});else switch(e?.refType){case"revision":case"stash":i={v:1,ref:{id:e.ref,type:2}};break;case"branch":case"tag":i={v:1,ref:{id:e.name,type:4}}}if("string"==typeof t&&(t=n.Uri.parse(t,!0)),r){let e=t.path;e.endsWith("/")&&(e=e.slice(0,-1)),r=`${e}/${(r=this.getRelativePath(r,t)).startsWith("/")?r.slice(0,-1):r}`}return t.with({scheme:o.sN.Virtual,authority:Q("github",i),path:r??t.path})}createProviderUri(t,e,r){const n=this.createVirtualUri(t,e,r);return null==this._remotehub?n.scheme!==o.sN.Virtual?n:n.with({scheme:o.sN.GitHub}):this._remotehub.getProviderUri(n)}getPagingLimit(t){return 0===(t=Math.min(100,t??S.D.get("advanced.maxListItems")??100))&&(t=100),t}async resolveReferenceCore(t,e,r){if(null==r||"HEAD"===r){return(await e.getRevision()).revision}if((0,w.D3)(r))return r;if((0,w.yk)(r))return;const[n,i]=await Promise.allSettled([this.getBranches(t,{filter:t=>t.name===r}),this.getTags(t,{filter:t=>t.name===r})]);return r=(0,A.Sb)(n)?.values[0]?.sha??(0,A.Sb)(i)?.values[0]?.sha}async getQueryArgsFromSearchQuery(t,e,r){const n=[];for(const[i,o]of e.entries())switch(i){case"message:":n.push(...o.map((t=>t.replace(/ /g,"+"))));break;case"author:":{let e;o.includes("@me")&&(e=await this.getCurrentUser(r));for(let r of o)if(r&&(r=r.replace(N,t.matchRegex?"\\b":""),r)){if("@me"===r){if(null==e?.username)continue;r=`@${e.username}`}r=r.replace(/ /g,"+"),r.startsWith("@")?n.push(`author:${r.slice(1)}`):r.includes("@")?n.push(`author-email:${r}`):n.push(`author-name:${r}`)}break}}return n}}function Q(t,e){return`${t}${null!=e?`+${(0,i.e)(JSON.stringify(e))}`:""}`}j([(0,q.cM)()],GitHubGitProvider.prototype,"getBestRevisionUri",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getWorkingUri",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"addRemote",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"pruneRemote",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"removeRemote",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"applyChangesToWorkingFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"branchContainsCommit",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"checkout",1),j([(0,q.cM)({singleLine:!0})],GitHubGitProvider.prototype,"resetCache",1),j([(0,q.cM)({singleLine:!0})],GitHubGitProvider.prototype,"resetCaches",1),j([(0,q.cM)({args:{1:t=>t.length}})],GitHubGitProvider.prototype,"excludeIgnoredUris",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"fetch",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"pull",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"push",1),j([(0,U.H)(),(0,q.fF)()],GitHubGitProvider.prototype,"findRepositoryUri",1),j([(0,q.cM)({args:{1:t=>t.join(",")}})],GitHubGitProvider.prototype,"getAheadBehindCommitCount",1),j([(0,U.H)(((t,e)=>`${t.toString()}|${e?.isDirty}`)),(0,q.cM)({args:{1:t=>t?.isDirty}})],GitHubGitProvider.prototype,"getBlame",1),j([(0,q.cM)({args:{1:"<contents>"}})],GitHubGitProvider.prototype,"getBlameContents",1),j([(0,U.H)(((t,e,r,n)=>`${t.toString()}|${e}|${r?.isDirty}|${n?.forceSingleLine}`)),(0,q.cM)({args:{2:t=>t?.isDirty}})],GitHubGitProvider.prototype,"getBlameForLine",1),j([(0,q.cM)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForLineContents",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getBlameForRange",1),j([(0,q.cM)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForRangeContents",1),j([(0,q.cM)({args:{0:"<blame>"}})],GitHubGitProvider.prototype,"getBlameRange",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getBranch",1),j([(0,q.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getBranches",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getChangedFilesCount",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getCommit",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getCommitBranches",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getCommitCount",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getCommitForFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getCommitsForGraph",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getContributors",1),j([(0,U.H)(),(0,q.cM)()],GitHubGitProvider.prototype,"getCurrentUser",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getDefaultBranchName",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getDiffForFile",1),j([(0,q.cM)({args:{1:t=>"<contents>"}})],GitHubGitProvider.prototype,"getDiffForFileContents",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getDiffForLine",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getDiffStatus",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getFileStatusForCommit",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getLog",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getLogRefsOnly",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getLogForFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getMergeBase",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getMergeStatus",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getRebaseStatus",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getNextComparisonUris",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getOldestUnpushedRefForFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getPreviousComparisonUris",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getPreviousComparisonUrisForLine",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getIncomingActivity",1),j([(0,q.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getRemotes",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getRevisionContent",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getStash",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getStatusForFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getStatusForFiles",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getStatusForRepo",1),j([(0,q.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getTags",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getTreeEntryForRevision",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getTreeForRevision",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"hasBranchOrTag",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"hasCommitBeenPushed",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"getDiffTool",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"openDiffTool",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"openDirectoryCompare",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"resolveReference",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"richSearchCommits",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"searchCommits",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"validateBranchOrTagName",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"validateReference",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"stageFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"stageDirectory",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"unStageFile",1),j([(0,q.cM)()],GitHubGitProvider.prototype,"unStageDirectory",1),j([(0,U.H)()],GitHubGitProvider.prototype,"ensureRepositoryContext",1),j([(0,U.H)()],GitHubGitProvider.prototype,"ensureGitHub",1)},3878:(t,e,r)=>{r.r(e),r.d(e,{fromCommitFileStatus:()=>g,fromGitHubIssueDetailed:()=>p,fromGitHubPullRequest:()=>s,fromGitHubPullRequestDetailed:()=>m,fromGitHubPullRequestMergeableState:()=>h,fromGitHubPullRequestReviewDecision:()=>l,fromGitHubPullRequestState:()=>a,toGitHubPullRequestMergeableState:()=>d,toGitHubPullRequestReviewDecision:()=>c,toGitHubPullRequestState:()=>u});var n=r(7881),i=r(8452),o=r(4092);function s(t,e){return new o.i7(e,{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},String(t.number),t.title,t.permalink,a(t.state),new Date(t.updatedAt),null==t.closedAt?void 0:new Date(t.closedAt),null==t.mergedAt?void 0:new Date(t.mergedAt))}function a(t){return"MERGED"===t?o.o0.Merged:"CLOSED"===t?o.o0.Closed:o.o0.Open}function u(t){return t===o.o0.Merged?"MERGED":t===o.o0.Closed?"CLOSED":"OPEN"}function l(t){switch(t){case"APPROVED":return o.pD.Approved;case"CHANGES_REQUESTED":return o.pD.ChangesRequested;case"REVIEW_REQUIRED":return o.pD.ReviewRequired}}function c(t){switch(t){case o.pD.Approved:return"APPROVED";case o.pD.ChangesRequested:return"CHANGES_REQUESTED";case o.pD.ReviewRequired:return"REVIEW_REQUIRED"}}function h(t){switch(t){case"MERGEABLE":return o.Cz.Mergeable;case"CONFLICTING":return o.Cz.Conflicting;case"UNKNOWN":return o.Cz.Unknown}}function d(t){switch(t){case o.Cz.Mergeable:return"MERGEABLE";case o.Cz.Conflicting:return"CONFLICTING";case o.Cz.Unknown:return"UNKNOWN"}}function m(t,e){return new o.i7(e,{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},String(t.number),t.title,t.permalink,a(t.state),new Date(t.updatedAt),null==t.closedAt?void 0:new Date(t.closedAt),null==t.mergedAt?void 0:new Date(t.mergedAt),h(t.mergeable),{head:{exists:null!=t.headRepository,owner:t.headRepository?.owner.login,repo:t.baseRepository?.name,sha:t.headRefOid,branch:t.headRefName,url:t.headRepository?.url},base:{exists:null!=t.baseRepository,owner:t.baseRepository?.owner.login,repo:t.baseRepository?.name,sha:t.baseRefOid,branch:t.baseRefName,url:t.baseRepository?.url},isCrossRepository:t.isCrossRepository},t.isDraft,t.additions,t.deletions,t.totalCommentsCount,l(t.reviewDecision),t.reviewRequests.nodes.map((t=>({isCodeOwner:t.asCodeOwner,reviewer:{name:t.requestedReviewer.login,avatarUrl:t.requestedReviewer.avatarUrl,url:t.requestedReviewer.url}}))),t.assignees.nodes.map((t=>({name:t.login,avatarUrl:t.avatarUrl,url:t.url}))))}function p(t,e){return new i.$9({id:e.id,name:e.name,domain:e.domain,icon:e.icon},String(t.number),t.title,t.url,new Date(t.createdAt),t.closed,new Date(t.updatedAt),{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},{owner:t.repository.owner.login,repo:t.repository.name},t.assignees.nodes.map((t=>({name:t.name,avatarUrl:t.avatarUrl,url:t.url}))),null==t.closedAt?void 0:new Date(t.closedAt),null==t.labels?.nodes?void 0:t.labels.nodes.map((t=>({color:t.color,name:t.name}))),t.comments?.totalCount,t.reactions?.totalCount)}function g(t){switch(t){case"added":return n.NV.Added;case"changed":case"modified":return n.NV.Modified;case"removed":return n.NV.Deleted;case"renamed":return n.NV.Renamed;case"copied":return n.NV.Copied}}},778:(t,e,r)=>{var n=r(2479);function i(t){var e=function(){return e.called?e.value:(e.called=!0,e.value=t.apply(this,arguments))};return e.called=!1,e}function o(t){var e=function(){if(e.called)throw new Error(e.onceError);return e.called=!0,e.value=t.apply(this,arguments)},r=t.name||"Function wrapped with `once`";return e.onceError=r+" shouldn't be called more than once",e.called=!1,e}t.exports=n(i),t.exports.strict=n(o),i.proto=i((function(){Object.defineProperty(Function.prototype,"once",{value:function(){return i(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return o(this)},configurable:!0})}))},2479:t=>{t.exports=function t(e,r){if(e&&r)return t(e)(r);if("function"!=typeof e)throw new TypeError("need wrapper function");return Object.keys(e).forEach((function(t){n[t]=e[t]})),n;function n(){for(var t=new Array(arguments.length),r=0;r<t.length;r++)t[r]=arguments[r];var n=e.apply(this,t),i=t[t.length-1];return"function"==typeof n&&n!==i&&Object.keys(i).forEach((function(t){n[t]=i[t]})),n}}}};