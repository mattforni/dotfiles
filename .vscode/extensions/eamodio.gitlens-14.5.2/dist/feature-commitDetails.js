exports.id=10,exports.ids=[10],exports.modules={7387:(t,e,i)=>{function s(t){if(null!=t)try{let e=function(t,e){if(e instanceof Date)return e.getTime();if(e instanceof Map||e instanceof Set)return[...e.entries()];if(e instanceof Function||e instanceof Error)return;if(e instanceof RegExp)return e.toString();const i=this[t];return i instanceof Date?i.getTime():e};return JSON.parse(JSON.stringify(t,e))}catch(t){throw t}}i.d(e,{q:()=>s})},9263:(t,e,i)=>{i.d(e,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var s=i(9496),o=i(3139),n=i(5255),a=i(9311),r=i(6897),c=i(9338),h=i(6450),p=i(439),l=i(8452),m=i(4092),d=i(4321),u=i(3646),g=i(9679),f=i(2226),k=i(9529),w=i(5148),_=i(2061),v=i(4241),S=i(9796),b=i(3105),C=i(4336),x=i(6004);class MRU{constructor(t=10,e){this.maxSize=t,this.comparator=e}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0);const e=null!=this.comparator?this.stack.findIndex((e=>this.comparator(t,e))):this.stack.indexOf(t);-1!==e?this.stack.splice(e,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(t),this._position=0}get(t){if(null!=t){if(t<0||t>=this.stack.length)return;return this.stack[t]}return this.stack.length>0?this.stack[0]:void 0}insert(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(t),this._position++}navigate(t){if(!(this.stack.length<=1)){if("back"===t){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}}var y=i(7469),D=i(7387),P=i(5798),F=i(6260),T=i(620);const R=new P.ke("commit/actions"),W=new P.ke("commit/file/actions"),q=new P.ke("commit/file/open"),O=new P.ke("commit/file/openOnRemote"),E=new P.ke("commit/file/compareWorking"),A=new P.ke("commit/file/comparePrevious"),M=new P.ke("commit/file/stage"),L=new P.ke("commit/file/unstage"),I=new P.ke("commit/pickCommit"),B=new P.ke("commit/searchCommit"),N=new P.ke("commit/switchMode"),G=new P.ke("commit/autolinkSettings"),j=new P.ke("commit/explain"),U=new P.ke("commit/pin"),V=new P.ke("commit/navigate"),H=new P.ke("commit/preferences/update"),Y=new P.ke("commit/wip/createPatch"),$=new P.jH("commit/didChange",!0),J=new P.jH("commit/didChange/wip"),z=new P.jH("commit/didExplain");var Z=Object.defineProperty,K=Object.getOwnPropertyDescriptor,Q=(t,e,i,s)=>{for(var o,n=s>1?void 0:s?K(e,i):e,a=t.length-1;a>=0;a--)(o=t[a])&&(n=(s?o(e,i,n):o(n))||n);return s&&n&&Z(e,i,n),n};class CommitDetailsWebviewProvider{constructor(t,e,i){this.container=t,this.host=e,this.options=i,this._context={mode:"commit",navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commit:void 0,richStateLoaded:!1,formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0},this._disposable=w.D.onDidChangeAny(this.onAnyConfigurationChanged,this)}_bootstraping=!0;_context;_pendingContext;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,((t,e)=>t.ref===e.ref));dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}_skipNextRefreshOnVisibilityChange=!1;async onShowing(t,e,...i){let s;const[o]=i;if((0,T.W)(o)){const{commit:t}=o.state;null!=t?.repoPath&&null!=t?.sha&&(s=null!=t.stashNumber?{commit:(0,d.xB)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,d.xB)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else s=null!=o&&"object"==typeof o?o:void 0;let n;return null!=s&&(s.preserveFocus&&(null==e?e={preserveFocus:!0}:e.preserveFocus=!0),({commit:n,...s}=s)),null!=n&&"wip"===this.mode&&"passive"!==s?.interaction&&this.setMode("commit"),null==n&&(this._pinned||(n=this.getBestCommitOrStash())),null==n||this._context.commit?.ref.startsWith(n.ref)||await this.updateCommit(n,{pinned:!1}),!(s?.preserveVisibility&&!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}includeBootstrap(){return this._bootstraping=!0,this._context={...this._context,...this._pendingContext},this._pendingContext=void 0,this.getState(this._context)}registerCommands(){return[(0,k.xR)(`${this.host.id}.refresh`,(()=>this.host.refresh(!0)))]}onFocusChanged(t){this._focused!==t&&(this._focused=t,t&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(t){switch(t.method){case O.method:(0,P.mq)(O,t,(t=>{this.openFileOnRemote(t)}));break;case q.method:(0,P.mq)(q,t,(t=>{this.openFile(t)}));break;case E.method:(0,P.mq)(E,t,(t=>{this.openFileComparisonWithWorking(t)}));break;case A.method:(0,P.mq)(A,t,(t=>{this.openFileComparisonWithPrevious(t)}));break;case W.method:(0,P.mq)(W,t,(t=>{this.showFileActions(t)}));break;case R.method:(0,P.mq)(R,t,(t=>{switch(t.action){case"graph":{let t;if(t="wip"===this._context.mode?null!=this._context.wip?.changes?(0,d.xB)(p.CL,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this._context.commit?(0,d.qj)(this._context.commit):void 0,null==t)return;(0,k.P0)("graph"===this.options.attachedTo?n.Gh.ShowInCommitGraphView:n.Gh.ShowInCommitGraph,{ref:t});break}case"more":this.showCommitActions();break;case"scm":(0,k.dO)("workbench.view.scm");break;case"sha":t.alt?this.showCommitPicker():null!=this._context.commit&&(0,k.P0)(n.Gh.CopyShaToClipboard,{sha:this._context.commit.sha})}}));break;case I.method:(0,P.mq)(I,t,(t=>this.showCommitPicker()));break;case B.method:(0,P.mq)(B,t,(t=>this.showCommitSearch()));break;case N.method:(0,P.mq)(N,t,(t=>this.switchMode(t)));break;case G.method:(0,P.mq)(G,t,(t=>this.showAutolinkSettings()));break;case U.method:(0,P.mq)(U,t,(t=>this.updatePinned(t.pin??!1,!0)));break;case V.method:(0,P.mq)(V,t,(t=>this.navigateStack(t.direction)));break;case H.method:(0,P.mq)(H,t,(t=>this.updatePreferences(t)));break;case j.method:(0,P.mq)(j,t,(()=>this.explainCommit(t.completionId)));break;case M.method:(0,P.mq)(M,t,(t=>this.stageFile(t)));break;case L.method:(0,P.mq)(L,t,(t=>this.unstageFile(t)));break;case Y.method:(0,P.mq)(Y,t,(t=>this.createPatchFromWip(t)))}}onRefresh(t){if(!this._pinned)if("wip"===this.mode){const t=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=t?s.Uri.parse(t):void 0))}else{const t=this._pendingContext?.commit??this.getBestCommitOrStash();this.updateCommit(t,{immediate:!1})}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(t){if(this.ensureTrackers(),!t)return;const e=this._skipNextRefreshOnVisibilityChange;if(e&&(this._skipNextRefreshOnVisibilityChange=!1),this._bootstraping){if(this._bootstraping=!1,null==this._pendingContext)return;this.updateState()}else e||this.onRefresh(),this.updateState(!0)}onAnyConfigurationChanged(t){(w.D.changed(t,["defaultDateFormat","views.commitDetails.files","views.commitDetails.avatars"])||w.D.changedAny(t,"workbench.tree.renderIndentGuides")||w.D.changedAny(t,"workbench.tree.indent"))&&(this.updatePendingContext({preferences:{...this._context.preferences,...this._pendingContext?.preferences,...this.getPreferences()}}),this.updateState()),null!=this._context.commit&&w.D.changed(t,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&(this.updateCommit(this._context.commit,{force:!0}),this.updateState())}getPreferences(){return{autolinksExpanded:this.container.storage.getWorkspace("views:commitDetails:autolinksExpanded")??!0,avatars:w.D.get("views.commitDetails.avatars"),dateFormat:w.D.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:w.D.get("views.commitDetails.files"),indentGuides:w.D.getAny("workbench.tree.renderIndentGuides")??"onHover",indent:w.D.getAny("workbench.tree.indent")}}onCommitSelected(t){null==t.data||"graph"===this.options.attachedTo&&"gitlens.views.graph"!==t.source||"default"===this.options.attachedTo&&"gitlens.views.graph"===t.source||("wip"!==this.mode?this._pinned&&"passive"===t.data.interaction?(this._commitStack.insert((0,d.qj)(t.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:t.data.preserveFocus},t.data):t.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(t.data.commit.repoPath)))}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if(this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){const{lineTracker:t}=this.container;this._lineTrackerDisposable=t.subscribe(this,t.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout((()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0}),100)}createPatchFromWip(t){if(null==t.changes)return;const e={type:"wip",repository:{name:t.changes.repository.name,path:t.changes.repository.path,uri:t.changes.repository.uri},files:t.changes.files,revision:{to:p.CL,from:"HEAD"},checked:t.checked};(0,g.l)({mode:"create",create:{changes:[e]}})}onActiveEditorLinesChanged(t){if(t.pending||null==t.editor||t.suspended)return;if("wip"===this.mode){const e=this.container.git.getBestRepositoryOrFirst(t.editor);return void this.updateWipState(e)}const e=t.selections?.[0]?.active,i=null!=e?this.container.lineTracker.getState(e)?.commit:void 0;this.updateCommit(i)}_wipSubscription;get mode(){return this._pendingContext?.mode??this._context.mode}setMode(t,e){this.updatePendingContext({mode:t}),"commit"===t?(this._wipSubscription?.subscription.dispose(),this._wipSubscription=void 0,this.updateState(!0)):this.updateWipState(e??this.container.git.getBestRepositoryOrFirst())}async explainCommit(t){let e;try{const t=await this.container.ai.explainCommit(this._context.commit,{progress:{location:{viewId:this.host.id}}});if(null==t)throw new Error("Error retrieving content");e={summary:t}}catch(t){e={error:{message:t.message}}}this.host.notify(z,e,t)}navigateStack(t){const e=this._commitStack.navigate(t);null!=e&&this.updateCommit(e,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(t){let e;if(null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=t.commit&&(e=await this.getDetailsModel(t.commit,t.formattedMessage),!t.richStateLoaded)){this._cancellationTokenSource=new s.CancellationTokenSource;const e=this._cancellationTokenSource.token;setTimeout((()=>{e.isCancellationRequested||this.updateRichState(t,e)}),100)}return(0,D.q)({...this.host.baseWebviewState,mode:t.mode,commit:e,navigationStack:t.navigationStack,pinned:t.pinned,preferences:t.preferences,includeRichContent:t.richStateLoaded,autolinkedIssues:t.autolinkedIssues?.map(l.Gj),pullRequest:null!=t.pullRequest?(0,m.l1)(t.pullRequest):void 0,wip:t.wip})}async updateWipState(t){if(null!=this._wipSubscription){const{repo:e,subscription:i}=this._wipSubscription;t?.path!==e.path&&(i.dispose(),this._wipSubscription=void 0)}let e;if(null!=t){null==this._wipSubscription&&(this._wipSubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)});if(e={changes:await this.getWipChange(t),repositoryCount:this.container.git.openRepositoryCount},null==this._pendingContext){if(await this.host.notify(J,{wip:e}))return void(this._context.wip=e)}}this.updatePendingContext({wip:e}),this.updateState(!0)}async updateRichState(t,e){const{commit:i}=t;if(null==i)return;const s=await this.container.git.getBestRemoteWithRichProvider(i.repoPath);if(e.isCancellationRequested)return;const[o,n]=null!=s?.provider?await Promise.allSettled([w.D.get("views.commitDetails.autolinks.enabled")&&w.D.get("views.commitDetails.autolinks.enhanced")?(0,f.IN)(i.getEnrichedAutolinks(s)):void 0,w.D.get("views.commitDetails.pullRequests.enabled")?i.getAssociatedPullRequest(s):void 0]):[];if(e.isCancellationRequested)return;const a=(0,y.Sb)(o)?.value,r=(0,y.Sb)(n),c=this.getFormattedMessage(i,s,a);this.updatePendingContext({richStateLoaded:!0,formattedMessage:c,autolinkedIssues:null!=a?[...(0,b.DZ)(a.values(),(([t])=>t?.value))]:void 0,pullRequest:r}),this.updateState()}_repositorySubscription;async updateCommit(t,e){if(!e?.force&&this._context.commit?.sha===t?.ref)return;let i;if((0,h.f_)(t))i=t;else if(null!=t)if("stash"===t.refType){const e=await this.container.git.getStash(t.repoPath);i=e?.commits.get(t.ref)}else i=await this.container.git.getCommit(t.repoPath,t.ref);let s=this._pendingContext?.wip??this._context.wip;if(null!=this._repositorySubscription){const{repo:t,subscription:e}=this._repositorySubscription;i?.repoPath!==t.path&&(e.dispose(),this._repositorySubscription=void 0,s=void 0)}if(null==this._repositorySubscription&&null!=i){const t=await this.container.git.getOrOpenRepository(i.repoPath);null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)},"wip"===this.mode?this.updateWipState(t):s=void 0)}this.updatePendingContext({commit:i,richStateLoaded:Boolean(i?.isUncommitted)||!(0,_.fw)("gitlens:hasConnectedRemotes"),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:s},e?.force),null!=e?.pinned&&this.updatePinned(e?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=i&&(e?.skipStack||this._commitStack.add((0,d.qj)(i)),this.updateNavigation()),this.updateState(e?.immediate??!0)}subscribeToRepositoryWip(t){return s.Disposable.from(t.watchFileSystem(1e3),t.onDidChangeFileSystem((()=>this.onWipChanged(t))),t.onDidChange((e=>{e.changed(u.I6.Index,u.du.Any)&&this.onWipChanged(t)})))}onWipChanged(t){this.updateWipState(t)}async getWipChange(t){const e=await this.container.git.getStatusForRepo(t.path);if(null==e)return;const i=[];for(const t of e.files){const e={repoPath:t.repoPath,path:t.path,status:t.status,originalPath:t.originalPath,staged:t.staged};i.push(e),t.staged&&t.wip&&i.push({...e,staged:!1})}return{repository:{name:t.name,path:t.path,uri:t.uri.toString()},branchName:e.branch,files:i}}updatePinned(t,e){t!==this._context.pinned&&(this._pinned=t,this.ensureTrackers(),this.updatePendingContext({pinned:t}),this.updateState(e))}updatePreferences(t){if(this._context.preferences?.autolinksExpanded===t.autolinksExpanded&&this._context.preferences?.files?.compact===t.files?.compact&&this._context.preferences?.files?.icon===t.files?.icon&&this._context.preferences?.files?.layout===t.files?.layout&&this._context.preferences?.files?.threshold===t.files?.threshold)return;const e={...this._context.preferences,...this._pendingContext?.preferences};null!=t.autolinksExpanded&&this._context.preferences?.autolinksExpanded!==t.autolinksExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:autolinksExpanded",t.autolinksExpanded),e.autolinksExpanded=t.autolinksExpanded),null!=t.files&&(this._context.preferences?.files?.compact!==t.files?.compact&&w.D.updateEffective("views.commitDetails.files.compact",t.files?.compact),this._context.preferences?.files?.icon!==t.files?.icon&&w.D.updateEffective("views.commitDetails.files.icon",t.files?.icon),this._context.preferences?.files?.layout!==t.files?.layout&&w.D.updateEffective("views.commitDetails.files.layout",t.files?.layout),this._context.preferences?.files?.threshold!==t.files?.threshold&&w.D.updateEffective("views.commitDetails.files.threshold",t.files?.threshold),e.files=t.files),this.updatePendingContext({preferences:e}),this.updateState()}updatePendingContext(t,e=!1){const[i,s]=(0,F.OY)(this._context,this._pendingContext,t,e);return i&&(this._pendingContext=s),i}_notifyDidChangeStateDebounced=void 0;updateState(t=!1){t?this.notifyDidChangeState():(null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,S.Ds)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced())}updateNavigation(){let t=this._commitStack.get(this._commitStack.position-1)?.ref;null!=t&&(t=(0,d.zL)(t)),this.updatePendingContext({navigationStack:{count:this._commitStack.count,position:this._commitStack.position,hint:t}}),this.updateState()}async notifyDidChangeState(t=!1){const e=(0,x.UH)();if(this._notifyDidChangeStateDebounced?.cancel(),!t&&null==this._pendingContext)return!1;let i;return null!=this._pendingContext?(i={...this._context,...this._pendingContext},this._context=i,this._pendingContext=void 0):i=this._context,s.window.withProgress({location:{viewId:this.host.id}},(async()=>{try{await this.host.notify($,{state:await this.getState(i)})}catch(t){C.Yd.error(e,t)}}))}getBestCommitOrStash(){if(this._pinned)return;let t;if("graph"!==this.options.attachedTo&&null!=s.window.activeTextEditor){const{lineTracker:e}=this.container,i=e.selections?.[0].active;null!=i&&(t=e.getState(i)?.commit)}else if(t=this._pendingContext?.commit,null==t){const e=this.container.events.getCachedEventArgs("commit:selected");t=e?.commit}return t}async getDetailsModel(t,e){const[i,s,n]=await Promise.allSettled([t.hasFullDetails()?t:t.ensureFullDetails().then((()=>t)),t.author.getAvatarUri(t,{size:32}),this.container.git.getBestRemoteWithRichProvider(t.repoPath,{includeDisconnected:!0})]);t=(0,y.Sb)(i,t);const a=(0,y.Sb)(s),r=(0,y.Sb)(n);null==e&&(e=this.getFormattedMessage(t,r));const c=null!=t.message?this.container.autolinks.getAutolinks(t.message,r):void 0;return{repoPath:t.repoPath,sha:t.sha,shortSha:t.shortSha,author:{...t.author,avatar:a?.toString(!0)},message:e,parents:t.parents,stashNumber:"stash"===t.refType?t.number:void 0,files:t.files,stats:t.stats,autolinks:null!=c?[...(0,b.UI)(c.values(),o.G)]:void 0}}getFormattedMessage(t,e,i){let s=c.i.fromTemplate("${message}",t);const o=s.indexOf("\n");return-1!==o&&(s=`${s.substring(0,o)}\0\n\0${s.substring(o+1)}`),w.D.get("views.commitDetails.autolinks.enabled")?this.container.autolinks.linkify(s,"html",null!=e?[e]:void 0,i):s}async getFileCommitFromParams(t){let e;if("wip"===this.mode){const t=this._context.wip?.changes?.repository.uri;if(null==t)return;e=await this.container.git.getCommit(s.Uri.parse(t),p.CL)}else e=this._context.commit;return e=await(e?.getCommitForFile(t.path,t.staged)),null!=e?[e,e.file]:void 0}showAutolinkSettings(){(0,k.P0)(n.Gh.ShowSettingsPageAndJumpToAutolinks)}showCommitPicker(){(0,a.m)({command:"log",state:{reference:"HEAD",repo:this._context.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,a.m)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this._context.commit||this._context.commit.isUncommitted||(0,r.$J)(this._context.commit)}async showFileActions(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;this.suspendLineTracker(),(0,r.$J)(i,s)}switchMode(t){let e;if("wip"===t.mode){let{repoPath:i}=t;if(null==i){if(e=this.container.git.getBestRepositoryOrFirst(),null==e)return;i=e.path}else e=this.container.git.getRepository(i)}this.setMode(t.mode,e)}async openFileComparisonWithWorking(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;this.suspendLineTracker(),(0,r.ce)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileComparisonWithPrevious(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;this.suspendLineTracker(),(0,r.vw)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFile(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;this.suspendLineTracker(),(0,r.ZB)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileOnRemote(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;(0,r.YM)(s,i)}async stageFile(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;await this.container.git.stageFile(i.repoPath,s.path)}async unstageFile(t){const e=await this.getFileCommitFromParams(t);if(null==e)return;const[i,s]=e;await this.container.git.unstageFile(i.repoPath,s.path)}getShowOptions(t){return t.showOptions}}Q([(0,v.fF)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),Q([(0,v.fF)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),Q([(0,v.fF)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateRichState",1)}};