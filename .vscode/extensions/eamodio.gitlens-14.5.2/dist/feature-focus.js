exports.id=521,exports.ids=[521],exports.modules={1629:(e,t,s)=>{s.d(t,{FocusWebviewProvider:()=>FocusWebviewProvider});var r=s(9496),i=s(5255),n=s(8887),o=s(4155),a=s(8834),u=s(5367),h=s(8452),c=s(4092),l=s(4321),d=s(3646),p=s(2674),f=s(4794),g=s(9529),m=s(4241),w=s(4336),R=s(6004),b=s(5116),y=s(7469),_=s(5798);const v=new _.ke("focus/pr/openWorktree"),I=new _.ke("focus/pr/openBranch"),q=new _.ke("focus/pr/switchToBranch"),P=new _.ke("focus/pr/snooze"),S=new _.ke("focus/pr/pin"),C=new _.ke("focus/issue/snooze"),k=new _.ke("focus/issue/pin"),F=new _.jH("focus/didChange",!0);var W=Object.defineProperty,D=Object.getOwnPropertyDescriptor,A=(e,t,s,r)=>{for(var i,n=r>1?void 0:r?D(t,s):t,o=e.length-1;o>=0;o--)(i=e[o])&&(n=(r?i(t,s,n):i(n))||n);return r&&n&&W(t,s,n),n};class FocusWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=r.Disposable.from(this.container.subscription.onDidChange(this.onSubscriptionChanged,this),this.container.git.onDidChangeRepositories((async()=>{if(this._etag!==this.container.git.etag){if(null!=this._discovering&&(this._etag=await this._discovering,this._etag===this.container.git.etag))return;this.host.refresh(!0)}})))}_pullRequests=[];_issues=[];_discovering;_disposable;_etag;_etagSubscription;_repositoryEventsDisposable;_repos;_enrichedItems;dispose(){this._disposable.dispose()}onMessageReceived(e){switch(e.method){case I.method:(0,_.mq)(I,e,(e=>this.onOpenBranch(e)));break;case q.method:(0,_.mq)(q,e,(e=>this.onSwitchBranch(e)));break;case v.method:(0,_.mq)(v,e,(e=>this.onOpenWorktree(e)));break;case P.method:(0,_.mq)(P,e,(e=>this.onSnoozePr(e)));break;case S.method:(0,_.mq)(S,e,(e=>this.onPinPr(e)));break;case C.method:(0,_.mq)(C,e,(e=>this.onSnoozeIssue(e)));break;case k.method:(0,_.mq)(k,e,(e=>this.onPinIssue(e)))}}async onPinIssue({issue:e,pin:t}){const s=this._issues?.find((t=>t.issue.nodeId===e.nodeId));if(null!=s){if(t)await this.container.focus.unpinItem(t),this._enrichedItems=this._enrichedItems?.filter((e=>e.id!==t)),s.enriched=s.enriched?.filter((e=>e.id!==t));else{const e={type:"issue",id:s.issue.nodeId,remote:s.repoAndRemote.remote,url:s.issue.url},t=await this.container.focus.pinItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onSnoozeIssue({issue:e,snooze:t}){const s=this._issues?.find((t=>t.issue.nodeId===e.nodeId));if(null!=s){if(t)await this.container.focus.unsnoozeItem(t),this._enrichedItems=this._enrichedItems?.filter((e=>e.id!==t)),s.enriched=s.enriched?.filter((e=>e.id!==t));else{const e={type:"issue",id:s.issue.nodeId,remote:s.repoAndRemote.remote,url:s.issue.url},t=await this.container.focus.snoozeItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onPinPr({pullRequest:e,pin:t}){const s=this._pullRequests?.find((t=>t.pullRequest.nodeId===e.nodeId));if(null!=s){if(t)await this.container.focus.unpinItem(t),this._enrichedItems=this._enrichedItems?.filter((e=>e.id!==t)),s.enriched=s.enriched?.filter((e=>e.id!==t));else{const e={type:"pr",id:s.pullRequest.nodeId,remote:s.repoAndRemote.remote,url:s.pullRequest.url},t=await this.container.focus.pinItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onSnoozePr({pullRequest:e,snooze:t}){const s=this._pullRequests?.find((t=>t.pullRequest.nodeId===e.nodeId));if(null!=s){if(t)await this.container.focus.unsnoozeItem(t),this._enrichedItems=this._enrichedItems?.filter((e=>e.id!==t)),s.enriched=s.enriched?.filter((e=>e.id!==t));else{const e={type:"pr",id:s.pullRequest.nodeId,remote:s.repoAndRemote.remote,url:s.pullRequest.url},t=await this.container.focus.snoozeItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}findSearchedPullRequest(e){return this._pullRequests?.find((t=>t.pullRequest.id===e.id))}async getRemoteBranch(e){const t=e.pullRequest,s=e.repoAndRemote,i=s.repo.uri,n=await s.repo.getMainRepository();if(null==n)return void r.window.showWarningMessage(`Unable to find main repository(${i.toString()}) for PR #${t.id}`);const a=t.refs.base.owner,u=r.Uri.parse(t.refs.base.url),h=t.refs.head.branch,c=r.Uri.parse(t.refs.head.url),d=c.toString(),[,p,g]=(0,f.Sk)(d);let m,w;if([m]=await n.getRemotes({filter:e=>e.matches(p,g)}),null!=m)w=`${m.name}/${h}`,await this.container.git.fetch(n.path,{remote:m.name});else{const e=await r.window.showInformationMessage(`Unable to find a remote for '${d}'. Would you like to add a new remote?`,{modal:!0},{title:"Yes"},{title:"No",isCloseAffordance:!0});if("Yes"!==e?.title)return;const s=t.refs.head.owner;if(await(0,o.IH)(n,s,d,{confirm:!1,fetch:!0,reveal:!1}),[m]=await n.getRemotes({filter:e=>e.url===d}),null==m)return;w=`${m.name}/${h}`;const i=t.refs.base.repo,l=`pr/${u.toString()===c.toString()?h:w}`;this.container.git.setConfig(n.path,`branch.${l}.github-pr-owner-number`,`${a}#${i}#${t.id}`)}return{remote:m,reference:(0,l.xB)(w,n.path,{refType:"branch",name:w,remote:!0})}}async onOpenBranch({pullRequest:e}){const t=this.findSearchedPullRequest(e);if(null==t)return;const s=await this.getRemoteBranch(t);null!=s?(0,g.P0)(i.Gh.ShowInCommitGraph,{ref:s.reference}):r.window.showErrorMessage(`Unable to find remote branch for '${t.pullRequest.refs?.head.owner}:${t.pullRequest.refs?.head.branch}'`)}async onSwitchBranch({pullRequest:e}){const t=this.findSearchedPullRequest(e);if(null==t||t.isCurrentBranch)return;if(null!=t.branch)return a.gu(t.branch.repoPath,t.branch);const s=await this.getRemoteBranch(t);if(null!=s)return a.gu(s.remote.repoPath,s.reference);r.window.showErrorMessage(`Unable to find remote branch for '${t.pullRequest.refs?.head.owner}:${t.pullRequest.refs?.head.branch}'`)}async onOpenWorktree({pullRequest:e}){const t=this.findSearchedPullRequest(e);if(null==t?.repoAndRemote)return;const s=r.Uri.parse(e.refs.base.url),n=t.repoAndRemote.repo.uri;return(0,g.P0)(i.Gh.OpenOrCreateWorktreeForGHPR,{base:{repositoryCloneUrl:{repositoryName:e.refs.base.repo,owner:e.refs.base.owner,url:s}},githubRepository:{rootUri:n},head:{ref:e.refs.head.branch,sha:e.refs.head.sha,repositoryCloneUrl:{repositoryName:e.refs.head.repo,owner:e.refs.head.owner,url:r.Uri.parse(e.refs.head.url)}},item:{number:parseInt(e.id,10)}})}onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(this._etagSubscription=e.etag,this._access=void 0,this.notifyDidChangeState())}_access;async getAccess(e){return(e||null==this._access)&&(this._access=await this.container.git.access(n.x.Focus)),this._access}async getState(e,t){const s=this.host.baseWebviewState;this._etag=this.container.git.etag,this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories.then((e=>(this._discovering=void 0,e))),this._etag=await this._discovering);const r=await this.getAccess(e);if(!0!==r.allowed)return{...s,access:r};const i=await this.getRichRepos(e),n=i.filter((e=>e.isGitHub));const o=function(e){return e.filter((e=>e.isConnected&&e.isGitHub))}(n);if(!(o.length>0))return{...s,access:r,repos:n.map((e=>M(e)))};const a=o.map((e=>M(e))),u=Promise.allSettled([this.getMyPullRequests(o,e),this.getMyIssues(o,e),this.getEnrichedItems(e)]);async function l(){const[e,t,i]=await u;return{...s,access:r,repos:a,pullRequests:(0,y.Sb)(e)?.map((e=>({pullRequest:(0,c.l1)(e.pullRequest),reasons:e.reasons,isCurrentBranch:e.isCurrentBranch??!1,isCurrentWorktree:e.isCurrentWorktree??!1,hasWorktree:e.hasWorktree??!1,hasLocalBranch:e.hasLocalBranch??!1,enriched:B(e,(0,y.Sb)(i)),rank:e.rank}))),issues:(0,y.Sb)(t)?.map((e=>({issue:(0,h.y$)(e.issue),reasons:e.reasons,enriched:B(e,(0,y.Sb)(i)),rank:e.rank})))}}if(t)return queueMicrotask((async()=>{const e=await l();this.host.notify(F,{state:e})})),{...s,access:r,repos:a};return await l()}async includeBootstrap(){return this.getState(!0,!0)}async getRichRepos(e){if(e||null==this._repos){const e=[],t=[];for(const s of this.container.git.openRepositories){const r=await s.getRichRemote();null==r||e.findIndex((e=>e.remote===r))>-1||(t.push(s.onDidChange(this.onRepositoryChanged,this)),e.push({repo:s,remote:r,isConnected:await r.provider.isConnected(),isGitHub:"github"===r.provider.id}))}this._repositoryEventsDisposable&&(this._repositoryEventsDisposable.dispose(),this._repositoryEventsDisposable=void 0),this._repositoryEventsDisposable=r.Disposable.from(...t),this._repos=e}return this._repos}onRepositoryChanged(e){e.changed(d.I6.RemoteProviders,d.du.Any)&&this.notifyDidChangeState(!0)}async getMyPullRequests(e,t){const s=(0,R.UH)();if(t||null==this._pullRequests){const t=[],r=new Map,i=new Map,n=e.map((e=>[e,this.container.git.getMyPullRequests(e.remote)]));for(const[e,o]of n){let n;try{n=await o}catch(t){w.Yd.error(t,s,`Failed to get prs for '${e.remote.url}'`)}if(null!=n)for(const s of n){if(0===s.reasons.length)continue;const n={...s,repoAndRemote:e,isCurrentWorktree:!1,isCurrentBranch:!1,rank:$(s)},o=`${n.pullRequest.refs.head.owner}/${n.pullRequest.refs.head.branch}`;let a=r.get(n.repoAndRemote.repo);null==a&&(a=new b.X((e=>n.repoAndRemote.repo.getBranches(null!=e?{paging:e}:void 0))),r.set(n.repoAndRemote.repo,a));let h=i.get(n.repoAndRemote.repo);null==h&&(h=await n.repoAndRemote.repo.getWorktrees(),i.set(n.repoAndRemote.repo,h));const c=await(0,p.K)(n.repoAndRemote.repo,n.pullRequest.refs.head.branch,o,h,a);n.hasWorktree=null!=c,n.isCurrentWorktree=!0===c?.opened;const l=await(0,u.eK)(e.repo,o,a);l&&(n.branch=l,n.hasLocalBranch=!0,n.isCurrentBranch=l.current),t.push(n)}}this._pullRequests=t.sort(((e,t)=>{const s=e.rank,r=t.rank;return s===r?e.pullRequest.date.getTime()-t.pullRequest.date.getTime():(r??0)-(s??0)}))}return this._pullRequests}async getMyIssues(e,t){const s=(0,R.UH)();if(t||null==this._pullRequests){const t=[],r=e.map((e=>[e,this.container.git.getMyIssues(e.remote)]));for(const[e,i]of r){let r;try{r=await i}catch(t){w.Yd.error(t,s,`Failed to get issues for '${e.remote.url}'`)}if(null!=r)for(const s of r)0!==s.reasons.length&&t.push({...s,repoAndRemote:e,rank:0})}this._issues=t.sort(((e,t)=>t.issue.updatedDate.getTime()-e.issue.updatedDate.getTime()))}return this._issues}async getEnrichedItems(e){if(e||null==this._enrichedItems){const e=await this.container.focus.get();this._enrichedItems=e}return this._enrichedItems}async notifyDidChangeState(e,t){this.host.notify(F,{state:await this.getState(e,t)})}}function B(e,t){if(null==t||0===t.length)return;let s;return s=null!=e.pullRequest?t.filter((t=>t.entityUrl===e.pullRequest.url)):t.filter((t=>t.entityUrl===e.issue.url)),0!==s.length?(e.enriched=s,s.map((e=>({id:e.id,type:e.type})))):void 0}function $(e){let t=0;return e.reasons.includes("authored")?t+=1e3:e.reasons.includes("assigned")?t+=900:e.reasons.includes("review-requested")?t+=800:e.reasons.includes("mentioned")&&(t+=700),e.pullRequest.reviewDecision===c.pD.Approved?e.pullRequest.mergeableState===c.Cz.Mergeable?t+=100:e.pullRequest.mergeableState===c.Cz.Conflicting?t+=90:t+=80:e.pullRequest.reviewDecision===c.pD.ChangesRequested&&(t+=70),t}function M(e){return{repo:e.repo.path,isGitHub:e.isGitHub,isConnected:e.isConnected}}A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onPinIssue",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onSnoozeIssue",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onPinPr",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onSnoozePr",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onOpenBranch",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onSwitchBranch",1),A([(0,m.fF)({args:!1})],FocusWebviewProvider.prototype,"onOpenWorktree",1),A([(0,m.fF)()],FocusWebviewProvider.prototype,"getAccess",1),A([(0,m.fF)()],FocusWebviewProvider.prototype,"getState",1),A([(0,m.fF)()],FocusWebviewProvider.prototype,"getRichRepos",1),A([(0,m.fF)({args:{0:!1}})],FocusWebviewProvider.prototype,"getMyPullRequests",1),A([(0,m.fF)({args:{0:!1}})],FocusWebviewProvider.prototype,"getMyIssues",1),A([(0,m.fF)()],FocusWebviewProvider.prototype,"getEnrichedItems",1)}};