exports.id=457,exports.ids=[457],exports.modules={3548:(t,e,r)=>{function n(t){return"[object Object]"===Object.prototype.toString.call(t)}function i(t){var e,r;return!1!==n(t)&&(void 0===(e=t.constructor)||!1!==n(r=e.prototype)&&!1!==r.hasOwnProperty("isPrototypeOf"))}function o(t,e){const r=Object.assign({},t);return Object.keys(e).forEach((n=>{i(e[n])?n in t?r[n]=o(t[n],e[n]):Object.assign(r,{[n]:e[n]}):Object.assign(r,{[n]:e[n]})})),r}function s(t){for(const e in t)void 0===t[e]&&delete t[e];return t}function a(t,e,r){if("string"==typeof e){let[t,n]=e.split(" ");r=Object.assign(n?{method:t,url:n}:{url:t},r)}else r=Object.assign({},e);var n;r.headers=(n=r.headers)?Object.keys(n).reduce(((t,e)=>(t[e.toLowerCase()]=n[e],t)),{}):{},s(r),s(r.headers);const i=o(t||{},r);return"/graphql"===r.url&&(t&&t.mediaType.previews?.length&&(i.mediaType.previews=t.mediaType.previews.filter((t=>!i.mediaType.previews.includes(t))).concat(i.mediaType.previews)),i.mediaType.previews=(i.mediaType.previews||[]).map((t=>t.replace(/-preview/,"")))),i}r.r(e),r.d(e,{GitHubApi:()=>GitHubApi});const u=/\{[^}]+\}/g;function l(t){return t.replace(/^\W+|\W+$/g,"").split(/,/)}function c(t,e){return Object.keys(t).filter((t=>!e.includes(t))).reduce(((e,r)=>(e[r]=t[r],e)),{})}function h(t){return t.split(/(%[0-9A-Fa-f]{2})/g).map((function(t){return/%[0-9A-Fa-f]/.test(t)||(t=encodeURI(t).replace(/%5B/g,"[").replace(/%5D/g,"]")),t})).join("")}function d(t){return encodeURIComponent(t).replace(/[!'()*]/g,(function(t){return"%"+t.charCodeAt(0).toString(16).toUpperCase()}))}function m(t,e,r){return e="+"===t||"#"===t?h(e):d(e),r?d(r)+"="+e:e}function p(t){return null!=t}function g(t){return";"===t||"&"===t||"?"===t}function f(t,e){var r=["+","#",".","/",";","?","&"];return t=t.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,(function(t,n,i){if(n){let t="";const i=[];if(-1!==r.indexOf(n.charAt(0))&&(t=n.charAt(0),n=n.substr(1)),n.split(/,/g).forEach((function(r){var n=/([^:\*]*)(?::(\d+)|(\*))?/.exec(r);i.push(function(t,e,r,n){var i=t[r],o=[];if(p(i)&&""!==i)if("string"==typeof i||"number"==typeof i||"boolean"==typeof i)i=i.toString(),n&&"*"!==n&&(i=i.substring(0,parseInt(n,10))),o.push(m(e,i,g(e)?r:""));else if("*"===n)Array.isArray(i)?i.filter(p).forEach((function(t){o.push(m(e,t,g(e)?r:""))})):Object.keys(i).forEach((function(t){p(i[t])&&o.push(m(e,i[t],t))}));else{const t=[];Array.isArray(i)?i.filter(p).forEach((function(r){t.push(m(e,r))})):Object.keys(i).forEach((function(r){p(i[r])&&(t.push(d(r)),t.push(m(e,i[r].toString())))})),g(e)?o.push(d(r)+"="+t.join(",")):0!==t.length&&o.push(t.join(","))}else";"===e?p(i)&&o.push(d(r)):""!==i||"&"!==e&&"?"!==e?""===i&&o.push(""):o.push(d(r)+"=");return o}(e,t,n[1],n[2]||n[3]))})),t&&"+"!==t){var o=",";return"?"===t?o="&":"#"!==t&&(o=t),(0!==i.length?t:"")+i.join(o)}return i.join(",")}return h(i)})),"/"===t?t:t.replace(/\/$/,"")}function y(t){let e,r=t.method.toUpperCase(),n=(t.url||"/").replace(/:([a-z]\w+)/g,"{$1}"),i=Object.assign({},t.headers),o=c(t,["method","baseUrl","url","headers","request","mediaType"]);const s=function(t){const e=t.match(u);return e?e.map(l).reduce(((t,e)=>t.concat(e)),[]):[]}(n);var a;n=(a=n,{expand:f.bind(null,a)}).expand(o),/^http/.test(n)||(n=t.baseUrl+n);const h=c(o,Object.keys(t).filter((t=>s.includes(t))).concat("baseUrl"));if(!/application\/octet-stream/i.test(i.accept)&&(t.mediaType.format&&(i.accept=i.accept.split(/,/).map((e=>e.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,`application/vnd$1$2.${t.mediaType.format}`))).join(",")),n.endsWith("/graphql")&&t.mediaType.previews?.length)){const e=i.accept.match(/[\w-]+(?=-preview)/g)||[];i.accept=e.concat(t.mediaType.previews).map((e=>`application/vnd.github.${e}-preview${t.mediaType.format?`.${t.mediaType.format}`:"+json"}`)).join(",")}return["GET","HEAD"].includes(r)?n=function(t,e){const r=/\?/.test(t)?"&":"?",n=Object.keys(e);return 0===n.length?t:t+r+n.map((t=>"q"===t?"q="+e.q.split("+").map(encodeURIComponent).join("+"):`${t}=${encodeURIComponent(e[t])}`)).join("&")}(n,h):"data"in h?e=h.data:Object.keys(h).length&&(e=h),i["content-type"]||void 0===e||(i["content-type"]="application/json; charset=utf-8"),["PATCH","PUT"].includes(r)&&void 0===e&&(e=""),Object.assign({method:r,url:n,headers:i},void 0!==e?{body:e}:null,t.request?{request:t.request}:null)}function w(t,e,r){return y(a(t,e,r))}function v(){return"object"==typeof navigator&&"userAgent"in navigator?navigator.userAgent:"object"==typeof process&&void 0!==process.version?`Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`:"<environment undetectable>"}const b=function t(e,r){const n=a(e,r),i=w.bind(null,n);return Object.assign(i,{DEFAULTS:n,defaults:t.bind(null,n),merge:a.bind(null,n),parse:y})}(null,{method:"GET",baseUrl:"https://api.github.com",headers:{accept:"application/vnd.github.v3+json","user-agent":`octokit-endpoint.js/9.0.2 ${v()}`},mediaType:{format:""}});class Deprecation extends Error{constructor(t){super(t),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="Deprecation"}}var C=r(778),$=r.n(C);const R=$()((t=>console.warn(t))),P=$()((t=>console.warn(t)));class RequestError extends Error{constructor(t,e,r){let n;super(t),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="HttpError",this.status=e,"headers"in r&&void 0!==r.headers&&(n=r.headers),"response"in r&&(this.response=r.response,n=r.response.headers);const i=Object.assign({},r.request);r.request.headers.authorization&&(i.headers=Object.assign({},r.request.headers,{authorization:r.request.headers.authorization.replace(/ .*$/," [REDACTED]")})),i.url=i.url.replace(/\bclient_secret=\w+/g,"client_secret=[REDACTED]").replace(/\baccess_token=\w+/g,"access_token=[REDACTED]"),this.request=i,Object.defineProperty(this,"code",{get:()=>(R(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")),e)}),Object.defineProperty(this,"headers",{get:()=>(P(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")),n||{})})}}function G(t){const e=t.request&&t.request.log?t.request.log:console,r=!1!==t.request?.parseSuccessResponseBody;(i(t.body)||Array.isArray(t.body))&&(t.body=JSON.stringify(t.body));let n,o,s={},{fetch:a}=globalThis;if(t.request?.fetch&&(a=t.request.fetch),!a)throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");return a(t.url,{method:t.method,body:t.body,headers:t.headers,signal:t.request?.signal,...t.body&&{duplex:"half"}}).then((async i=>{o=i.url,n=i.status;for(const t of i.headers)s[t[0]]=t[1];if("deprecation"in s){const r=s.link&&s.link.match(/<([^>]+)>; rel="deprecation"/),n=r&&r.pop();e.warn(`[@octokit/request] "${t.method} ${t.url}" is deprecated. It is scheduled to be removed on ${s.sunset}${n?`. See ${n}`:""}`)}if(204!==n&&205!==n){if("HEAD"===t.method){if(n<400)return;throw new RequestError(i.statusText,n,{response:{url:o,status:n,headers:s,data:void 0},request:t})}if(304===n)throw new RequestError("Not modified",n,{response:{url:o,status:n,headers:s,data:await S(i)},request:t});if(n>=400){const e=await S(i),r=new RequestError(function(t){if("string"==typeof t)return t;if("message"in t)return Array.isArray(t.errors)?`${t.message}: ${t.errors.map(JSON.stringify).join(", ")}`:t.message;return`Unknown error: ${JSON.stringify(t)}`}(e),n,{response:{url:o,status:n,headers:s,data:e},request:t});throw r}return r?await S(i):i.body}})).then((t=>({status:n,url:o,headers:s,data:t}))).catch((e=>{if(e instanceof RequestError)throw e;if("AbortError"===e.name)throw e;let r=e.message;throw"TypeError"===e.name&&"cause"in e&&(e.cause instanceof Error?r=e.cause.message:"string"==typeof e.cause&&(r=e.cause)),new RequestError(r,500,{request:t})}))}async function S(t){const e=t.headers.get("content-type");return/application\/json/.test(e)?t.json().catch((()=>t.text())).catch((()=>"")):!e||/^text\/|charset=utf-8$/.test(e)?t.text():function(t){return t.arrayBuffer()}(t)}const H=function t(e,r){const n=e.defaults(r);return Object.assign((function(e,r){const i=n.merge(e,r);if(!i.request||!i.request.hook)return G(n.parse(i));const o=(t,e)=>G(n.parse(n.merge(t,e)));return Object.assign(o,{endpoint:n,defaults:t.bind(null,n)}),i.request.hook(o,i)}),{endpoint:n,defaults:t.bind(null,n)})}(b,{headers:{"user-agent":`octokit-request.js/8.1.5 ${v()}`}});var U=class extends Error{constructor(t,e,r){super("Request failed due to following response errors:\n"+r.errors.map((t=>` - ${t.message}`)).join("\n")),this.request=t,this.headers=e,this.response=r,this.name="GraphqlResponseError",this.errors=r.errors,this.data=r.data,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}},D=["method","baseUrl","url","headers","request","query","mediaType"],q=["query","method","url"],F=/\/api\/v3\/?$/;function E(t,e){const r=t.defaults(e);return Object.assign(((t,e)=>function(t,e,r){if(r){if("string"==typeof e&&"query"in r)return Promise.reject(new Error('[@octokit/graphql] "query" cannot be used as variable name'));for(const t in r)if(q.includes(t))return Promise.reject(new Error(`[@octokit/graphql] "${t}" cannot be used as variable name`))}const n="string"==typeof e?Object.assign({query:e},r):e,i=Object.keys(n).reduce(((t,e)=>D.includes(e)?(t[e]=n[e],t):(t.variables||(t.variables={}),t.variables[e]=n[e],t)),{}),o=n.baseUrl||t.endpoint.DEFAULTS.baseUrl;return F.test(o)&&(i.url=o.replace(F,"/api/graphql")),t(i).then((t=>{if(t.data.errors){const e={};for(const r of Object.keys(t.headers))e[r]=t.headers[r];throw new U(i,e,t.data)}return t.data.data}))}(r,t,e)),{defaults:E.bind(null,r),endpoint:r.endpoint})}var M=E(H,{headers:{"user-agent":`octokit-graphql.js/7.0.2 ${v()}`},method:"POST",url:"/graphql"});var A=r(9496),x=r(3309),k=r(7338),T=r(4575),_=r(4321),I=r(2075),B=r(7925),O=r(2800),j=r(5148),N=r(4241),L=r(4336),Y=r(6004),V=r(6398),W=r(4627),z=r(4550),Q=r(3878),K=Object.defineProperty,J=Object.getOwnPropertyDescriptor,X=(t,e,r,n)=>{for(var i,o=n>1?void 0:n?J(e,r):e,s=t.length-1;s>=0;s--)(i=t[s])&&(o=(n?i(e,r,o):i(o))||o);return n&&o&&K(e,r,o),o};const Z=Object.freeze({values:[]}),tt=Object.freeze({ranges:[]}),et="\nassignees(first: 10) {\n\tnodes {\n\t\tlogin\n\t\tavatarUrl\n\t\turl\n\t}\n}\nauthor {\n\tlogin\n\tavatarUrl\n\turl\n}\nbaseRefName\nbaseRefOid\nbaseRepository {\n\tname\n\towner {\n\t\tlogin\n\t}\n\turl\n}\nchecksUrl\nisDraft\nisCrossRepository\nisReadByViewer\nheadRefName\nheadRefOid\nheadRepository {\n\tname\n\towner {\n\t\tlogin\n\t}\n\turl\n}\npermalink\nid\nnumber\ntitle\nstate\nadditions\ndeletions\nupdatedAt\nclosedAt\nmergeable\nmergedAt\nmergedBy {\n\tlogin\n}\nrepository {\n\tisFork\n\towner {\n\t\tlogin\n\t}\n}\nreviewDecision\nreviewRequests(first: 10) {\n\tnodes {\n\t\tasCodeOwner\n\t\tid\n\t\trequestedReviewer {\n\t\t\t... on User {\n\t\t\t\tlogin\n\t\t\t\tavatarUrl\n\t\t\t\turl\n\t\t\t}\n\t\t}\n\t}\n}\ntotalCommentsCount\n",rt="\n... on Issue {\n\tassignees(first: 100) {\n\t\tnodes {\n\t\t\tlogin\n\t\t\turl\n\t\t\tavatarUrl\n\t\t}\n\t}\n\tauthor {\n\t\tlogin\n\t\tavatarUrl\n\t\turl\n\t}\n\tcomments {\n\t  totalCount\n\t}\n\tid\n\tnumber\n\ttitle\n\turl\n\tcreatedAt\n\tclosedAt\n\tclosed\n\tupdatedAt\n\tlabels(first: 20) {\n\t\tnodes {\n\t\t\tcolor\n\t\t\tname\n\t\t}\n\t}\n\treactions(content: THUMBS_UP) {\n\t  totalCount\n\t}\n\trepository {\n\t\tname\n\t\towner {\n\t\t\tlogin\n\t\t}\n\t}\n}\n";class GitHubApi{_onDidReauthenticate=new A.EventEmitter;get onDidReauthenticate(){return this._onDidReauthenticate.event}_disposable;constructor(t){this._disposable=j.D.onDidChangeAny((t=>{(j.D.changedAny(t,["http.proxy","http.proxyStrictSSL"])||j.D.changed(t,["outputLevel","proxy"]))&&this.resetCaches()}))}dispose(){this._disposable.dispose()}resetCaches(){this._proxyAgent=null,this._defaults.clear(),this._enterpriseVersions.clear()}_proxyAgent=null;get proxyAgent(){if(!k.$L)return null===this._proxyAgent&&(this._proxyAgent=(0,x.Nx)()),this._proxyAgent}async getAccountForCommit(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getAccountForCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: GitObjectID!\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $ref) {\n\t\t\t... on Commit {\n\t\t\t\tauthor {\n\t\t\t\t\tname\n\t\t\t\t\temail\n\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,ref:i},s),l=u?.repository?.object?.author;if(null==l)return;return{provider:t,name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||nt(o)?l.avatarUrl??void 0:l.email&&null!=o?.baseUrl?await this.createEnterpriseAvatarUrl(t,e,o.baseUrl,l.email,o.avatarSize):void 0}}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,s)}}async getAccountForEmail(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getAccountForEmail(\n\t$emailQuery: String!\n\t$avatarSize: Int\n) {\n\tsearch(type: USER, query: $emailQuery, first: 1) {\n\t\tnodes {\n\t\t\t... on User {\n\t\t\t\tname\n\t\t\t\temail\n\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,emailQuery:`in:email ${i}`},s),l=u?.search?.nodes?.[0];if(null==l)return;return{provider:t,name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||nt(o)?l.avatarUrl??void 0:l.email&&null!=o?.baseUrl?await this.createEnterpriseAvatarUrl(t,e,o.baseUrl,l.email,o.avatarSize):void 0}}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,s)}}async getDefaultBranch(t,e,r,n,i){const o=(0,Y.UH)();try{const s="query getDefaultBranch(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tdefaultBranchRef {\n\t\t\tname\n\t\t}\n\t}\n}",a=await this.graphql(t,e,s,{...i,owner:r,repo:n},o),u=a?.repository?.defaultBranchRef?.name??void 0;if(null==u)return;return{provider:t,name:u}}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,o)}}async getIssueOrPullRequest(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getIssueOrPullRequest(\n\t$owner: String!\n\t$repo: String!\n\t$number: Int!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tissueOrPullRequest(number: $number) {\n\t\t\t__typename\n\t\t\t... on Issue {\n\t\t\t\tcreatedAt\n\t\t\t\tclosed\n\t\t\t\tclosedAt\n\t\t\t\tid\n\t\t\t\ttitle\n\t\t\t\turl\n\t\t\t\tstate\n\t\t\t}\n\t\t\t... on PullRequest {\n\t\t\t\tcreatedAt\n\t\t\t\tclosed\n\t\t\t\tclosedAt\n\t\t\t\tid\n\t\t\t\ttitle\n\t\t\t\turl\n\t\t\t\tstate\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,number:i},s),l=u?.repository?.issueOrPullRequest;if(null==l)return;return{provider:t,type:l.type,id:String(i),nodeId:l.id,date:new Date(l.createdAt),title:l.title,closed:l.closed,closedDate:null==l.closedAt?void 0:new Date(l.closedAt),url:l.url,state:(0,Q.fromGitHubPullRequestState)(l.state)}}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,s)}}async getPullRequestForBranch(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getPullRequestForBranch(\n\t$owner: String!\n\t$repo: String!\n\t$branch: String!\n\t$limit: Int!\n\t$include: [PullRequestState!]\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tref(qualifiedName: $branch) {\n\t\t\tassociatedPullRequests(first: $limit, orderBy: {field: UPDATED_AT, direction: DESC}, states: $include) {\n\t\t\t\tnodes {\n\t\t\t\t\tauthor {\n\t\t\t\t\t\tlogin\n\t\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t\t\turl\n\t\t\t\t\t}\n\t\t\t\t\tpermalink\n\t\t\t\t\tnumber\n\t\t\t\t\ttitle\n\t\t\t\t\tstate\n\t\t\t\t\tupdatedAt\n\t\t\t\t\tclosedAt\n\t\t\t\t\tmergedAt\n\t\t\t\t\trepository {\n\t\t\t\t\t\tisFork\n\t\t\t\t\t\towner {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...o,owner:r,repo:n,branch:`refs/heads/${i}`,limit:10},s),l=u?.repository?.ref?.associatedPullRequests?.nodes?.filter((t=>null!=t&&(!t.repository.isFork||t.repository.owner.login===r)));if(null==l||0===l.length)return;return l.length>1&&l.sort(((t,e)=>(t.repository.owner.login===r?-1:1)-(e.repository.owner.login===r?-1:1)||("OPEN"===t.state?-1:1)-("OPEN"===e.state?-1:1)||new Date(e.updatedAt).getTime()-new Date(t.updatedAt).getTime())),(0,Q.fromGitHubPullRequest)(l[0],t)}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,s)}}async getPullRequestForCommit(t,e,r,n,i,o,s){const a=(0,Y.UH)();try{const u="query getPullRequestForCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: GitObjectID!\n\t$avatarSize: Int\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $ref) {\n\t\t\t... on Commit {\n\t\t\t\tassociatedPullRequests(first: 2, orderBy: {field: UPDATED_AT, direction: DESC}) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\tavatarUrl(size: $avatarSize)\n\t\t\t\t\t\t\turl\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpermalink\n\t\t\t\t\t\tnumber\n\t\t\t\t\t\ttitle\n\t\t\t\t\t\tstate\n\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\tclosedAt\n\t\t\t\t\t\tmergedAt\n\t\t\t\t\t\trepository {\n\t\t\t\t\t\t\tisFork\n\t\t\t\t\t\t\towner {\n\t\t\t\t\t\t\t\tlogin\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",l=await this.graphql(t,e,u,{...o,owner:r,repo:n,ref:i},a,s),c=l?.repository?.object?.associatedPullRequests?.nodes?.filter((t=>null!=t&&(!t.repository.isFork||t.repository.owner.login===r)));if(null==c||0===c.length)return;return c.length>1&&c.sort(((t,e)=>(t.repository.owner.login===r?-1:1)-(e.repository.owner.login===r?-1:1)||("MERGED"===t.state?-1:1)-("MERGED"===e.state?-1:1)||new Date(e.updatedAt).getTime()-new Date(t.updatedAt).getTime())),(0,Q.fromGitHubPullRequest)(c[0],t)}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,a)}}async getRepositoryMetadata(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getRepositoryMetadata(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\towner {\n\t\t\tlogin\n\t\t}\n\t\tname\n\t\tparent {\n\t\t\towner {\n\t\t\t\tlogin\n\t\t\t}\n\t\t\tname\n\t\t}\n\t}\n}",u=await this.graphql(t,e,a,{...i,owner:r,repo:n},s,o),l=u?.repository??void 0;if(null==l)return;return{provider:t,owner:l.owner.login,name:l.name,isFork:null!=l.parent,parent:null!=l.parent?{owner:l.parent.owner.login,name:l.parent.name}:void 0}}catch(e){if(e instanceof T.Ww)return;throw this.handleException(e,t,s)}}async getBlame(t,e,r,n,i){const o=(0,Y.UH)();try{const s="query getBlameRanges(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String!\n) {\n\tviewer { name }\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\t...on Commit {\n\t\t\t\tblame(path: $path) {\n\t\t\t\t\tranges {\n\t\t\t\t\t\tstartingLine\n\t\t\t\t\t\tendingLine\n\t\t\t\t\t\tcommit {\n\t\t\t\t\t\t\toid\n\t\t\t\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\tadditions\n\t\t\t\t\t\t\tchangedFiles\n\t\t\t\t\t\t\tdeletions\n\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcommitter {\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i},o);if(null==a)return tt;const u=a.repository?.object?.blame?.ranges;return null==u||0===u.length?{ranges:[],viewer:a.viewer?.name}:{ranges:u,viewer:a.viewer?.name}}catch(t){if(t instanceof T.Ww)return tt;throw this.handleException(t,void 0,o)}}async getBranches(t,e,r,n){const i=(0,Y.UH)();try{const o='query getBranches(\n\t$owner: String!\n\t$repo: String!\n\t$branchQuery: String\n\t$cursor: String\n\t$limit: Int = 100\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(query: $branchQuery, refPrefix: "refs/heads/", first: $limit, after: $cursor) {\n\t\t\tpageInfo {\n\t\t\t\tendCursor\n\t\t\t\thasNextPage\n\t\t\t}\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\toid\n\t\t\t\t\t...on Commit {\n\t\t\t\t\t\tauthoredDate\n\t\t\t\t\t\tcommittedDate\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',s=await this.graphql(void 0,t,o,{owner:e,repo:r,branchQuery:n?.query,cursor:n?.cursor,limit:Math.min(100,n?.limit??100)},i);if(null==s)return Z;const a=s.repository?.refs;return null==a?Z:{paging:{cursor:a.pageInfo.endCursor,more:a.pageInfo.hasNextPage},values:a.nodes}}catch(t){if(t instanceof T.Ww)return Z;throw this.handleException(t,void 0,i)}}async getCommit(t,e,r,n){const i=(0,Y.UH)();try{const o=await this.request(void 0,t,"GET /repos/{owner}/{repo}/commits/{ref}",{owner:e,repo:r,ref:n},i),s=o?.data;if(null==s)return;const{commit:a}=s;return{oid:s.sha,parents:{nodes:s.parents.map((t=>({oid:t.sha})))},message:a.message,additions:s.stats?.additions,changedFiles:s.files?.length,deletions:s.stats?.deletions,author:{avatarUrl:s.author?.avatar_url??void 0,date:a.author?.date??(new Date).toString(),email:a.author?.email??void 0,name:a.author?.name??""},committer:{date:a.committer?.date??(new Date).toString(),email:a.committer?.email??void 0,name:a.committer?.name??""},files:s.files}}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,i)}}async getCommitForFile(t,e,r,n,i){if((0,_.D3)(n))return this.getCommit(t,e,r,n);const o=await this.getCommits(t,e,r,n,{limit:1,path:i});if(0===o.values.length)return;return{...await this.getCommit(t,e,r,o.values[0].oid)??o.values[0],viewer:o.viewer}}async getCommitBranches(t,e,r,n,i){const o=(0,Y.UH)();try{const s='query getCommitBranches(\n\t$owner: String!\n\t$repo: String!\n\t$since: GitTimestamp!\n\t$until: GitTimestamp!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(first: 20, refPrefix: "refs/heads/") {\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\t... on Commit {\n\t\t\t\t\t\thistory(first: 3, since: $since until: $until) {\n\t\t\t\t\t\t\tnodes { oid }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',a=await this.graphql(void 0,t,s,{owner:e,repo:r,since:i.toISOString(),until:i.toISOString()},o),u=a?.repository?.refs?.nodes;if(null==u)return[];const l=[];for(const t of u)for(const e of t.target.history.nodes)if(e.oid===n){l.push(t.name);break}return l}catch(t){if(t instanceof T.Ww)return[];throw this.handleException(t,void 0,o)}}async getCommitCount(t,e,r,n){const i=(0,Y.UH)();try{const o="query getCommitCount(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tref(qualifiedName: $ref) {\n\t\t\ttarget {\n\t\t\t\t... on Commit {\n\t\t\t\t\thistory(first: 1) {\n\t\t\t\t\t\ttotalCount\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,ref:n},i),a=s?.repository?.ref?.target.history.totalCount;return a}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,i)}}async getCommitOnBranch(t,e,r,n,i,o){const s=(0,Y.UH)();try{const a="query getCommitOnBranch(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$since: GitTimestamp!\n\t$until: GitTimestamp!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tref(qualifiedName: $ref) {\n\t\t\ttarget {\n\t\t\t\t... on Commit {\n\t\t\t\t\thistory(first: 3, since: $since until: $until) {\n\t\t\t\t\t\tnodes { oid }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",u=await this.graphql(void 0,t,a,{owner:e,repo:r,ref:`refs/heads/${n}`,since:o.toISOString(),until:o.toISOString()},s),l=u?.repository?.ref.target.history.nodes;if(null==l)return[];const c=[];for(const t of l)if(t.oid===i){c.push(n);break}return c}catch(t){if(t instanceof T.Ww)return[];throw this.handleException(t,void 0,s)}}async getCommits(t,e,r,n,i){const o=(0,Y.UH)();if(1===i?.limit&&null==i?.path)return this.getCommitsCoreSingle(t,e,r,n);try{const s="query getCommits(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String\n\t$author: CommitAuthor\n\t$after: String\n\t$before: String\n\t$limit: Int = 100\n\t$since: GitTimestamp\n\t$until: GitTimestamp\n) {\n\tviewer { name }\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: $limit, author: $author, path: $path, after: $after, before: $before, since: $since, until: $until) {\n\t\t\t\t\tpageInfo {\n\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\tendCursor\n\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\thasPreviousPage\n\t\t\t\t\t}\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t... on Commit {\n\t\t\t\t\t\t\toid\n\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\t\t\t\tadditions\n\t\t\t\t\t\t\tchangedFiles\n\t\t\t\t\t\t\tdeletions\n\t\t\t\t\t\t\tauthor {\n\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\tdate\n\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcommitter {\n\t\t\t\t\t\t\t\t date\n\t\t\t\t\t\t\t\t email\n\t\t\t\t\t\t\t\t name\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}";let a;if(null!=i?.authors)if(1===i.authors.length){const[t]=i.authors;a={id:t.id,emails:t.email?[t.email]:void 0}}else{const t=i.authors.filter((t=>t.email)).map((t=>t.email));a=t.length?{emails:t}:void 0}const u=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,after:i?.after,before:i?.before,path:i?.path,author:a,limit:Math.min(100,i?.limit??100),since:"string"==typeof i?.since?i?.since:i?.since?.toISOString(),until:"string"==typeof i?.until?i?.until:i?.until?.toISOString()},o),l=u?.repository?.object?.history;return null==l?Z:{paging:null!=l.pageInfo.endCursor?{cursor:l.pageInfo.endCursor??void 0,more:l.pageInfo.hasNextPage}:void 0,values:l.nodes,viewer:u?.viewer.name}}catch(t){if(t instanceof T.Ww)return Z;throw this.handleException(t,void 0,o)}}async getCommitsCoreSingle(t,e,r,n){const i=(0,Y.UH)();try{const o="query getCommit(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\tviewer { name }\n\trepository(name: $repo owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t...on Commit {\n\t\t\t\toid\n\t\t\t\tparents(first: 3) { nodes { oid } }\n\t\t\t\tmessage\n\t\t\t\tadditions\n\t\t\t\tchangedFiles\n\t\t\t\tdeletions\n\t\t\t\tauthor {\n\t\t\t\t\tavatarUrl\n\t\t\t\t\tdate\n\t\t\t\t\temail\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t\tcommitter {\n\t\t\t\t\tdate\n\t\t\t\t\temail\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,ref:n},i);if(null==s)return Z;const a=s.repository?.object;return null!=a?{values:[a],viewer:s.viewer.name}:Z}catch(t){if(t instanceof T.Ww)return Z;throw this.handleException(t,void 0,i)}}async getCommitRefs(t,e,r,n,i){const o=(0,Y.UH)();try{const s="query getCommitRefs(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$after: String\n\t$before: String\n\t$first: Int\n\t$last: Int\n\t$path: String\n\t$since: GitTimestamp\n\t$until: GitTimestamp\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: $first, last: $last, path: $path, since: $since, until: $until, after: $after, before: $before) {\n\t\t\t\t\tpageInfo { startCursor, endCursor, hasNextPage, hasPreviousPage }\n\t\t\t\t\ttotalCount\n\t\t\t\t\tnodes { oid }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i?.path,first:i?.first,last:i?.last,after:i?.after,before:i?.before,since:i?.since,until:i?.until},o),u=a?.repository?.object?.history;if(null==u)return;return{pageInfo:u.pageInfo,totalCount:u.totalCount,values:u.nodes}}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,o)}}async getCommitTags(t,e,r,n,i){const o=(0,Y.UH)();try{const s='query getCommitTags(\n\t$owner: String!\n\t$repo: String!\n\t$since: GitTimestamp!\n\t$until: GitTimestamp!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(first: 20, refPrefix: "refs/tags/") {\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\t... on Commit {\n\t\t\t\t\t\thistory(first: 3, since: $since until: $until) {\n\t\t\t\t\t\t\tnodes { oid }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',a=await this.graphql(void 0,t,s,{owner:e,repo:r,since:i.toISOString(),until:i.toISOString()},o),u=a?.repository?.refs?.nodes;if(null==u)return[];const l=[];for(const t of u)for(const e of t.target.history.nodes)if(e.oid===n){l.push(t.name);break}return l}catch(t){if(t instanceof T.Ww)return[];throw this.handleException(t,void 0,o)}}async getNextCommitRefs(t,e,r,n,i,o){const s=await this.getCommitDate(t,e,r,o);if(null==s)return[];let a=await this.getCommitRefs(t,e,r,n,{path:i,first:1,since:s});if(null==a)return[];const u=`${a.pageInfo.startCursor.split(" ",1)[0]} ${a.totalCount}`;let l;if([,l]=u.split(" ",2),l=Math.min(parseInt(l,10),5),a=await this.getCommitRefs(t,e,r,n,{path:i,last:l,before:u}),null==a)return[];const c=[];for(const{oid:t}of a.values){if(t===o)break;c.push(t)}return c.reverse()}async getCommitDate(t,e,r,n){const i=(0,Y.UH)();try{const o="query getCommitDate(\n\t$owner: String!\n\t$repo: String!\n\t$sha: GitObjectID!\n) {\n\trepository(name: $repo, owner: $owner) {\n\t\tobject(oid: $sha) {\n\t\t\t... on Commit { committer { date } }\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,o,{owner:e,repo:r,sha:n},i),a=s?.repository?.object?.committer.date;return a}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,i)}}async getContributors(t,e,r){const n=(0,Y.UH)();try{const i=await this.request(void 0,t,"GET /repos/{owner}/{repo}/contributors",{owner:e,repo:r,per_page:100},n),o=i?.data;return null==o?[]:i.data}catch(t){if(t instanceof T.Ww)return[];throw this.handleException(t,void 0,n)}}async getDefaultBranchName(t,e,r){const n=(0,Y.UH)();try{const i="query getDefaultBranch(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tdefaultBranchRef {\n\t\t\tname\n\t\t}\n\t}\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o)return;return o.repository?.defaultBranchRef?.name??void 0}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,n)}}async getCurrentUser(t,e,r){const n=(0,Y.UH)();try{const i="query getCurrentUser(\n\t$owner: String!\n\t$repo: String!\n) {\n\tviewer { name, email, login, id }\n\trepository(owner: $owner, name: $repo) { viewerPermission }\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o)return;return{name:o.viewer?.name,email:o.viewer?.email,username:o.viewer?.login,id:o.viewer?.id}}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,n)}}async getRepositoryVisibility(t,e,r){const n=(0,Y.UH)();try{const i="query getRepositoryVisibility(\n\t$owner: String!\n\t$repo: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tvisibility\n\t}\n}",o=await this.graphql(void 0,t,i,{owner:e,repo:r},n);if(null==o?.repository?.visibility)return;return"PUBLIC"===o.repository.visibility?"public":"private"}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,n)}}async getTags(t,e,r,n){const i=(0,Y.UH)();try{const o='query getTags(\n\t$owner: String!\n\t$repo: String!\n\t$tagQuery: String\n\t$cursor: String\n\t$limit: Int = 100\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\trefs(query: $tagQuery, refPrefix: "refs/tags/", first: $limit, after: $cursor, orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {\n\t\t\tpageInfo {\n\t\t\t\tendCursor\n\t\t\t\thasNextPage\n\t\t\t}\n\t\t\tnodes {\n\t\t\t\tname\n\t\t\t\ttarget {\n\t\t\t\t\toid\n\t\t\t\t\t...on Tag {\n\t\t\t\t\t\tmessage\n\t\t\t\t\t\ttagger { date }\n\t\t\t\t\t\ttarget {\n\t\t\t\t\t...on Commit {\n\t\t\t\t\t\t\t\toid\n\t\t\t\t\t\tauthoredDate\n\t\t\t\t\t\tcommittedDate\n\t\t\t\t\t\tmessage\n\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}',s=await this.graphql(void 0,t,o,{owner:e,repo:r,tagQuery:n?.query,cursor:n?.cursor,limit:Math.min(100,n?.limit??100)},i);if(null==s)return Z;const a=s.repository?.refs;return null==a?Z:{paging:{cursor:a.pageInfo.endCursor,more:a.pageInfo.hasNextPage},values:a.nodes}}catch(t){if(t instanceof T.Ww)return Z;throw this.handleException(t,void 0,i)}}async resolveReference(t,e,r,n,i){const o=(0,Y.UH)();try{if(!i){const i="query resolveReference(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\toid\n\t\t}\n\t}\n}",s=await this.graphql(void 0,t,i,{owner:e,repo:r,ref:n},o);return s?.repository?.object?.oid??void 0}const s="query resolveReference(\n\t$owner: String!\n\t$repo: String!\n\t$ref: String!\n\t$path: String!\n) {\n\trepository(owner: $owner, name: $repo) {\n\t\tobject(expression: $ref) {\n\t\t\t... on Commit {\n\t\t\t\thistory(first: 1, path: $path) {\n\t\t\t\t\tnodes { oid }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",a=await this.graphql(void 0,t,s,{owner:e,repo:r,ref:n,path:i},o);return a?.repository?.object?.history.nodes?.[0]?.oid??void 0}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,o)}}async searchCommits(t,e,r){const n=(0,Y.UH)(),i=Math.min(100,r?.limit??100);let o,s,a;null!=r?.cursor?([o,s,a]=r.cursor.split(" ",3),o=parseInt(o,10),s=parseInt(s,10),a=parseInt(a,10)):(o=1,s=i,a=0);try{const i=await this.request(void 0,t,"GET /search/commits",{q:e,sort:r?.sort,order:r?.order,per_page:s,page:o},n),u=i?.data;if(null==u||0===u.items.length)return;const l=u.items.map((t=>({oid:t.sha,parents:{nodes:t.parents.map((t=>({oid:t.sha})))},message:t.commit.message,author:{avatarUrl:t.author?.avatar_url??void 0,date:t.commit.author?.date??t.commit.author?.date??(new Date).toString(),email:t.author?.email??t.commit.author?.email??void 0,name:t.author?.name??t.commit.author?.name??""},committer:{date:t.commit.committer?.date??t.committer?.date??(new Date).toString(),email:t.committer?.email??t.commit.committer?.email??void 0,name:t.committer?.name??t.commit.committer?.name??""}}))),c=a+u.items.length,h=u.incomplete_results||u.total_count>c;return{pageInfo:{startCursor:`${o} ${s} ${a}`,endCursor:h?`${o+1} ${s} ${c}`:void 0,hasPreviousPage:u.total_count>0&&o>1,hasNextPage:h},totalCount:u.total_count,values:l}}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,n)}}async searchCommitShas(t,e,r){const n=(0,Y.UH)(),i=Math.min(100,r?.limit??100);let o,s,a;null!=r?.cursor?([o,s,a]=r.cursor.split(" ",3),o=parseInt(o,10),s=parseInt(s,10),a=parseInt(a,10)):(o=1,s=i,a=0);try{const i=await this.request(void 0,t,"GET /search/commits",{q:e,sort:r?.sort,order:r?.order,per_page:s,page:o},n),u=i?.data;if(null==u||0===u.items.length)return;const l=a+u.items.length,c=u.incomplete_results||u.total_count>l;return{pageInfo:{startCursor:`${o} ${s} ${a}`,endCursor:c?`${o+1} ${s} ${l}`:void 0,hasPreviousPage:u.total_count>0&&o>1,hasNextPage:c},totalCount:u.total_count,values:u.items.map((t=>({sha:t.sha,authorDate:new Date(t.commit.author.date).getTime(),committerDate:new Date(t.commit.committer?.date??t.commit.author.date).getTime()})))}}catch(t){if(t instanceof T.Ww)return;throw this.handleException(t,void 0,n)}}_enterpriseVersions=new Map;async getEnterpriseVersion(t,e,r){let n=this._enterpriseVersions.get(e);if(null!=n)return n;if(null===n)return;const i=(0,Y.UH)();try{const o=await this.request(t,e,"GET /meta",r,i),s=o?.data?.installed_version;n=s?(0,z.mL)(s):null}catch(t){n=null}return this._enterpriseVersions.set(e,n),n??void 0}async graphql(t,e,r,n,i,o){try{let i;if(null!=o){if(o.isCancellationRequested)throw new T.FU;i=new AbortController,o.onCancellationRequested((()=>i.abort())),n={...n,request:{...n?.request,signal:i.signal}}}return await(0,x.a_)(t?.getIgnoreSSLErrors()??!1,(()=>this.getDefaults(e,M)(r,n)))}catch(r){if(r instanceof U){switch(r.errors?.[0]?.type){case"NOT_FOUND":throw new T.Ww(r);case"FORBIDDEN":throw new T._7("github",T.Jx.Forbidden,r);case"RATE_LIMITED":{let t;const n=r.headers?.["x-ratelimit-reset"];throw null!=n&&(t=parseInt(n,10),Number.isNaN(t)&&(t=void 0)),new T.yx(r,e,t)}}L.Yd.isDebugging&&A.window.showErrorMessage(`GitHub request failed: ${r.errors?.[0]?.message??r.message}`)}else r instanceof RequestError||"AbortError"===r.name?this.handleRequestError(t,e,r,i):L.Yd.isDebugging&&A.window.showErrorMessage(`GitHub request failed: ${r.message}`);throw r}}async request(t,e,r,n,i,o){try{let i;if(null!=o){if(o.isCancellationRequested)throw new T.FU;i=new AbortController,o.onCancellationRequested((()=>i.abort())),n={...n,request:{...n?.request,signal:i.signal}}}return await(0,x.a_)(t?.getIgnoreSSLErrors()??!1,(()=>this.getDefaults(e,H)(r,n)))}catch(r){throw r instanceof RequestError||"AbortError"===r.name?this.handleRequestError(t,e,r,i):L.Yd.isDebugging&&A.window.showErrorMessage(`GitHub request failed: ${r.message}`),r}}_defaults=new Map;getDefaults(t,e){let r=this._defaults.get(e);null==r&&(r=new Map,this._defaults.set(e,r));let n=r.get(t);return null==n&&(n=e.defaults({headers:{authorization:`token ${t}`},request:{agent:this.proxyAgent,fetch:k.$L?(t,e)=>{if(null!=e.headers){const{"user-agent":t,...r}=e.headers;t&&(e.headers=r)}return(0,x.he)(t,e)}:x.he,hook:"debug"===L.Yd.logLevel||L.Yd.isDebugging?async(t,e)=>{const r=(0,V.k)(`[GITHUB] ${e.method} ${e.url}`,{log:!1});try{return await t(e)}finally{let t;try{if("string"==typeof e.query){const r=/(^[^({\n]+)/.exec(e.query);t=` ${r?.[1].trim()??e.query}`}}catch{}r?.stop({message:t})}}:void 0}}),r.set(t,n)),n}handleRequestError(t,e,r,n){if("AbortError"===r.name)throw new T.FU;switch(r.status){case 404:case 410:case 422:throw new T.Ww(r);case 401:throw new T._7("github",T.Jx.Unauthorized,r);case 403:if(r.message.includes("rate limit")){let t;const n=r.response?.headers?.["x-ratelimit-reset"];throw null!=n&&(t=parseInt(n,10),Number.isNaN(t)&&(t=void 0)),new T.yx(r,e,t)}throw new T._7("github",T.Jx.Forbidden,r);case 500:return L.Yd.error(r,n),void(null!=r.response&&(t?.trackRequestException(),(0,B.vF)(`${t?.name??"GitHub"} failed to respond and might be experiencing issues.${t?.custom?"":" Please visit the [GitHub status page](https://githubstatus.com) for more information."}`)));case 502:if(L.Yd.error(r,n),r.message.includes("timeout"))return t?.trackRequestException(),void(0,B.s$)(t?.name??"GitHub");break;default:if(r.status>=400&&r.status<500)throw new T.Bn(r)}L.Yd.error(r,n),L.Yd.isDebugging&&A.window.showErrorMessage(`GitHub request failed: ${r.response?.errors?.[0]?.message??r.message}`)}handleException(t,e,r){return L.Yd.error(t,r),t instanceof T._7&&this.showAuthenticationErrorMessage(t,e),t}async showAuthenticationErrorMessage(t,e){if(t.reason===T.Jx.Unauthorized||t.reason===T.Jx.Forbidden){const r="Reauthenticate";await A.window.showErrorMessage(`${t.message}. Would you like to try reauthenticating${t.reason===T.Jx.Forbidden?" to provide additional access":""}?`,r)===r&&(await(e?.reauthenticate()),this.resetCaches(),this._onDidReauthenticate.fire())}else A.window.showErrorMessage(t.message)}async createEnterpriseAvatarUrl(t,e,r,n,i){i=i??16;const o=await this.getEnterpriseVersion(t,e,{baseUrl:r});if((0,z.L5)(o,">= 3.0.0")){let o;const s=(0,I.at)(n);null!=s&&A.Uri.parse(r).authority===s.authority&&(null!=s.userId?o=`${r}/enterprise/avatars/u/${encodeURIComponent(s.userId)}?s=${i}`:null!=s.login&&(o=`${r}/enterprise/avatars/${encodeURIComponent(s.login)}?s=${i}`)),null==o&&(o=`${r}/enterprise/avatars/u/e?email=${encodeURIComponent(n)}&s=${i}`);const a=await(0,x.a_)(t?.getIgnoreSSLErrors()??!1,(()=>(0,x.he)(o,{method:"GET",headers:{Authorization:`Bearer ${e}`}})));if(a.ok){const t=(0,W.US)(new Uint8Array(await a.arrayBuffer()));return`data:${a.headers.get("content-type")};base64,${t}`}}return`https://avatars.githubusercontent.com/u/e?email=${encodeURIComponent(n)}&s=${i}`}async searchMyPullRequests(t,e,r){const n=(0,Y.UH)();try{let i=function(e,r){return{pullRequest:(0,Q.fromGitHubPullRequestDetailed)(e,t),reasons:r?[r]:[]}};const o=`query searchPullRequests(\n\t$authored: String!\n\t$assigned: String!\n\t$reviewRequested: String!\n\t$mentioned: String!\n) {\n\tauthored: search(first: 100, query: $authored, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${et}\n\t\t\t}\n\t\t}\n\t}\n\tassigned: search(first: 100, query: $assigned, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${et}\n\t\t\t}\n\t\t}\n\t}\n\treviewRequested: search(first: 100, query: $reviewRequested, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${et}\n\t\t\t}\n\t\t}\n\t}\n\tmentioned: search(first: 100, query: $mentioned, type: ISSUE) {\n\t\tnodes {\n\t\t\t...on PullRequest {\n\t\t\t\t${et}\n\t\t\t}\n\t\t}\n\t}\n}`;let s=r?.search?.trim()??"";if(r?.user&&(s+=` user:${r.user}`),null!=r?.repos&&r.repos.length>0){const t="  repo:";s+=`${t}${r.repos.join(t)}`}const a="is:pr is:open archived:false",u=await this.graphql(t,e,o,{authored:`${s} ${a} author:@me`.trim(),assigned:`${s} ${a} assignee:@me`.trim(),reviewRequested:`${s} ${a} review-requested:@me`.trim(),mentioned:`${s} ${a} mentions:@me`.trim(),baseUrl:r?.baseUrl},n);if(void 0===u)return[];return it([...u.assigned.nodes.map((t=>i(t,"assigned"))),...u.reviewRequested.nodes.map((t=>i(t,"review-requested"))),...u.mentioned.nodes.map((t=>i(t,"mentioned"))),...u.authored.nodes.map((t=>i(t,"authored")))],(t=>t.pullRequest.url))}catch(e){throw this.handleException(e,t,n)}}async searchMyIssues(t,e,r){const n=(0,Y.UH)(),i=`query searchIssues(\n\t\t\t\t$authored: String!\n\t\t\t\t$assigned: String!\n\t\t\t\t$mentioned: String!\n\t\t\t) {\n\t\t\t\tauthored: search(first: 100, query: $authored, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${rt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassigned: search(first: 100, query: $assigned, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${rt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmentioned: search(first: 100, query: $mentioned, type: ISSUE) {\n\t\t\t\t\tnodes {\n\t\t\t\t\t\t${rt}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`;let o=r?.search?.trim()??"";if(r?.user&&(o+=` user:${r.user}`),null!=r?.repos&&r.repos.length>0){const t="  repo:";o+=`${t}${r.repos.join(t)}`}const s="type:issue is:open archived:false";try{let a=function(e,r){return{issue:(0,Q.fromGitHubIssueDetailed)(e,t),reasons:r?[r]:[]}};const u=await this.graphql(t,e,i,{authored:`${o} ${s} author:@me`.trim(),assigned:`${o} ${s} assignee:@me`.trim(),mentioned:`${o} ${s} mentions:@me`.trim(),baseUrl:r?.baseUrl},n);if(void 0===u)return[];return it([...u.assigned.nodes.map((t=>a(t,"assigned"))),...u.mentioned.nodes.map((t=>a(t,"mentioned"))),...u.authored.nodes.map((t=>a(t,"authored")))],(t=>t.issue.url))}catch(e){throw this.handleException(e,t,n)}}}function nt(t){return null==t?.baseUrl||"https://api.github.com"===t.baseUrl}function it(t,e){return(0,O.uw)(t,e,((t,e)=>(0!==e.reasons.length&&t.reasons.push(...e.reasons),t)))}X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForCommit",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForEmail",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getDefaultBranch",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getIssueOrPullRequest",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForBranch",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForCommit",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"getRepositoryMetadata",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getBlame",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getBranches",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommit",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitForFile",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitBranches",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitCount",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitOnBranch",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommits",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitRefs",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitTags",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getNextCommitRefs",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getContributors",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getDefaultBranchName",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getCurrentUser",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getRepositoryVisibility",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"getTags",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"resolveReference",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommits",1),X([(0,N.fF)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommitShas",1),X([(0,N.fF)({args:{0:t=>t?.name,1:"<token>"}})],GitHubApi.prototype,"getEnterpriseVersion",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"searchMyPullRequests",1),X([(0,N.fF)({args:{0:t=>t.name,1:"<token>"}})],GitHubApi.prototype,"searchMyIssues",1)},5168:(t,e,r)=>{r.r(e),r.d(e,{GitHubGitProvider:()=>GitHubGitProvider});var n=r(9496),i=r(6150),o=r(5255),s=r(3148),a=r(4575),u=r(8887),l=r(6592),c=r(7462),h=r(5367),d=r(6450),m=r(439),p=r(1719),g=r(7881),f=r(4321),y=r(3050),w=r(3646),v=r(827),b=r(9502),C=r(3961),$=r(7552),R=r(6934),P=r(5148),G=r(2061),S=r(5432),H=r(4241),U=r(3105),D=r(4336),q=r(6004),F=r(3700),E=r(7469),M=r(9701),A=r(6700);async function x(t){try{const t=n.extensions.getExtension("ms-vscode.remote-repositories")??n.extensions.getExtension("GitHub.remotehub");if(null==t)throw D.Yd.log("GitHub Repositories extension is not installed or enabled"),new a.R5("GitHub Repositories","GitHub.remotehub");return t.isActive?t.exports:await t.activate()}catch(e){if(D.Yd.error(e,"Unable to get required api from the GitHub Repositories extension"),a.R5,t)return;throw e}}var k=(t=>(t[t.Branch=0]="Branch",t[t.RemoteBranch=1]="RemoteBranch",t[t.Tag=2]="Tag",t[t.Commit=3]="Commit",t))(k||{}),T=r(3878),_=Object.defineProperty,I=Object.getOwnPropertyDescriptor,B=(t,e,r,n)=>{for(var i,o=n>1?void 0:n?I(e,r):e,s=t.length-1;s>=0;s--)(i=t[s])&&(o=(n?i(e,r,o):i(o))||o);return n&&o&&_(e,r,o),o};const O=/"/g,j=Object.freeze([]),N=Object.freeze({values:[]}),L=Promise.resolve(void 0),Y=["repo","read:user","user:email"],V=/^[^/](?!.*\/\.)(?!.*\.\.)(?!.*\/\/)(?!.*@\{)[^\000-\037\177 ~^:?*[\\]+[^./]$/;class GitHubGitProvider{constructor(t){this.container=t,this._disposables.push(this.container.events.on("git:cache:reset",(t=>t.data.repoPath?this.resetCache(t.data.repoPath,...t.data.caches??j):this.resetCaches(...t.data.caches??j)),n.authentication.onDidChangeSessions(this.onAuthenticationSessionsChanged,this)))}descriptor={id:"github",name:"GitHub",virtual:!0};supportedSchemes=new Set([o.sN.Virtual,o.sN.GitHub,o.sN.PRs]);_onDidChange=new n.EventEmitter;get onDidChange(){return this._onDidChange.event}_onDidChangeRepository=new n.EventEmitter;get onDidChangeRepository(){return this._onDidChangeRepository.event}_onDidCloseRepository=new n.EventEmitter;get onDidCloseRepository(){return this._onDidCloseRepository.event}_onDidOpenRepository=new n.EventEmitter;get onDidOpenRepository(){return this._onDidOpenRepository.event}_branchesCache=new Map;_repoInfoCache=new Map;_tagsCache=new Map;_disposables=[];dispose(){this._disposables.forEach((t=>{t.dispose()}))}onAuthenticationSessionsChanged(t){"github"===t.provider.id&&(this._sessionPromise=void 0,this.ensureSession(!1,!0))}onRepositoryChanged(t,e){this._branchesCache.delete(t.path),this._tagsCache.delete(t.path),this._repoInfoCache.delete(t.path),this._onDidChangeRepository.fire(e)}async discoverRepositories(t,e){if(!this.supportedSchemes.has(t.scheme))return[];try{const{remotehub:r}=await this.ensureRepositoryContext(t.toString(),!0),n=r.getVirtualWorkspaceUri(t);return null==n?[]:this.openRepository(void 0,n,!0,void 0,e?.silent)}catch(e){return e.message.startsWith("No provider registered with")&&(D.Yd.error(e,"No GitHub provider registered with Remote Repositories (yet); queuing pending discovery"),this._pendingDiscovery.add(t),this.ensurePendingRepositoryDiscovery()),[]}}_pendingDiscovery=new Set;_pendingTimer;ensurePendingRepositoryDiscovery(){null==this._pendingTimer&&0!==this._pendingDiscovery.size&&(this._pendingTimer=setTimeout((async()=>{try{const t=await x();for(const e of this._pendingDiscovery){if(null==t.getProvider(e))return this._pendingTimer=void 0,void this.ensurePendingRepositoryDiscovery();this._pendingDiscovery.delete(e)}this._pendingTimer=void 0,setTimeout((()=>this._onDidChange.fire()),1),0!==this._pendingDiscovery.size&&this.ensurePendingRepositoryDiscovery()}catch{this._pendingTimer=void 0,this.ensurePendingRepositoryDiscovery()}}),250))}updateContext(){(0,G.v)("gitlens:hasVirtualFolders",this.container.git.hasOpenRepositories(this.descriptor.id))}openRepository(t,e,r,i,o){return[new w._j(this.container,this.onRepositoryChanged.bind(this),this.descriptor,t??n.workspace.getWorkspaceFolder(e),e,r,i??!n.window.state.focused,o)]}async supports(t){switch(t){case u.A.Stashes:case u.A.Worktrees:case u.A.StashOnlyStaged:return!1;default:return!0}}async visibility(t){const e=await this.getRemotes(t,{sort:!0});if(0===e.length)return["local",void 0];for await(const t of(0,E.rX)(e.map((t=>this.getRemoteVisibility(t)))))if("fulfilled"===t.status&&"public"===t.value[0])return["public",(0,y.Ym)(t.value[1])];return["private",(0,y.Ym)(e)]}async getRemoteVisibility(t){if("github"===t.provider?.id){const{github:e,metadata:r,session:n}=await this.ensureRepositoryContext(t.repoPath);return[await e.getRepositoryVisibility(n.accessToken,r.repo.owner,r.repo.name)??"private",t]}return["private",t]}async getOpenScmRepositories(){return[]}async getScmRepository(t){}async getOrOpenScmRepository(t){}canHandlePathOrUri(t,e){if(this.supportedSchemes.has(t))return"string"==typeof e?e:e.toString()}getAbsoluteUri(t,e){if("string"==typeof e){if(!(0,F.tE)(e))throw n.window.showErrorMessage(`Unable to get absolute uri between ${"string"==typeof t?t:t.toString(!0)} and ${e}; Base path '${e}' must be a uri`),new Error(`Base path '${e}' must be a uri`);e=n.Uri.parse(e,!0)}if("string"==typeof t&&!(0,F.tE)(t)){const r=(0,F.AH)(t);if(!(0,F.YP)(r))return n.Uri.joinPath(e,r)}const r=this.getRelativePath(t,e);return n.Uri.joinPath(e,r)}async getBestRevisionUri(t,e,r){return r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e)}getRelativePath(t,e){if("string"==typeof e){if(!(0,F.tE)(e))throw n.window.showErrorMessage(`Unable to get relative path between ${"string"==typeof t?t:t.toString(!0)} and ${e}; Base path '${e}' must be a uri`),new Error(`Base path '${e}' must be a uri`);e=n.Uri.parse(e,!0)}let r;if("string"==typeof t){if(!(0,F.tE)(t))return t=(0,F.AH)(t),r=(0,F.YP)(t)&&t.startsWith(e.path)?t.slice(e.path.length):t,r.charCodeAt(0)===o.mN.Slash&&(r=r.slice(1)),r;t=n.Uri.parse(t,!0)}return r=(0,F.AH)((0,F.Gf)(e.path.slice(1),t.path.slice(1))),r}getRevisionUri(t,e,r){const n=this.createProviderUri(t,r,e);return r===m.Ii?n.with({query:"~"}):n}async getWorkingUri(t,e){return this.createVirtualUri(t,void 0,e.path)}async addRemote(t,e,r,n){}async pruneRemote(t,e){}async removeRemote(t,e){}async applyChangesToWorkingFile(t,e,r){}async branchContainsCommit(t,e,r){return!1}async checkout(t,e,r){}resetCache(t,...e){(0===e.length||e.includes("branches"))&&this._branchesCache.delete(t),(0===e.length||e.includes("tags"))&&this._tagsCache.delete(t),0===e.length&&this._repoInfoCache.delete(t)}resetCaches(...t){(0===t.length||t.includes("branches"))&&this._branchesCache.clear(),(0===t.length||t.includes("tags"))&&this._tagsCache.clear(),0===t.length&&this._repoInfoCache.clear()}async excludeIgnoredUris(t,e){return e}async fetch(t,e){}async pull(t,e){}async push(t,e){}async findRepositoryUri(t,e){const r=(0,q.UH)();try{const e=await this.ensureRemoteHubApi();return e.getProviderRootUri(t).with({scheme:o.sN.Virtual})}catch(t){return a.R5,void D.Yd.error(t,r)}}async getAheadBehindCommitCount(t,e,r){}async getBlame(t,e){const r=(0,q.UH)();if(e?.isDirty)return;let n="blame";null!=t.sha&&(n+=`:${t.sha}`);const i=await this.container.tracker.getOrAdd(t);if(null!=i.state){const t=i.state.getBlame(n);if(null!=t)return D.Yd.debug(r,`Cache hit: '${n}'`),t.item}D.Yd.debug(r,`Cache miss: '${n}'`),null==i.state&&(i.state=new A.p);const o=this.getBlameCore(t,i,n,r);if(null!=i.state){D.Yd.debug(r,`Cache add: '${n}'`);const t={item:o};i.state.setBlame(n,t)}return o}async getBlameCore(t,e,r,i){try{const e=await this.ensureRepositoryContext(t.repoPath);if(null==e)return;const{metadata:r,github:i,remotehub:s,session:a}=e,u=s.getVirtualUri(s.getProviderRootUri(t)),l=this.getRelativePath(t,u);if(t.scheme===o.sN.Virtual){const[e,r]=await Promise.allSettled([n.workspace.fs.stat(t),n.workspace.fs.stat(t.with({scheme:o.sN.GitHub}))]);if("fulfilled"!==e.status||"fulfilled"!==r.status||e.value.mtime!==r.value.mtime)return}const c=t.sha&&"HEAD"!==t.sha?t.sha:(await r.getRevision()).revision,h=await i.getBlame(a.accessToken,r.repo.owner,r.repo.name,c,l),m=new Map,p=new Map,f=[];for(const e of h.ranges){const r=e.commit,{viewer:n=a.account.label}=h,i=null!=n&&r.author.name===n?"You":r.author.name,o=null!=n&&r.committer.name===n?"You":r.committer.name;let s=m.get(i);null==s&&(s={name:i,lineCount:0},m.set(i,s)),s.lineCount+=e.endingLine-e.startingLine+1;let c=p.get(r.oid);null==c&&(c=new d.aM(this.container,t.repoPath,r.oid,new d._j(i,r.author.email,new Date(r.author.date),r.author.avatarUrl),new d._j(o,r.committer.email,new Date(r.author.date)),r.message.split("\n",1)[0],r.parents.nodes[0]?.oid?[r.parents.nodes[0]?.oid]:[],r.message,new g.K8(u.toString(),l,g.NV.Modified),{changedFiles:r.changedFiles??0,additions:r.additions??0,deletions:r.deletions??0},[]),p.set(r.oid,c));for(let t=e.startingLine;t<=e.endingLine;t++){const e={sha:r.oid,originalLine:t,line:t};c.lines.push(e),f[t-1]=e}}const y=new Map([...m.entries()].sort(((t,e)=>e[1].lineCount-t[1].lineCount)));return{repoPath:t.repoPath,authors:y,commits:p,lines:f}}catch(t){if(null!=e.state&&!String(t).includes("No provider registered with")){const n=t?.toString()??"";D.Yd.debug(i,`Cache replace (with empty promise): '${r}'`);const o={item:L,errorMessage:n};return e.state.setBlame(r,o),e.setBlameFailure(t),L}return}}async getBlameContents(t,e){}async getBlameForLine(t,e,r,n){const i=(0,q.UH)();if(!r?.isDirty){if(!n?.forceSingleLine){const r=await this.getBlame(t);if(null==r)return;let n=r.lines[e];if(null==n){if(r.lines.length!==e)return;n=r.lines[e-1]}const i=r.commits.get(n.sha);if(null==i)return;return{author:{...r.authors.get(i.author.name),lineCount:i.lines.length},commit:i,line:n}}try{const r=await this.ensureRepositoryContext(t.repoPath);if(null==r)return;const{metadata:n,github:i,remotehub:o,session:s}=r,a=o.getVirtualUri(o.getProviderRootUri(t)),u=this.getRelativePath(t,a),l=t.sha&&"HEAD"!==t.sha?t.sha:(await n.getRevision()).revision,c=await i.getBlame(s.accessToken,n.repo.owner,n.repo.name,l,u),h=e+1,m=c.ranges.find((t=>t.startingLine===h));if(null==m)return;const p=m.commit,{viewer:f=s.account.label}=c,y=null!=f&&p.author.name===f?"You":p.author.name,w=null!=f&&p.committer.name===f?"You":p.committer.name,v=new d.aM(this.container,t.repoPath,p.oid,new d._j(y,p.author.email,new Date(p.author.date),p.author.avatarUrl),new d._j(w,p.committer.email,new Date(p.author.date)),p.message.split("\n",1)[0],p.parents.nodes[0]?.oid?[p.parents.nodes[0]?.oid]:[],p.message,new g.K8(a.toString(),u,g.NV.Modified),{changedFiles:p.changedFiles??0,additions:p.additions??0,deletions:p.deletions??0},[]);for(let t=m.startingLine;t<=m.endingLine;t++){const e={sha:p.oid,originalLine:t,line:t};v.lines.push(e)}return{author:{name:y,lineCount:m.endingLine-m.startingLine+1},commit:v,line:{sha:p.oid,originalLine:m.startingLine,line:m.startingLine}}}catch(t){return void D.Yd.error(i,t)}}}async getBlameForLineContents(t,e,r,n){}async getBlameForRange(t,e){const r=await this.getBlame(t);if(null!=r)return this.getBlameRange(r,t,e)}async getBlameForRangeContents(t,e,r){const n=await this.getBlameContents(t,r);if(null!=n)return this.getBlameRange(n,t,e)}getBlameRange(t,e,r){if(0===t.lines.length)return{allLines:t.lines,...t};if(0===r.start.line&&r.end.line===t.lines.length-1)return{allLines:t.lines,...t};const n=t.lines.slice(r.start.line,r.end.line+1),i=new Set(n.map((t=>t.sha))),o=r.start.line+1,s=r.end.line+1,a=new Map,u=new Map;for(const e of t.commits.values()){if(!i.has(e.sha))continue;const t=e.with({lines:e.lines.filter((t=>t.line>=o&&t.line<=s))});u.set(e.sha,t);let r=a.get(t.author.name);null==r&&(r={name:t.author.name,lineCount:0},a.set(r.name,r)),r.lineCount+=t.lines.length}const l=new Map([...a.entries()].sort(((t,e)=>e[1].lineCount-t[1].lineCount)));return{repoPath:e.repoPath,authors:l,commits:u,lines:n,allLines:t.lines}}async getBranch(t){const{values:[e]}=await this.getBranches(t,{filter:t=>t.current});return e}async getBranches(t,e){if(null==t)return N;const r=(0,q.UH)();let n=e?.cursor?void 0:this._branchesCache.get(t);if(null==n){async function o(){try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=await r.getRevision(),s=0===o.type?o.name:void 0,a=[];let u=e?.cursor;const l=null==u;for(;;){const e=await n.getBranches(i.accessToken,r.repo.owner,r.repo.name,{cursor:u});for(const r of e.values){const e=new Date("author-date"===P.D.get("advanced.commitOrdering")?r.target.authoredDate:r.target.committedDate),n=r.target.oid;a.push(new h.XI(this.container,t,r.name,!1,r.name===s,e,n,{name:`origin/${r.name}`,missing:!1}),new h.XI(this.container,t,`origin/${r.name}`,!0,!1,e,n))}if(!e.paging?.more||!l)return{...e,values:a};u=e.paging.cursor}}catch(e){return D.Yd.error(e,r),this._branchesCache.delete(t),N}}n=o.call(this),null==e?.cursor&&this._branchesCache.set(t,n)}let i=await n;return null!=e?.filter&&(i={...i,values:i.values.filter(e.filter)}),null!=e?.sort&&(0,h.YF)(i.values,"boolean"==typeof e.sort?void 0:e.sort),i}async getChangedFilesCount(t,e){if(!e)return;const r=await this.getCommit(t,e);if(null==r?.stats)return;const{stats:n}=r,i=(0,d.By)(n.changedFiles);return{additions:n.additions,deletions:n.deletions,changedFiles:i}}async getCommit(t,e){if(null==t)return;const r=(0,q.UH)();try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=await n.getCommit(i.accessToken,r.repo.owner,r.repo.name,e);if(null==o)return;const{viewer:s=i.account.label}=o,a=null!=s&&o.author.name===s?"You":o.author.name,u=null!=s&&o.committer.name===s?"You":o.committer.name;return new d.aM(this.container,t,o.oid,new d._j(a,o.author.email,new Date(o.author.date),o.author.avatarUrl),new d._j(u,o.committer.email,new Date(o.committer.date)),o.message.split("\n",1)[0],o.parents.nodes.map((t=>t.oid)),o.message,o.files?.map((e=>new g.K8(t,e.filename??"",(0,T.fromCommitFileStatus)(e.status)??g.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0})))??[],{changedFiles:o.changedFiles??0,additions:o.additions??0,deletions:o.deletions??0},[])}catch(t){return void D.Yd.error(t,r)}}async getCommitBranches(t,e,r,n){if(null==t||null==n?.commitDate)return[];const i=(0,q.UH)();try{const{metadata:i,github:o,session:s}=await this.ensureRepositoryContext(t);let a;return a=r?await o.getCommitOnBranch(s.accessToken,i.repo.owner,i.repo.name,r,e,n?.commitDate):await o.getCommitBranches(s.accessToken,i.repo.owner,i.repo.name,e,n?.commitDate),a}catch(t){return D.Yd.error(t,i),[]}}async getCommitCount(t,e){if(null==t)return;const r=(0,q.UH)();try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t);return await n.getCommitCount(i?.accessToken,r.repo.owner,r.repo.name,e)}catch(t){return void D.Yd.error(t,r)}}async getCommitForFile(t,e,r){if(null==t)return;const n=(0,q.UH)();try{const{metadata:n,github:i,remotehub:o,session:s}=await this.ensureRepositoryContext(t),a=this.getRelativePath(e,o.getProviderRootUri(e)),u=r?.ref&&"HEAD"!==r.ref?r.ref:(await n.getRevision()).revision,l=await i.getCommitForFile(s.accessToken,n.repo.owner,n.repo.name,u,a);if(null==l)return;const{viewer:c=s.account.label}=l,h=null!=c&&l.author.name===c?"You":l.author.name,m=null!=c&&l.committer.name===c?"You":l.committer.name,p=l.files?.map((e=>new g.K8(t,e.filename??"",(0,T.fromCommitFileStatus)(e.status)??g.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),f=p?.find((t=>t.path===a));return new d.aM(this.container,t,l.oid,new d._j(h,l.author.email,new Date(l.author.date),l.author.avatarUrl),new d._j(m,l.committer.email,new Date(l.committer.date)),l.message.split("\n",1)[0],l.parents.nodes.map((t=>t.oid)),l.message,{file:f,files:p},{changedFiles:l.changedFiles??0,additions:l.additions??0,deletions:l.deletions??0},[])}catch(t){return void D.Yd.error(t,n)}}async getCommitsForGraph(t,e,r){const n=r?.limit??P.D.get("graph.defaultItemLimit")??5e3,i=P.D.get("graph.commitOrdering",void 0,"date"),o=P.D.get("graph.avatars",void 0,!0),[s,a,u,l,c,h]=await Promise.allSettled([this.getLog(t,{all:!0,ordering:i,limit:n}),this.getBranch(t),this.getBranches(t,{filter:t=>t.remote}),this.getRemotes(t),this.getTags(t),this.getCurrentUser(t)]),d=new Map,m=(0,E.Sb)(a),p=new Map,g=new Map;null!=m&&(p.set(m.name,m),null!=m.sha&&g.set(m.sha,[m.name]));const f=(0,E.Sb)(u)?.values;if(null!=f)for(const t of f){if(p.set(t.name,t),null==t.sha)continue;const e=g.get(t.sha);null==e?g.set(t.sha,[t.name]):e.push(t.name)}const y=new Set,w=(0,E.Sb)(l)[0],v=null!=w?new Map([[w.name,w]]):new Map,b=new Map,C=(0,E.Sb)(c)?.values;if(null!=C)for(const t of C){if(null==t.sha)continue;const e=b.get(t.sha);null==e?b.set(t.sha,[t.name]):e.push(t.name)}return this.getCommitsForGraphCore(t,e,(0,E.Sb)(s),m,p,g,w,v,b,(0,E.Sb)(h),d,y,{...r,useAvatars:o})}async getCommitsForGraphCore(t,e,r,n,i,o,a,u,l,c,m,p,g){const w={...g?.include,stats:!0},v=new Map;if(null==r)return{repoPath:t,avatars:m,ids:p,includes:w,branches:i,remotes:u,downstreams:v,rows:[]};const C=(r.pagedCommits?.()??r.commits)?.values();if(null==C)return{repoPath:t,avatars:m,ids:p,includes:w,branches:i,remotes:u,downstreams:v,rows:[]};const $=[];let R,P,G,S,H,D,q,F,E,A,x=!1,k=!1;const T=n.upstream?.name;for(const r of C){if(p.add(r.sha),x=r.sha===n.sha,x)if(G={webviewItem:`gitlens:branch${x?"+current":""}${null!=n?.upstream?"+tracking":""}`,webviewItemValue:{type:"branch",ref:(0,f.xB)(n.name,t,{id:n.id,refType:"branch",name:n.name,remote:!1,upstream:n.upstream})}},H=[{id:n.id,name:n.name,isCurrentHead:!0,context:(0,M.BH)(G),upstream:null!=n.upstream?{name:n.upstream.name,id:(0,h.Vx)(t,!0,n.upstream.name)}:void 0}],null!=n.upstream){if(F=(0,h.Vx)(t,!0,n.name),R=((g?.useAvatars?a.provider?.avatarUri:void 0)??(0,y.dM)(this.container,a,e))?.toString(!0),G={webviewItem:"gitlens:branch+remote",webviewItemValue:{type:"branch",ref:(0,f.xB)(n.name,t,{id:F,refType:"branch",name:n.name,remote:!0,upstream:{name:a.name,missing:!1}})}},D=[{id:F,name:n.name,owner:a.name,url:a.url,avatarUrl:R,context:(0,M.BH)(G),current:!0,hostingServiceType:a.provider?.id}],null!=T){let t=v.get(T);null==t&&(t=[],v.set(T,t)),t.push(n.name)}}else D=[];else{H=[],D=[];const n=o.get(r.sha);if(null!=n)for(const r of n)F=(0,h.Vx)(t,!0,r),P=(0,h.S3)(r),R=((g?.useAvatars?a.provider?.avatarUri:void 0)??(0,y.dM)(this.container,a,e))?.toString(!0),G={webviewItem:"gitlens:branch+remote",webviewItemValue:{type:"branch",ref:(0,f.xB)(r,t,{id:F,refType:"branch",name:r,remote:!0,upstream:{name:a.name,missing:!1}})}},D.push({id:F,name:P,owner:a.name,url:a.url,avatarUrl:R,context:(0,M.BH)(G),hostingServiceType:a.provider?.id})}q=[];const i=l.get(r.sha);if(null!=i)for(const e of i)A=(0,b.YU)(t,e),G={webviewItem:"gitlens:tag",webviewItemValue:{type:"tag",ref:(0,f.xB)(e,t,{id:A,refType:"tag",name:e})}},q.push({id:A,name:e,annotated:!0,context:(0,M.BH)(G)});if(r.author.email&&!m.has(r.author.email)){const t=r.getCachedAvatarUri();null!=t&&m.set(r.author.email,t.toString(!0))}k="You"===r.author.name,S={row:(0,M.BH)({webviewItem:`gitlens:commit${x?"+HEAD":""}+current`,webviewItemValue:{type:"commit",ref:(0,f.xB)(r.sha,t,{refType:"revision",message:r.message})}}),avatar:(0,M.BH)({webviewItem:"gitlens:contributor"+(k?"+current":""),webviewItemValue:{type:"contributor",repoPath:t,name:k&&null!=c?.name?c.name:r.author.name,email:r.author.email,current:k}})},$.push({sha:r.sha,parents:r.parents,author:r.author.name,email:r.author.email??"",date:r.committer.date.getTime(),message:(0,s.X)(r.message&&String(r.message).length?r.message:r.summary),type:r.parents.length>1?"merge-node":"commit-node",heads:H,remotes:D,tags:q,contexts:S}),null!=r.stats&&(null==E&&(E=new Map),E.set(r.sha,{files:(0,d.By)(r.stats.changedFiles),additions:r.stats.additions,deletions:r.stats.deletions}))}return"HEAD"===g?.ref?g.ref=(0,U.Ps)(r.commits.values())?.sha:null!=g?.ref&&(g.ref=void 0),{repoPath:t,avatars:m,ids:p,includes:w,branches:i,remotes:u,downstreams:v,rows:$,id:g?.ref,paging:{limit:r.limit,startingCursor:r.startingCursor,hasMore:r.hasMore},more:async s=>{const h=await(r.more?.(s));return this.getCommitsForGraphCore(t,e,h,n,i,o,a,u,l,c,m,p,g)}}}async getCommitTags(t,e,r){if(null==t||null==r?.commitDate)return[];const n=(0,q.UH)();try{const{metadata:n,github:i,session:o}=await this.ensureRepositoryContext(t);return await i.getCommitTags(o.accessToken,n.repo.owner,n.repo.name,e,r?.commitDate)}catch(t){return D.Yd.error(t,n),[]}}async getContributors(t,e){if(null==t)return[];const r=(0,q.UH)();try{const{metadata:e,github:r,session:n}=await this.ensureRepositoryContext(t),i=await r.getContributors(n.accessToken,e.repo.owner,e.repo.name),o=await this.getCurrentUser(t),s=[];for(const e of i)"User"===e.type&&s.push(new p.V(t,e.name,e.email,e.contributions,void 0,(0,C.o)(o,e.name,e.email,e.login),void 0,e.login,e.avatar_url,e.node_id));return s}catch(t){return D.Yd.error(t,r),[]}}async getCurrentUser(t){if(!t)return;const e=(0,q.UH)(),r=this._repoInfoCache.get(t);let n=r?.user;if(null!=n)return n;if(null!==n)try{const{metadata:e,github:i,session:o}=await this.ensureRepositoryContext(t);return n=await i.getCurrentUser(o.accessToken,e.repo.owner,e.repo.name),this._repoInfoCache.set(t,{...r,user:n??null}),n}catch(n){return D.Yd.error(n,e),void this._repoInfoCache.set(t,{...r,user:null})}}async getDefaultBranchName(t,e){if(null==t)return;const r=(0,q.UH)();try{const{metadata:e,github:r,session:n}=await this.ensureRepositoryContext(t);return await r.getDefaultBranchName(n.accessToken,e.repo.owner,e.repo.name)}catch(t){return void D.Yd.error(t,r)}}async getDiffForFile(t,e,r){}async getDiffForFileContents(t,e,r){}async getDiffForLine(t,e,r,n){}async getDiffStatus(t,e,r,n){}async getFileStatusForCommit(t,e,r){if(r===m.Ii||(0,f.l3)(r))return;const n=await this.getCommitForFile(t,e,{ref:r});return null!=n?n.findFile(e):void 0}async getLastFetchedTimestamp(t){}async getLog(t,e){if(null==t)return;const r=(0,q.UH)(),n=this.getPagingLimit(e?.limit);try{const{metadata:r,github:i,session:o}=await this.ensureRepositoryContext(t),s=e?.ref&&"HEAD"!==e.ref?e.ref:(await r.getRevision()).revision,a=await i.getCommits(o.accessToken,r.repo.owner,r.repo.name,s,{all:e?.all,authors:e?.authors,after:e?.cursor,limit:n,since:e?.since?new Date(e.since):void 0}),u=new Map,{viewer:l=o.account.label}=a;for(const e of a.values){const r=null!=l&&e.author.name===l?"You":e.author.name,n=null!=l&&e.committer.name===l?"You":e.committer.name;let i=u.get(e.oid);null==i&&(i=new d.aM(this.container,t,e.oid,new d._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new d._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,e.files?.map((e=>new g.K8(t,e.filename??"",(0,T.fromCommitFileStatus)(e.status)??g.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),u.set(e.oid,i))}const c={repoPath:t,commits:u,sha:s,range:void 0,count:u.size,limit:n,hasMore:a.paging?.more??!1,endingCursor:a.paging?.cursor,query:r=>this.getLog(t,{...e,limit:r})};return c.hasMore&&(c.more=this.getLogMoreFn(c,e)),c}catch(t){return void D.Yd.error(t,r)}}async getLogRefsOnly(t,e){const r=await this.getLog(t,e);if(null!=r)return new Set([...r.commits.values()].map((t=>t.ref)))}getLogMoreFn(t,e){return async r=>{const n=null!=r&&"object"==typeof r?r.until:void 0;let i="number"==typeof r?r:void 0;if(n&&(0,U.G)(t.commits.values(),(t=>t.ref===n)))return t;i=this.getPagingLimit(i);const o=await this.getLog(t.repoPath,{...e,limit:i,cursor:t.endingCursor});if(null==o)return{...t,hasMore:!1,more:void 0};const s=new Map([...t.commits,...o.commits]),a={repoPath:t.repoPath,commits:s,sha:t.sha,range:void 0,count:s.size,limit:null==n?(t.limit??0)+i:void 0,hasMore:null!=n||o.hasMore,startingCursor:(0,U.Z$)(t.commits)?.[0],endingCursor:o.endingCursor,pagedCommits:()=>{for(const e of t.commits.keys())o.commits.delete(e);return o.commits},query:t.query};return a.hasMore&&(a.more=this.getLogMoreFn(a,e)),a}}async getLogForFile(t,e,r){if(null==t)return;const n=(0,q.UH)(),i=this.getRelativePath(e,t);if(null!=t&&t===i)throw new Error(`File name cannot match the repository path; path=${i}`);(r={reverse:!1,...r}).renames=!1,r.all=!1;let o="log";null!=r.ref&&(o+=`:${r.ref}`),r.limit=this.getPagingLimit(r?.limit),r.limit&&(o+=`:n${r.limit}`),r.renames&&(o+=":follow"),r.reverse&&(o+=":reverse"),r.since&&(o+=`:since=${r.since}`),r.skip&&(o+=`:skip${r.skip}`),r.cursor&&(o+=`:cursor=${r.cursor}`);const s=await this.container.tracker.getOrAdd(c.YY.fromFile(i,t,r.ref));if(!r.force&&null==r.range){if(null!=s.state){const i=s.state.getLog(o);if(null!=i)return D.Yd.debug(n,`Cache hit: '${o}'`),i.item;if(null!=r.ref||null!=r.limit){const i=s.state.getLog(`log${r.renames?":follow":""}${r.reverse?":reverse":""}`);if(null!=i){if(null==r.ref)return D.Yd.debug(n,`Cache hit: ~'${o}'`),i.item;D.Yd.debug(n,`Cache ?: '${o}'`);let s=await i.item;if(null!=s&&!s.hasMore&&s.commits.has(r.ref)){D.Yd.debug(n,`Cache hit: '${o}'`);let i=!0,a=0;const u=new Map((0,U.DZ)(s.commits.entries(),(([t,e])=>{if(i){if(t!==r?.ref)return;i=!1}if(a++,!(null!=r?.limit&&a>r.limit))return[t,e]}))),l={...r};return s={...s,limit:r.limit,count:u.size,commits:u,query:r=>this.getLogForFile(t,e,{...l,limit:r})},s}}}}D.Yd.debug(n,`Cache miss: '${o}'`),null==s.state&&(s.state=new A.p)}const a=this.getLogForFileCore(t,i,s,o,n,r);if(null!=s.state&&null==r.range){D.Yd.debug(n,`Cache add: '${o}'`);const t={item:a};s.state.setLog(o,t)}return a}async getLogForFileCore(t,e,r,n,i,o){if(null==t)return;const s=this.getPagingLimit(o?.limit);try{const r=await this.ensureRepositoryContext(t);if(null==r)return;const{metadata:n,github:i,remotehub:a,session:u}=r,l=this.getAbsoluteUri(e,t),c=this.getRelativePath(l,a.getProviderRootUri(l)),h=o?.ref&&"HEAD"!==o.ref?o.ref:(await n.getRevision()).revision,m=await i.getCommits(u.accessToken,n.repo.owner,n.repo.name,h,{all:o?.all,after:o?.cursor,path:c,limit:s,since:o?.since?new Date(o.since):void 0}),p=new Map,{viewer:f=u.account.label}=m;for(const e of m.values){const r=null!=f&&e.author.name===f?"You":e.author.name,n=null!=f&&e.committer.name===f?"You":e.committer.name;let i=p.get(e.oid);if(null==i){const o=e.files?.map((e=>new g.K8(t,e.filename??"",(0,T.fromCommitFileStatus)(e.status)??g.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),s=(0,F.Mh)(c)?void 0:o?.find((t=>t.path===c))??new g.K8(t,c,g.NV.Modified,void 0,void 0,1===e.changedFiles?{additions:e.additions??0,deletions:e.deletions??0,changes:0}:void 0);i=new d.aM(this.container,t,e.oid,new d._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new d._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,{file:s,files:o},{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),p.set(e.oid,i)}}const y={repoPath:t,commits:p,sha:h,range:void 0,count:p.size,limit:s,hasMore:m.paging?.more??!1,endingCursor:m.paging?.cursor,query:r=>this.getLogForFile(t,e,{...o,limit:r})};return y.hasMore&&(y.more=this.getLogForFileMoreFn(y,e,o)),y}catch(t){if(null!=r.state&&null==o?.range&&!o?.reverse){const e=t?.toString()??"";D.Yd.debug(i,`Cache replace (with empty promise): '${n}'`);const o={item:L,errorMessage:e};return r.state.setLog(n,o),L}return}}getLogForFileMoreFn(t,e,r){return async n=>{const i=null!=n&&"object"==typeof n?n.until:void 0;let o="number"==typeof n?n:void 0;if(i&&(0,U.G)(t.commits.values(),(t=>t.ref===i)))return t;o=this.getPagingLimit(o);const s=await this.getLogForFile(t.repoPath,e,{...r,limit:null==i?o:0,cursor:t.endingCursor});if(null==s)return{...t,hasMore:!1,more:void 0};const a=new Map([...t.commits,...s.commits]),u={repoPath:t.repoPath,commits:a,sha:t.sha,range:t.range,count:a.size,limit:null==i?(t.limit??0)+o:void 0,hasMore:null!=i||s.hasMore,endingCursor:s.endingCursor,query:t.query};return u.hasMore&&(u.more=this.getLogForFileMoreFn(u,e,r)),u}}async getMergeBase(t,e,r,n){}async getMergeStatus(t){}async getRebaseStatus(t){}async getNextComparisonUris(t,e,r,n=0){if(!r)return;const i=(0,q.UH)();try{const i=await this.ensureRepositoryContext(t);if(null==i)return;const{metadata:o,github:s,remotehub:a,session:u}=i,l=this.getRelativePath(e,a.getProviderRootUri(e)),h=(await o.getRevision()).revision;"HEAD"===r&&(r=h);const d=await s.getNextCommitRefs(u.accessToken,o.repo.owner,o.repo.name,h,l,r);return{current:0===n?c.YY.fromFile(l,t,r):new c.YY(await this.getBestRevisionUri(t,l,d[n-1])),next:new c.YY(await this.getBestRevisionUri(t,l,d[n]))}}catch(t){throw D.Yd.error(t,i),t}}async getOldestUnpushedRefForFile(t,e){}async getPreviousComparisonUris(t,e,r,n=0){if(r===m.Ii)return;const i=(0,q.UH)();r===m.CL&&(r=void 0);try{const i=await this.ensureRepositoryContext(t);if(null==i)return;const{metadata:o,github:s,remotehub:a,session:u}=i,l=this.getRelativePath(e,a.getProviderRootUri(e)),h=null!=r?1:0,d=await s.getCommitRefs(u.accessToken,o.repo.owner,o.repo.name,r&&"HEAD"!==r?r:(await o.getRevision()).revision,{path:l,first:h+n+1});if(null==d)return;const p=0===n?c.YY.fromFile(l,t,r):new c.YY(await this.getBestRevisionUri(t,l,d.values[h+n-1]?.oid??m.Ii));if(null==p||p.sha===m.Ii)return;return{current:p,previous:new c.YY(await this.getBestRevisionUri(t,l,d.values[h+n]?.oid??m.Ii))}}catch(t){throw D.Yd.error(t,i),t}}async getPreviousComparisonUrisForLine(t,e,r,n,i=0){if(n===m.Ii)return;const o=(0,q.UH)();try{const o=await this.ensureRepositoryContext(t);if(null==o)return;const{remotehub:s}=o;let a,u=this.getRelativePath(e,s.getProviderRootUri(e)),l=c.YY.fromFile(u,t,n),h=r,d=r,m=r;for(let e=0;e<Math.max(0,i)+2;e++){const e=await this.getBlameForLine(a??l,m,void 0,{forceSingleLine:!0});if(null==e)break;n=e.commit.sha,u=e.commit.file?.path??e.commit.file?.originalPath??u,m=e.line.originalLine-1;const r=c.YY.fromFile(u,t,n);null==a?(a=r,d=m):(l=a,h=d,a=r,d=m)}if(null==l)return;return{current:l,previous:a,line:(h??r)+1}}catch(t){throw D.Yd.error(t,o),t}}async getIncomingActivity(t,e){}async getRemotes(t,e){if(null==t)return[];const r=(0,$.v)(P.D.get("remotes",null)),i=n.Uri.parse(t,!0),[,o,s]=i.path.split("/",3),a=`https://github.com/${o}/${s}.git`,u="github.com",l=`${o}/${s}`;return[new y.ss(t,"origin","https",u,l,(0,$.B)(this.container,r)(a,u,l),[{type:"fetch",url:a},{type:"push",url:a}])]}async getRevisionContent(t,e,r){const i=r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e);return n.workspace.fs.readFile(i)}async getStash(t){}async getStatusForFile(t,e){}async getStatusForFiles(t,e){}async getStatusForRepo(t){if(null==t)return;const e=await this.ensureRepositoryContext(t);if(null==e)return;const r=await e.metadata.getRevision();return null!=r?new v.Hk(t,r.name,r.revision,[],{ahead:0,behind:0},r.type===k.Branch||r.type===k.RemoteBranch?`origin/${r.name}`:void 0):void 0}async getTags(t,e){if(null==t)return N;const r=(0,q.UH)();let n=e?.cursor?void 0:this._tagsCache.get(t);if(null==n){async function o(){try{const{metadata:r,github:n,session:i}=await this.ensureRepositoryContext(t),o=[];let s=e?.cursor;const a=null==s;let u,l;for(;;){const e=await n.getTags(i.accessToken,r.repo.owner,r.repo.name,{cursor:s});for(const r of e.values)u=r.target.authoredDate??r.target.target?.authoredDate??r.target.tagger?.date,l=r.target.committedDate??r.target.target?.committedDate??r.target.tagger?.date,o.push(new b.gE(t,r.name,r.target.target?.oid??r.target.oid,r.target.message??r.target.target?.message??"",null!=u?new Date(u):void 0,null!=l?new Date(l):void 0));if(!e.paging?.more||!a)return{...e,values:o};s=e.paging.cursor}}catch(e){return D.Yd.error(e,r),this._tagsCache.delete(t),N}}n=o.call(this),null==e?.cursor&&this._tagsCache.set(t,n)}let i=await n;return null!=e?.filter&&(i={...i,values:i.values.filter(e.filter)}),null!=e?.sort&&(0,b.Pj)(i.values,"boolean"==typeof e.sort?void 0:e.sort),i}async getTreeEntryForRevision(t,e,r){if(null==t||!e)return;if("HEAD"===r){const e=await this.ensureRepositoryContext(t);if(null==e)return;const n=await e.metadata.getRevision();r=n?.revision}const i=r?this.createProviderUri(t,r,e):this.createVirtualUri(t,r,e),o=await n.workspace.fs.stat(i);return null!=o?{path:this.getRelativePath(i,t),commitSha:r,size:o.size,type:(o.type&n.FileType.Directory)===n.FileType.Directory?"tree":"blob"}:void 0}async getTreeForRevision(t,e){if(null==t)return[];if("HEAD"===e){const r=await this.ensureRepositoryContext(t);if(null==r)return[];const n=await r.metadata.getRevision();e=n?.revision}const r=e?this.createProviderUri(t,e):this.createVirtualUri(t,e),i=await n.workspace.fs.readDirectory(r);if(null==i)return[];const o=[];for(const[t,s]of i){const i=this.getAbsoluteUri(t,r);o.push({path:this.getRelativePath(t,i),commitSha:e,size:0,type:(s&n.FileType.Directory)===n.FileType.Directory?"tree":"blob"})}return[]}async hasBranchOrTag(t,e){const[{values:r},{values:n}]=await Promise.all([this.getBranches(t,{filter:e?.filter?.branches,sort:!1}),this.getTags(t,{filter:e?.filter?.tags,sort:!1})]);return 0!==r.length||0!==n.length}async hasCommitBeenPushed(t,e){return!0}isTrackable(t){return this.supportedSchemes.has(t.scheme)}async isTracked(t){if(!this.isTrackable(t)||null==this.container.git.getRepository(t))return!1;const e=t.with({scheme:o.sN.GitHub});return null!=await n.workspace.fs.stat(e)}async getDiffTool(t){}async openDiffTool(t,e,r){}async openDirectoryCompare(t,e,r,n){}async resolveReference(t,e,r,n){if(!e||e===m.Ii||null==r&&(0,f.D3)(e)||null!=r&&(0,f.l3)(e))return e;let i;if(null!=r)i=this.getRelativePath(r,t);else if(!(0,f.yo)(e)||e.endsWith("^3"))return e;const o=await this.ensureRepositoryContext(t);if(null==o)return e;const{metadata:s,github:a,session:u}=o,l=await a.resolveReference(u.accessToken,s.repo.owner,s.repo.name,e,i);return null!=l?l:i?m.Ii:e}async richSearchCommits(t,e,r){if(null==t)return;const n=(0,q.UH)(),i=(0,R.pD)(e),o=i.get("commit:");if(o?.size){const e=await this.getCommit(t,(0,U.Ps)(o));if(null==e)return;return{repoPath:t,commits:new Map([[e.sha,e]]),sha:e.sha,range:void 0,count:1,limit:1,hasMore:!1}}const s=await this.getQueryArgsFromSearchQuery(e,i,t);if(0===s.length)return;const a=this.getPagingLimit(r?.limit);try{const{metadata:n,github:i,session:o}=await this.ensureRepositoryContext(t),u=`repo:${n.repo.owner}/${n.repo.name}+${s.join("+").trim()}`,l=await i.searchCommits(o.accessToken,u,{cursor:r?.cursor,limit:a,sort:"date"===r?.ordering?"committer-date":"author-date"===r?.ordering?"author-date":void 0});if(null==l)return;const c=new Map,h=o.account.label;for(const e of l.values){const r=null!=h&&e.author.name===h?"You":e.author.name,n=null!=h&&e.committer.name===h?"You":e.committer.name;let i=c.get(e.oid);null==i&&(i=new d.aM(this.container,t,e.oid,new d._j(r,e.author.email,new Date(e.author.date),e.author.avatarUrl),new d._j(n,e.committer.email,new Date(e.committer.date)),e.message.split("\n",1)[0],e.parents.nodes.map((t=>t.oid)),e.message,e.files?.map((e=>new g.K8(t,e.filename??"",(0,T.fromCommitFileStatus)(e.status)??g.NV.Modified,e.previous_filename,void 0,{additions:e.additions??0,deletions:e.deletions??0,changes:e.changes??0}))),{changedFiles:e.changedFiles??0,additions:e.additions??0,deletions:e.deletions??0},[]),c.set(e.oid,i))}const m={repoPath:t,commits:c,sha:void 0,range:void 0,count:c.size,limit:a,hasMore:l.pageInfo?.hasNextPage??!1,endingCursor:l.pageInfo?.endCursor??void 0,query:e=>this.getLog(t,{...r,limit:e})};if(m.hasMore){let t=function(n){return async i=>{i=this.getPagingLimit(i);const o=await this.richSearchCommits(n.repoPath,e,{...r,limit:i,cursor:n.endingCursor});if(null==o)return{...n,hasMore:!1,more:void 0};const s=new Map([...n.commits,...o.commits]),a={repoPath:n.repoPath,commits:s,sha:n.sha,range:void 0,count:s.size,limit:(n.limit??0)+i,hasMore:o.hasMore,endingCursor:o.endingCursor,query:n.query};return a.hasMore&&(a.more=t.call(this,a)),a}};m.more=t.call(this,m)}return m}catch(t){return void D.Yd.error(t,n)}}async searchCommits(t,e,r){e={matchAll:!1,matchCase:!1,matchRegex:!0,...e};const n=(0,R.FL)(e);try{const i=new Map,o=(0,R.pD)(e),s=o.get("commit:");if(null!=s){const p=await Promise.allSettled([...(0,U.UI)(s,(e=>this.getCommit(t,e.replace(O,""))))]);let g=0;for(const f of p){const y=(0,E.Sb)(f);null!=y&&i.set(y.sha,{i:g++,date:Number("author-date"===r?.ordering?y.author.date:y.committer.date)})}return{repoPath:t,query:e,comparisonKey:n,results:i}}const a=await this.getQueryArgsFromSearchQuery(e,o,t);if(0===a.length)return{repoPath:t,query:e,comparisonKey:n,results:i};const{metadata:u,github:c,session:h}=await this.ensureRepositoryContext(t),d=`repo:${u.repo.owner}/${u.repo.name}+${a.join("+").trim()}`;async function m(o,s){if(r?.cancellation?.isCancellationRequested)return{repoPath:t,query:e,comparisonKey:n,results:i};o=this.getPagingLimit(o??P.D.get("advanced.maxSearchItems"));const a=await c.searchCommitShas(h.accessToken,d,{cursor:s,limit:o,sort:"date"===r?.ordering?"committer-date":"author-date"===r?.ordering?"author-date":void 0});if(null==a||r?.cancellation?.isCancellationRequested)return{repoPath:t,query:e,comparisonKey:n,results:i};for(const t of a.values)i.set(t.sha,{i:i.size,date:Number("author-date"===r?.ordering?t.authorDate:t.committerDate)});return s=a.pageInfo?.endCursor??void 0,{repoPath:t,query:e,comparisonKey:n,results:i,paging:a.pageInfo?.hasNextPage?{limit:o,hasMore:!0}:void 0,more:async t=>m.call(this,t,s)}}return m.call(this,r?.limit)}catch(w){if(w instanceof l.l0)throw w;throw new l.l0(w)}}async validateBranchOrTagName(t,e){return V.test(t)}async validateReference(t,e){return!0}async stageFile(t,e){}async stageDirectory(t,e){}async unstageFile(t,e){}async unstageDirectory(t,e){}async ensureRepositoryContext(t,e){let r=n.Uri.parse(t,!0);if(!/^github\+?/.test(r.authority))throw new a.kX(t,a.sh.NotAGitHubRepository);if(!e){const e=this.container.git.getRepository(r);if(null==e)throw new a.kX(t,a.sh.NotAGitHubRepository);r=e.uri}let i=this._remotehub;if(null==i)try{i=await this.ensureRemoteHubApi()}catch(e){throw a.R5,new a.kX(t,a.sh.RemoteHubApiNotFound,e)}const o=await(i?.getMetadata(r));if("github"!==o?.provider.id)throw new a.kX(t,a.sh.NotAGitHubRepository);let s,u;try{[s,u]=await Promise.all([this.ensureGitHub(),this.ensureSession()])}catch(e){if(e instanceof a._7)throw new a.kX(t,e.reason===a.Jx.UserDidNotConsent?a.sh.GitHubAuthenticationDenied:a.sh.GitHubAuthenticationNotFound,e);throw new a.kX(t)}if(null==s)throw new a.kX(t);return{github:s,metadata:o,remotehub:i,session:u}}_github;async ensureGitHub(){if(null==this._github){const t=await this.container.github;null!=t&&this._disposables.push(t.onDidReauthenticate((()=>{this.ensureSession(!0)}))),this._github=t}return this._github}_remotehub;_remotehubPromise;async ensureRemoteHubApi(t){if(null==this._remotehubPromise&&(this._remotehubPromise=x(),this._remotehubPromise.then((t=>this._remotehub=t),(()=>this._remotehub=void 0))),!t)return this._remotehubPromise;try{return await this._remotehubPromise}catch{return}}_sessionPromise;async ensureSession(t=!1,e=!1){if(t||null==this._sessionPromise){async function r(){let i=this.container.storage.get(`provider:authentication:skip:${this.descriptor.id}`,!1);try{if(t)return i=!1,this.container.storage.delete(`provider:authentication:skip:${this.descriptor.id}`),await n.authentication.getSession("github",Y,{forceNewSession:!0});if(!i&&!e)return await n.authentication.getSession("github",Y,{createIfNone:!0});const r=await n.authentication.getSession("github",Y,{createIfNone:!1,silent:e});if(null!=r)return r;throw new Error("User did not consent")}catch(o){if(o instanceof Error&&o.message.includes("User did not consent")){if(!e&&(await this.container.storage.store(`provider:authentication:skip:${this.descriptor.id}`,!0),!i))return t||queueMicrotask((async()=>{const t="Re-enable";await n.window.showInformationMessage("GitLens has been disabled. Authentication is required for GitLens to work with remote GitHub repositories.",t)===t&&this.ensureSession(!0)})),t=!1,r.call(this);throw new a._7("github",a.Jx.UserDidNotConsent)}throw D.Yd.error(o),new a._7("github",void 0,o)}}this._sessionPromise=r.call(this)}return this._sessionPromise}createVirtualUri(t,e,r){let i;if("string"==typeof e)e&&(i=(0,f.D3)(e)?{v:1,ref:{id:e,type:2}}:{v:1,ref:{id:e,type:4}});else switch(e?.refType){case"revision":case"stash":i={v:1,ref:{id:e.ref,type:2}};break;case"branch":case"tag":i={v:1,ref:{id:e.name,type:4}}}if("string"==typeof t&&(t=n.Uri.parse(t,!0)),r){let e=t.path;e.endsWith("/")&&(e=e.slice(0,-1)),r=`${e}/${(r=this.getRelativePath(r,t)).startsWith("/")?r.slice(0,-1):r}`}return t.with({scheme:o.sN.Virtual,authority:W("github",i),path:r??t.path})}createProviderUri(t,e,r){const n=this.createVirtualUri(t,e,r);return null==this._remotehub?n.scheme!==o.sN.Virtual?n:n.with({scheme:o.sN.GitHub}):this._remotehub.getProviderUri(n)}getPagingLimit(t){return 0===(t=Math.min(100,t??P.D.get("advanced.maxListItems")??100))&&(t=100),t}async resolveReferenceCore(t,e,r){if(null==r||"HEAD"===r){return(await e.getRevision()).revision}if((0,f.D3)(r))return r;if((0,f.yk)(r))return;const[n,i]=await Promise.allSettled([this.getBranches(t,{filter:t=>t.name===r}),this.getTags(t,{filter:t=>t.name===r})]);return r=(0,E.Sb)(n)?.values[0]?.sha??(0,E.Sb)(i)?.values[0]?.sha}async getQueryArgsFromSearchQuery(t,e,r){const n=[];for(const[i,o]of e.entries())switch(i){case"message:":n.push(...(0,U.UI)(o,(t=>t.replace(/ /g,"+"))));break;case"author:":{let e;o.has("@me")&&(e=await this.getCurrentUser(r));for(let r of o)if(r&&(r=r.replace(O,t.matchRegex?"\\b":""),r)){if("@me"===r){if(null==e?.username)continue;r=`@${e.username}`}r=r.replace(/ /g,"+"),r.startsWith("@")?n.push(`author:${r.slice(1)}`):r.includes("@")?n.push(`author-email:${r}`):n.push(`author-name:${r}`)}break}}return n}}function W(t,e){return`${t}${null!=e?`+${(0,i.e)(JSON.stringify(e))}`:""}`}B([(0,H.cM)()],GitHubGitProvider.prototype,"getBestRevisionUri",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getWorkingUri",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"addRemote",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"pruneRemote",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"removeRemote",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"applyChangesToWorkingFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"branchContainsCommit",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"checkout",1),B([(0,H.cM)({singleLine:!0})],GitHubGitProvider.prototype,"resetCache",1),B([(0,H.cM)({singleLine:!0})],GitHubGitProvider.prototype,"resetCaches",1),B([(0,H.cM)({args:{1:t=>t.length}})],GitHubGitProvider.prototype,"excludeIgnoredUris",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"fetch",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"pull",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"push",1),B([(0,S.H)(),(0,H.fF)()],GitHubGitProvider.prototype,"findRepositoryUri",1),B([(0,H.cM)({args:{1:t=>t.join(",")}})],GitHubGitProvider.prototype,"getAheadBehindCommitCount",1),B([(0,S.H)(((t,e)=>`${t.toString()}|${e?.isDirty}`)),(0,H.cM)({args:{1:t=>t?.isDirty}})],GitHubGitProvider.prototype,"getBlame",1),B([(0,H.cM)({args:{1:"<contents>"}})],GitHubGitProvider.prototype,"getBlameContents",1),B([(0,S.H)(((t,e,r,n)=>`${t.toString()}|${e}|${r?.isDirty}|${n?.forceSingleLine}`)),(0,H.cM)({args:{2:t=>t?.isDirty}})],GitHubGitProvider.prototype,"getBlameForLine",1),B([(0,H.cM)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForLineContents",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getBlameForRange",1),B([(0,H.cM)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForRangeContents",1),B([(0,H.cM)({args:{0:"<blame>"}})],GitHubGitProvider.prototype,"getBlameRange",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getBranch",1),B([(0,H.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getBranches",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getChangedFilesCount",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommit",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommitBranches",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommitCount",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommitForFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommitsForGraph",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getCommitTags",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getContributors",1),B([(0,S.H)(),(0,H.cM)()],GitHubGitProvider.prototype,"getCurrentUser",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getDefaultBranchName",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getDiffForFile",1),B([(0,H.cM)({args:{1:t=>"<contents>"}})],GitHubGitProvider.prototype,"getDiffForFileContents",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getDiffForLine",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getDiffStatus",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getFileStatusForCommit",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getLog",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getLogRefsOnly",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getLogForFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getMergeBase",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getMergeStatus",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getRebaseStatus",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getNextComparisonUris",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getOldestUnpushedRefForFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getPreviousComparisonUris",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getPreviousComparisonUrisForLine",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getIncomingActivity",1),B([(0,H.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getRemotes",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getRevisionContent",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getStash",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getStatusForFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getStatusForFiles",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getStatusForRepo",1),B([(0,H.cM)({args:{1:!1}})],GitHubGitProvider.prototype,"getTags",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getTreeEntryForRevision",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getTreeForRevision",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"hasBranchOrTag",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"hasCommitBeenPushed",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"getDiffTool",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"openDiffTool",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"openDirectoryCompare",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"resolveReference",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"richSearchCommits",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"searchCommits",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"validateBranchOrTagName",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"validateReference",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"stageFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"stageDirectory",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"unstageFile",1),B([(0,H.cM)()],GitHubGitProvider.prototype,"unstageDirectory",1),B([(0,S.H)()],GitHubGitProvider.prototype,"ensureRepositoryContext",1),B([(0,S.H)()],GitHubGitProvider.prototype,"ensureGitHub",1)},3878:(t,e,r)=>{r.r(e),r.d(e,{fromCommitFileStatus:()=>g,fromGitHubIssueDetailed:()=>p,fromGitHubPullRequest:()=>s,fromGitHubPullRequestDetailed:()=>m,fromGitHubPullRequestMergeableState:()=>h,fromGitHubPullRequestReviewDecision:()=>l,fromGitHubPullRequestState:()=>a,toGitHubPullRequestMergeableState:()=>d,toGitHubPullRequestReviewDecision:()=>c,toGitHubPullRequestState:()=>u});var n=r(7881),i=r(8452),o=r(4092);function s(t,e){return new o.i7(e,{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},String(t.number),t.id,t.title,t.permalink,a(t.state),new Date(t.updatedAt),null==t.closedAt?void 0:new Date(t.closedAt),null==t.mergedAt?void 0:new Date(t.mergedAt))}function a(t){return"MERGED"===t?"merged":"CLOSED"===t?"closed":"opened"}function u(t){return"merged"===t?"MERGED":"closed"===t?"CLOSED":"OPEN"}function l(t){switch(t){case"APPROVED":return o.pD.Approved;case"CHANGES_REQUESTED":return o.pD.ChangesRequested;case"REVIEW_REQUIRED":return o.pD.ReviewRequired}}function c(t){switch(t){case o.pD.Approved:return"APPROVED";case o.pD.ChangesRequested:return"CHANGES_REQUESTED";case o.pD.ReviewRequired:return"REVIEW_REQUIRED"}}function h(t){switch(t){case"MERGEABLE":return o.Cz.Mergeable;case"CONFLICTING":return o.Cz.Conflicting;case"UNKNOWN":return o.Cz.Unknown}}function d(t){switch(t){case o.Cz.Mergeable:return"MERGEABLE";case o.Cz.Conflicting:return"CONFLICTING";case o.Cz.Unknown:return"UNKNOWN"}}function m(t,e){return new o.i7(e,{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},String(t.number),t.id,t.title,t.permalink,a(t.state),new Date(t.updatedAt),null==t.closedAt?void 0:new Date(t.closedAt),null==t.mergedAt?void 0:new Date(t.mergedAt),h(t.mergeable),{head:{exists:null!=t.headRepository,owner:t.headRepository?.owner.login,repo:t.baseRepository?.name,sha:t.headRefOid,branch:t.headRefName,url:t.headRepository?.url},base:{exists:null!=t.baseRepository,owner:t.baseRepository?.owner.login,repo:t.baseRepository?.name,sha:t.baseRefOid,branch:t.baseRefName,url:t.baseRepository?.url},isCrossRepository:t.isCrossRepository},t.isDraft,t.additions,t.deletions,t.totalCommentsCount,l(t.reviewDecision),t.reviewRequests.nodes.map((t=>({isCodeOwner:t.asCodeOwner,reviewer:{name:t.requestedReviewer.login,avatarUrl:t.requestedReviewer.avatarUrl,url:t.requestedReviewer.url}}))),t.assignees.nodes.map((t=>({name:t.login,avatarUrl:t.avatarUrl,url:t.url}))))}function p(t,e){return new i.$9({id:e.id,name:e.name,domain:e.domain,icon:e.icon},String(t.number),t.id,t.title,t.url,new Date(t.createdAt),t.closed,a(t.state),new Date(t.updatedAt),{name:t.author.login,avatarUrl:t.author.avatarUrl,url:t.author.url},{owner:t.repository.owner.login,repo:t.repository.name},t.assignees.nodes.map((t=>({name:t.login,avatarUrl:t.avatarUrl,url:t.url}))),null==t.closedAt?void 0:new Date(t.closedAt),null==t.labels?.nodes?void 0:t.labels.nodes.map((t=>({color:t.color,name:t.name}))),t.comments?.totalCount,t.reactions?.totalCount)}function g(t){switch(t){case"added":return n.NV.Added;case"changed":case"modified":return n.NV.Modified;case"removed":return n.NV.Deleted;case"renamed":return n.NV.Renamed;case"copied":return n.NV.Copied}}},778:(t,e,r)=>{var n=r(2479);function i(t){var e=function(){return e.called?e.value:(e.called=!0,e.value=t.apply(this,arguments))};return e.called=!1,e}function o(t){var e=function(){if(e.called)throw new Error(e.onceError);return e.called=!0,e.value=t.apply(this,arguments)},r=t.name||"Function wrapped with `once`";return e.onceError=r+" shouldn't be called more than once",e.called=!1,e}t.exports=n(i),t.exports.strict=n(o),i.proto=i((function(){Object.defineProperty(Function.prototype,"once",{value:function(){return i(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return o(this)},configurable:!0})}))},2479:t=>{t.exports=function t(e,r){if(e&&r)return t(e)(r);if("function"!=typeof e)throw new TypeError("need wrapper function");return Object.keys(e).forEach((function(t){n[t]=e[t]})),n;function n(){for(var t=new Array(arguments.length),r=0;r<t.length;r++)t[r]=arguments[r];var n=e.apply(this,t),i=t[t.length-1];return"function"==typeof n&&n!==i&&Object.keys(i).forEach((function(t){n[t]=i[t]})),n}}}};