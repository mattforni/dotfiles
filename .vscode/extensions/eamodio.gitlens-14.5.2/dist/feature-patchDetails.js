exports.id=537,exports.ids=[537],exports.modules={9804:(e,t,i)=>{i.d(t,{PatchDetailsWebviewProvider:()=>PatchDetailsWebviewProvider});var s=i(9496),o=i(5255),n=i(6897),a=i(439),r=i(7881),c=i(4321),h=i(3646),d=i(847),l=i(2509);async function p(e,t){if(null==t)return;const i={label:"Create new branch",description:"Creates a branch to apply the Cloud Patch to. (Typing an existing branch name will use that branch.)"},o={label:"Select existing branch",description:"Selects an existing branch to apply the Cloud Patch to."},n=[i,o],a=s.window.createQuickPick();a.ignoreFocusOut=(0,l.hE)();const r=[];try{const c=await new Promise((t=>{r.push(a.onDidHide((()=>t(void 0))),a.onDidAccept((()=>{0!==a.activeItems.length&&t(a.activeItems[0])}))),a.title=e,a.placeholder="Select a branch option",a.matchOnDescription=!0,a.matchOnDetail=!0,a.items=n,a.show()}));return c===i?async function(e,t,i){const o=s.window.createInputBox();o.ignoreFocusOut=!0;const n=[];let a;try{a=await new Promise((i=>{n.push(o.onDidHide((()=>i(void 0))),o.onDidAccept((()=>{const e=o.value.trim();null!=e?i(e):o.validationMessage="Please enter a valid branch name"}))),o.title=e,o.placeholder=t,o.prompt="Enter a name for the new branch",o.show()}))}finally{o.dispose(),n.forEach((e=>{e.dispose()}))}return a}(e,"Enter a name for the new branch"):c===o?async function(e,t,i){if(null==i)return;const o=await(0,d.C_)(i,{});if(0===o.length)return;const n=s.window.createQuickPick();n.ignoreFocusOut=(0,l.hE)();const a=[];try{const i=await new Promise((i=>{a.push(n.onDidHide((()=>i(void 0))),n.onDidAccept((()=>{0!==n.activeItems.length&&i(n.activeItems[0])}))),n.title=e,n.placeholder=t,n.matchOnDescription=!0,n.matchOnDetail=!0,n.items=o,n.show()}));if(null==i)return;return i}finally{n.dispose(),a.forEach((e=>{e.dispose()}))}}(e,"Select an existing branch",t):void 0}finally{a.dispose(),r.forEach((e=>{e.dispose()}))}}var f=i(9529),u=i(5148),g=i(2061),y=i(4241),m=i(9796),w=i(3105),v=i(3700),C=i(7387),D=i(5798),x=i(9679),k=i(4435);const b=new D.ke("patch/apply"),_=new D.ke("patch/create"),P=new D.ke("patch/openInGraph"),S=new D.ke("patch/checked"),R=(new D.ke("patch/selectRepo"),new D.ke("patch/selectBase"),new D.ke("patch/file/actions"),new D.ke("patch/file/open")),F=(new D.ke("patch/file/openOnRemote"),new D.ke("patch/file/compareWorking")),E=new D.ke("patch/file/comparePrevious"),I=new D.ke("patch/explain"),W=new D.ke("patch/preferences/update"),M=new D.ke("patch/switchMode"),T=new D.ke("patch/cloud/copyLink"),O=(new D.ke("patch/local/createPatch"),new D.ke("patch/create/repository/check")),A=new D.ke("patch/update/create/metadata"),q=new D.jH("patch/didChange",!0),V=new D.jH("patch/create/didChange"),H=new D.jH("patch/draft/didChange"),U=new D.jH("patch/preferences/didChange"),$=new D.jH("patch/didExplain"),L=new D.jH("patch/draft/didChangeRepository");class RepositoryRefChangeset{constructor(e,t,i,s,o,n){this.container=e,this.repository=t,this.revision=i,this.files=s,this.checked=o,this.expanded=n}type="revision";dispose(){}suspend(){}resume(){}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._expanded=e)}async getChange(){return{type:"revision",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:this.files,checked:this.checked,expanded:this.expanded}}}class RepositoryWipChangeset{constructor(e,t,i,s,o,n){this.container=e,this.repository=t,this.revision=i,this.onDidChangeRepositoryWip=s,this.checked=o,this.expanded=n}type="wip";_disposable;dispose(){this._disposable?.dispose(),this._disposable=void 0}suspend(){this._disposable?.dispose(),this._disposable=void 0}resume(){this._files=void 0,this._expanded&&this.subscribe()}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._files=void 0,e?this.subscribe():(this._disposable?.dispose(),this._disposable=void 0),this._expanded=e)}_files;async getChange(){let e;return this.expanded&&(null==this._files&&(this._files=this.getFiles()),e=await this._files),{type:"wip",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:e?.files,checked:this.checked,expanded:this.expanded}}subscribe(){null==this._disposable&&(this._disposable=s.Disposable.from(this.repository.watchFileSystem(1e3),this.repository.onDidChangeFileSystem((()=>this.onDidChangeWip()),this),this.repository.onDidChange((e=>{e.changed(h.I6.Index,h.du.Any)&&this.onDidChangeWip()}))))}onDidChangeWip(){this._files=void 0,this.onDidChangeRepositoryWip(this)}async getFiles(){const e=await this.container.git.getStatusForRepo(this.repository.path),t=[];if(null!=e)for(const i of e.files){const e={repoPath:i.repoPath,path:i.path,status:i.status,originalPath:i.originalPath,staged:i.staged};t.push(e),i.staged&&i.wip&&t.push({...e,staged:!1})}return{files:t}}}var N=Object.defineProperty,j=Object.getOwnPropertyDescriptor;class PatchDetailsWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._context={mode:"create",draft:void 0,create:void 0,preferences:this.getPreferences()},this.setHostTitle(),this.host.description="PREVIEW ☁️",this._disposable=s.Disposable.from(u.D.onDidChangeAny(this.onAnyConfigurationChanged,this),e.git.onDidChangeRepositories(this.onRepositoriesChanged,this))}_context;_disposable;dispose(){this._disposable.dispose()}canReuseInstance(...e){const[t]=e;if("view"===t?.mode&&null!=t.draft)switch(t.draft.draftType){case"cloud":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.id===t.draft.id;case"local":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.patch.contents===t.draft.patch?.contents}return!1}async onShowing(e,t,...i){const[s]=i;if("view"===s?.mode&&null!=s.draft)this.updateViewDraftState(s.draft);else{this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;const e="create"===s?.mode&&null!=s.create?s.create:{repositories:void 0};this.updateCreateDraftState(e)}return!(t?.preserveVisibility&&!this.host.visible)}includeBootstrap(){return this.getState(this._context)}registerCommands(){return this.host.isView()?[(0,f.xR)(`${this.host.id}.refresh`,(()=>this.host.refresh(!0))),(0,f.xR)(`${this.host.id}.close`,(()=>this.closeView()))]:[]}onMessageReceived(e){switch(e.method){case b.method:(0,D.mq)(b,e,(e=>this.applyPatch(e)));break;case T.method:(0,D.mq)(T,e,(()=>this.copyCloudLink()));break;case _.method:(0,D.mq)(_,e,(e=>this.createDraft(e)));break;case I.method:(0,D.mq)(I,e,(()=>this.explainPatch(e.completionId)));break;case E.method:(0,D.mq)(E,e,(e=>{this.openFileComparisonWithPrevious(e)}));break;case F.method:(0,D.mq)(F,e,(e=>{this.openFileComparisonWithWorking(e)}));break;case R.method:(0,D.mq)(R,e,(e=>{this.openFile(e)}));break;case P.method:(0,D.mq)(P,e,(e=>{(0,f.P0)(o.Gh.ShowInCommitGraph,{ref:(0,c.xB)(e.ref,e.repoPath,{refType:"revision"})})}));break;case M.method:(0,D.mq)(M,e,(e=>this.switchMode(e)));break;case A.method:(0,D.mq)(A,e,(e=>this.updateCreateMetadata(e)));break;case O.method:(0,D.mq)(O,e,(e=>this.updateCreateCheckedState(e)));break;case W.method:(0,D.mq)(W,e,(e=>this.updatePreferences(e)));break;case S.method:(0,D.mq)(S,e,(e=>this.onPatchChecked(e)))}}onRefresh(){this.updateState(!0)}onReloaded(){this.updateState(!0)}onVisibilityChanged(e){this._context.create?.changes.forEach((t=>e?t.resume():t.suspend())),e&&this.host.sendPendingIpcNotifications()}onAnyConfigurationChanged(e){(u.D.changed(e,["defaultDateFormat","views.patchDetails.files","views.patchDetails.avatars"])||u.D.changedAny(e,"workbench.tree.renderIndentGuides")||u.D.changedAny(e,"workbench.tree.indent"))&&(this._context.preferences={...this._context.preferences,...this.getPreferences()},this.updateState())}getPreferences(){return{avatars:u.D.get("views.patchDetails.avatars"),dateFormat:u.D.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:u.D.get("views.patchDetails.files"),indentGuides:u.D.getAny("workbench.tree.renderIndentGuides")??"onHover",indent:u.D.getAny("workbench.tree.indent")}}onRepositoriesChanged(e){if("create"===this.mode&&null!=this._context.create){if(this._context.create?.showingAllRepos)for(const t of e.added)this._context.create.changes.set(t.uri.toString(),new RepositoryWipChangeset(this.container,t,{to:a.CL,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!1,!0));for(const t of e.removed)this._context.create.changes.delete(t.uri.toString());this.notifyDidChangeCreateDraftState()}}onRepositoryWipChanged(e){this.notifyDidChangeCreateDraftState()}get mode(){return this._context.mode}setMode(e,t){this._context.mode=e,this.setHostTitle(e),(0,g.v)("gitlens:views:patchDetails:mode","editor"===u.D.get("cloudPatches.experimental.layout")?void 0:e),t||this.updateState(!0)}setHostTitle(e=this._context.mode){this.host.title="create"===e?"Create Cloud Patch":"Cloud Patch Details"}async applyPatch(e){if(null==this._context.draft||"local"===this._context.draft.draftType||!e.selected?.length)return;const t=this._context.draft.changesets?.[0];if(null==t)return;const i="branch"===e.target;for(const n of t.patches)if(e.selected.includes(n.id))try{console.log(n);let e,t=n.commit;if(t||(t=await this.getOrCreateCommitForPatch(n.gkRepositoryId)),!t)continue;if(i){const i=t.getRepository(),a=await p(`Choose a Branch ${o.NE.Dot} ${i?.name}`,i);if(null==a){s.window.showErrorMessage(`Unable apply patch to '${n.repository.name}': No branch selected`);continue}const r="string"==typeof a;e={branchName:r?a:a.ref,createBranchIfNeeded:r}}this.container.git.applyPatchCommit(t.repoPath,t.ref,e)}catch(e){s.window.showErrorMessage(`Unable apply patch to '${n.baseRef}': ${e.message}`)}}closeView(){(0,g.v)("gitlens:views:patchDetails:mode",void 0)}copyCloudLink(){"cloud"===this._context.draft?.draftType&&s.env.clipboard.writeText(this._context.draft.deepLinkUrl)}async createDraft({title:e,changesets:t,description:i}){if(!await(0,k.wz)("Cloud Patches require a GitKraken account.",this.container)||!await(0,k.FQ)(this.container))return;const o=[],n=Object.entries(t),r=1===n.length;for(const[c,h]of n){if(!r&&!1===h.checked)continue;const d=this._context.create?.changes?.get(c);if(null==d)continue;let{revision:l,repository:p}=d;"wip"===h.type&&"staged"===h.checked&&(l={...l,to:a.pw}),o.push({repository:p,revision:l})}if(null!=o)try{const f=await this.container.drafts.createDraft("patch",e,o,i?{description:i}:void 0);async function u(){const e={title:"View Patch"},t={title:"Copy Link"};let i=!1;for(;;){const o=await s.window.showInformationMessage("Cloud Patch successfully created"+(i?"— link copied to the clipboard":""),e,t);if(o!==t){o===e&&(0,x.l)({mode:"view",draft:f});break}s.env.clipboard.writeText(f.deepLinkUrl),i=!0}}u(),this.container.draftsView.refresh(!0).then((()=>{this.container.draftsView.revealDraft(f)})),this.closeView()}catch(g){s.window.showErrorMessage(`Unable to create draft: ${g.message}`)}}async explainPatch(e){if("cloud"!==this._context.draft?.draftType)return;let t;try{const e=await this.getDraftPatch(this._context.draft);if(null==e)throw new Error("Unable to find patch");const i=await this.getOrCreateCommitForPatch(e.gkRepositoryId);if(null==i)throw new Error("Unable to find commit");const s=await this.container.ai.explainCommit(i,{progress:{location:{viewId:this.host.id}}});if(null==s)throw new Error("Error retrieving content");t={summary:s}}catch(e){t={error:{message:e.message}}}this.host.notify($,t,e)}async openPatchContents(e){}async onPatchChecked(e){if(e.patch.repository.located||!1===e.checked)return;const t=this._context.draft?.changesets?.[0].patches?.find((t=>t.gkRepositoryId===e.patch.gkRepositoryId));if(null==t?.repository||(0,h.uC)(t.repository))return;const i=await this.container.repositoryIdentity.getRepository(t.repository,{openIfNeeded:!0,prompt:!0});null==i?s.window.showErrorMessage(`Unable to locate repository '${t.repository.name}'`):t.repository=i,this.notifyPatchRepositoryUpdated(t)}notifyPatchRepositoryUpdated(e){return this.host.notify(L,{patch:(0,C.q)({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:null!=e.repository&&(0,h.uC)(e.repository)}})})}updateCreateCheckedState(e){const t=this._context.create?.changes.get(e.repoUri);null!=t&&(t.checked=e.checked,this.notifyDidChangeCreateDraftState())}updateCreateMetadata(e){null!=this._context.create&&(this._context.create.title=e.title,this._context.create.description=e.description,this.notifyDidChangeCreateDraftState())}switchMode(e){this.setMode(e.mode)}_notifyDidChangeStateDebounced=void 0;updateState(e=!1){this.host.clearPendingIpcNotifications(),e?this.notifyDidChangeState():(null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,m.Ds)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced())}async getState(e){let t,i;"create"===e.mode&&null!=e.create&&(t=await this.getCreateDraftState(e)),"view"===e.mode&&null!=e.draft&&(i=await this.getViewDraftState(e));return(0,C.q)({...this.host.baseWebviewState,mode:e.mode,create:t,draft:i,preferences:e.preferences})}async notifyDidChangeState(){return this._notifyDidChangeStateDebounced?.cancel(),this.host.notify(q,{state:await this.getState(this._context)})}updateCreateDraftState(e){let t,i=!1;if(null!=e.changes){t=this._context.create?.changes??new Map;const i=new Set;for(const o of e.changes){const e=this.container.git.getRepository(s.Uri.parse(o.repository.uri));if(null==e)continue;let n;n="wip"===o.type?new RepositoryWipChangeset(this.container,e,o.revision,this.onRepositoryWipChanged.bind(this),o.checked??!0,o.expanded??!0):new RepositoryRefChangeset(this.container,e,o.revision,o.files,o.checked??!0,o.expanded??!0),i.add(e.uri.toString()),t.set(e.uri.toString(),n)}if(i.size!==t.size)for(const[e,s]of t)i.has(e)||(s.checked=!1)}else{i=null==e.repositories;const s=e.repositories??this.container.git.openRepositories;t=new Map(s.map((e=>[e.uri.toString(),new RepositoryWipChangeset(this.container,e,{to:a.CL,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!0,!0)])))}this._context.create={title:e.title,description:e.description,changes:t,showingAllRepos:i},this.setMode("create",!0),this.notifyDidChangeCreateDraftState()}async getCreateDraftState(e){const{create:t}=e;if(null==t)return;const i={};if(0!==t.changes.size)for(const[e,s]of t.changes){const t=await s.getChange();0!==t?.files?.length&&(t.checked!==s.checked&&(t.checked=s.checked),i[e]=t)}return{title:t.title,description:t.description,changes:i}}async notifyDidChangeCreateDraftState(){return this.host.notify(V,{mode:this._context.mode,create:await this.getCreateDraftState(this._context)})}updateViewDraftState(e){this._context.draft=e,this.setMode("view",!0),this.notifyDidChangeViewDraftState()}async getViewDraftState(e){if(null==e.draft)return;const t=e.draft;return"cloud"===t.draftType?((null==t.changesets||(0,w.G)(t.changesets,(e=>e.patches.some((e=>null==e.contents||null==e.files||null==e.repository)))))&&setTimeout((async()=>{null==t.changesets&&(t.changesets=await this.container.drafts.getChangesets(t.id));const e=t.changesets.flatMap((e=>e.patches)).filter((e=>null==e.contents||null==e.files||null==e.repository)),i=await Promise.allSettled(e.map((e=>this.container.drafts.getPatchDetails(e))));for(const t of i)if("fulfilled"===t.status){const i=e.find((e=>e.id===t.value.id));null!=i&&(i.contents=t.value.contents,i.files=t.value.files,i.repository=t.value.repository)}this.notifyDidChangeViewDraftState()}),0),{draftType:"cloud",id:t.id,createdAt:t.createdAt.getTime(),updatedAt:t.updatedAt.getTime(),author:t.author,title:t.title,description:t.description,patches:(0,C.q)(t.changesets[0].patches.map((e=>({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:null!=e.repository&&(0,h.uC)(e.repository)}}))))}):void 0}async notifyDidChangeViewDraftState(){return this.host.notify(H,{mode:this._context.mode,draft:(0,C.q)(await this.getViewDraftState(this._context))})}updatePreferences(e){this._context.preferences?.files?.compact===e.files?.compact&&this._context.preferences?.files?.icon===e.files?.icon&&this._context.preferences?.files?.layout===e.files?.layout&&this._context.preferences?.files?.threshold===e.files?.threshold||(null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&u.D.updateEffective("views.patchDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&u.D.updateEffective("views.patchDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&u.D.updateEffective("views.patchDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&u.D.updateEffective("views.patchDetails.files.threshold",e.files?.threshold),this._context.preferences.files=e.files),this.notifyDidChangePreferences())}async notifyDidChangePreferences(){return this.host.notify(U,{preferences:this._context.preferences})}async getDraftPatch(e,t){if(null==e.changesets){const t=await this.container.drafts.getChangesets(e.id);e.changesets=t}const i=null==t?e.changesets[0].patches?.[0]:e.changesets[0].patches?.find((e=>e.gkRepositoryId===t));if(null!=i){if(null==i.contents||null==i.files||null==i.repository){const e=await this.container.drafts.getPatchDetails(i.id);i.contents=e.contents,i.files=e.files,i.repository=e.repository}return i}}async getFileCommitFromParams(e){let[t,i]=await this.getOrCreateCommit(e);return null!=t&&null!=i?[t,new r.K8(e.repoPath,e.path,e.status,e.originalPath,void 0,void 0,e.staged),i]:(t=await(t?.getCommitForFile(e.path,e.staged)),null!=t?[t,t.file,i]:void 0)}async getOrCreateCommit(e){switch(this.mode){case"create":return this.getCommitForFile(e);case"view":return[await this.getOrCreateCommitForPatch(e.gkRepositoryId)];default:return[void 0]}}async getCommitForFile(e){const t=(0,w.sE)(this._context.create.changes.values(),(t=>t.repository.path===e.repoPath));if(null==t)return[void 0];const i=await t.getChange();if(null==i)return[void 0];if("revision"===i.type){const t=await this.container.git.getCommit(e.repoPath,i.revision.to??a.CL);return i.revision.to===i.revision.from||i.revision.from.length===i.revision.to.length+1&&i.revision.from.endsWith("^")&&i.revision.from.startsWith(i.revision.to)?[t]:[t,i.revision]}return"wip"===i.type?[await this.container.git.getCommit(e.repoPath,i.revision.to??a.CL)]:[void 0]}async getOrCreateCommitForPatch(e){const t=this._context.draft;if("local"===t.draftType)return;const i=await this.getDraftPatch(t,e);if(null!=i?.repository){if(null==i?.commit){if(!(0,h.uC)(i.repository)){const e=await this.container.repositoryIdentity.getRepository(i.repository,{openIfNeeded:!0,prompt:!0});if(null==e)return void s.window.showErrorMessage(`Unable to locate repository '${i.repository.name}'`);i.repository=e}try{const e=await this.container.git.createUnreachableCommitForPatch(i.repository.uri,i.contents,i.baseRef??"HEAD",t.title);i.commit=e}catch(e){s.window.showErrorMessage(`Unable preview the patch on base '${i.baseRef}': ${e.message}`),i.baseRef=void 0}}return i?.commit}}async openFile(e){const t=await this.getFileCommitFromParams(e);if(null==t)return;const[i,s]=t;(0,n.ZB)(s,i,{preserveFocus:!0,preview:!0,...e.showOptions})}async openFileComparisonWithPrevious(e){const t=await this.getFileCommitFromParams(e);if(null==t)return;const[i,s,o]=t;(0,n.vw)(s,null!=o?{repoPath:i.repoPath,rhs:o.to??a.CL,lhs:o.from}:i,{preserveFocus:!0,preview:!0,...e.showOptions,rhsTitle:"view"===this.mode?`${(0,v.EZ)(s.path)} (Patch)`:void 0}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFileComparisonWithWorking(e){const t=await this.getFileCommitFromParams(e);if(null==t)return;const[i,s,o]=t;(0,n.ce)(s,null!=o?{repoPath:i.repoPath,ref:o.to}:i,{preserveFocus:!0,preview:!0,...e.showOptions,lhsTitle:"view"===this.mode?`${(0,v.EZ)(s.path)} (Patch)`:void 0})}}((e,t,i,s)=>{for(var o,n=s>1?void 0:s?j(t,i):t,a=e.length-1;a>=0;a--)(o=e[a])&&(n=(s?o(t,i,n):o(n))||n);s&&n&&N(t,i,n)})([(0,y.fF)({args:!1})],PatchDetailsWebviewProvider.prototype,"getState",1)},7387:(e,t,i)=>{function s(e){if(null!=e)try{let t=function(e,t){if(t instanceof Date)return t.getTime();if(t instanceof Map||t instanceof Set)return[...t.entries()];if(t instanceof Function||t instanceof Error)return;if(t instanceof RegExp)return t.toString();const i=this[e];return i instanceof Date?i.getTime():t};return JSON.parse(JSON.stringify(e,t))}catch(e){throw e}}i.d(t,{q:()=>s})}};