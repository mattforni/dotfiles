exports.id=692,exports.ids=[692],exports.modules={788:(t,e,i)=>{i.d(e,{i:()=>s});function s(t){if(null!=t)try{return JSON.parse(JSON.stringify(t,function(t,e){if(e instanceof Date)return e.getTime();if(e instanceof Map||e instanceof Set)return[...e.entries()];if(e instanceof Function||e instanceof Error)return;if(e instanceof RegExp)return e.toString();let i=this[t];return i instanceof Date?i.getTime():e}))}catch(t){throw t}}},2392:(t,e,i)=>{i.d(e,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var s=i(7304),o=i(3072),n=i(1608),a=i(3172),r=i(1144),h=i(204),c=i(1080),l=i(2060),p=i(7956),d=i(8292),m=i(1424),u=i(4408),g=i(2216),f=i(9444),w=i(7824),k=i(4169),_=i(3664),v=i(4136),C=i(8196),S=i(7348),b=i(6448),x=i(3e3);let MRU=class MRU{constructor(t=10,e){this.maxSize=t,this.comparator=e}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let e=null!=this.comparator?this.stack.findIndex(e=>this.comparator(t,e)):this.stack.indexOf(t);-1!==e?this.stack.splice(e,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(t),this._position=0}get(t){if(null!=t){if(t<0||t>=this.stack.length)return;return this.stack[t]}return this.stack.length>0?this.stack[0]:void 0}insert(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(t),this._position++}navigate(t){if(!(this.stack.length<=1)){if("back"===t){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}};var y=i(2356),P=i(788),D=i(6584),F=i(6340),T=i(4008);let E=new D.Ip("commit/actions"),R=new D.Ip("commit/file/actions"),W=new D.Ip("commit/file/open"),I=new D.Ip("commit/file/openOnRemote"),O=new D.Ip("commit/file/compareWorking"),A=new D.Ip("commit/file/comparePrevious"),M=new D.Ip("commit/file/stage"),q=new D.Ip("commit/file/unstage"),L=new D.Ip("commit/pickCommit"),N=new D.Ip("commit/searchCommit"),B=new D.Ip("commit/switchMode"),V=new D.Ip("commit/autolinkSettings"),z=new D.Ip("commit/explain"),U=new D.Ip("commit/pin"),G=new D.Ip("commit/navigate"),Y=new D.Ip("commit/preferences/update"),H=new D.Ip("commit/wip/createPatch"),J=new D.ik("commit/didChange",!0),$=new D.ik("commit/didChange/wip"),j=new D.ik("commit/didExplain");new D.ik("org/settings/didChange");var K=Object.defineProperty,X=Object.getOwnPropertyDescriptor,Q=(t,e,i,s)=>{for(var o,n=s>1?void 0:s?X(e,i):e,a=t.length-1;a>=0;a--)(o=t[a])&&(n=(s?o(e,i,n):o(n))||n);return s&&n&&K(e,i,n),n};let CommitDetailsWebviewProvider=class CommitDetailsWebviewProvider{constructor(t,e,i){this.container=t,this.host=e,this.options=i,this._context={mode:"commit",navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commit:void 0,richStateLoaded:!1,formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0,orgSettings:this.getOrgSettings()},this._disposable=s.Disposable.from(k.i.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,_.kz)(this.onContextChanged,this))}_bootstraping=!0;_context;_pendingContext;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,(t,e)=>t.ref===e.ref);dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}_skipNextRefreshOnVisibilityChange=!1;async onShowing(t,e,...i){let s,o;let[n]=i;if((0,T.E)(n)){let{commit:t}=n.state;t?.repoPath!=null&&t?.sha!=null&&(s=null!=t.stashNumber?{commit:(0,m.op)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,m.op)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else s=null!=n&&"object"==typeof n?n:void 0;return null!=s&&(s.preserveFocus&&(null==e?e={preserveFocus:!0}:e.preserveFocus=!0),{commit:o,...s}=s),null!=o&&"wip"===this.mode&&s?.interaction!=="passive"&&this.setMode("commit"),null!=o||this._pinned||(o=this.getBestCommitOrStash()),null==o||this._context.commit?.ref.startsWith(o.ref)||await this.updateCommit(o,{pinned:!1}),(!s?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}includeBootstrap(){return this._bootstraping=!0,this._context={...this._context,...this._pendingContext},this._pendingContext=void 0,this.getState(this._context)}registerCommands(){return[(0,w.or)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))]}onFocusChanged(t){this._focused!==t&&(this._focused=t,t&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(t){switch(t.method){case I.method:(0,D.El)(I,t,t=>void this.openFileOnRemote(t));break;case W.method:(0,D.El)(W,t,t=>void this.openFile(t));break;case O.method:(0,D.El)(O,t,t=>void this.openFileComparisonWithWorking(t));break;case A.method:(0,D.El)(A,t,t=>void this.openFileComparisonWithPrevious(t));break;case R.method:(0,D.El)(R,t,t=>void this.showFileActions(t));break;case E.method:(0,D.El)(E,t,t=>{switch(t.action){case"graph":{let t;if(null==(t="wip"===this._context.mode?this._context.wip?.changes!=null?(0,m.op)(l.Oy,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this._context.commit?(0,m.K4)(this._context.commit):void 0))return;(0,w.gf)("graph"===this.options.attachedTo?n.eq.ShowInCommitGraphView:n.eq.ShowInCommitGraph,{ref:t});break}case"more":this.showCommitActions();break;case"scm":(0,w.CA)("workbench.view.scm");break;case"sha":t.alt?this.showCommitPicker():null!=this._context.commit&&(0,w.gf)(n.eq.CopyShaToClipboard,{sha:this._context.commit.sha})}});break;case L.method:(0,D.El)(L,t,t=>this.showCommitPicker());break;case N.method:(0,D.El)(N,t,t=>this.showCommitSearch());break;case B.method:(0,D.El)(B,t,t=>this.switchMode(t));break;case V.method:(0,D.El)(V,t,t=>this.showAutolinkSettings());break;case U.method:(0,D.El)(U,t,t=>this.updatePinned(t.pin??!1,!0));break;case G.method:(0,D.El)(G,t,t=>this.navigateStack(t.direction));break;case Y.method:(0,D.El)(Y,t,t=>this.updatePreferences(t));break;case z.method:(0,D.El)(z,t,()=>this.explainCommit(t.completionId));break;case M.method:(0,D.El)(M,t,t=>this.stageFile(t));break;case q.method:(0,D.El)(q,t,t=>this.unstageFile(t));break;case H.method:(0,D.El)(H,t,t=>this.createPatchFromWip(t))}}onRefresh(t){if(!this._pinned){if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=t?s.Uri.parse(t):void 0))}else{let t=this._pendingContext?.commit??this.getBestCommitOrStash();this.updateCommit(t,{immediate:!1})}}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(t){if(this.ensureTrackers(),!t)return;let e=this._skipNextRefreshOnVisibilityChange;if(e&&(this._skipNextRefreshOnVisibilityChange=!1),this._bootstraping){if(this._bootstraping=!1,null==this._pendingContext)return;this.updateState()}else e||this.onRefresh(),this.updateState(!0)}onAnyConfigurationChanged(t){(k.i.changed(t,["defaultDateFormat","views.commitDetails.files","views.commitDetails.avatars"])||k.i.changedCore(t,"workbench.tree.renderIndentGuides")||k.i.changedCore(t,"workbench.tree.indent"))&&(this.updatePendingContext({preferences:{...this._context.preferences,...this._pendingContext?.preferences,...this.getPreferences()}}),this.updateState()),null!=this._context.commit&&k.i.changed(t,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&(this.updateCommit(this._context.commit,{force:!0}),this.updateState())}getPreferences(){return{autolinksExpanded:this.container.storage.getWorkspace("views:commitDetails:autolinksExpanded")??!0,avatars:k.i.get("views.commitDetails.avatars"),dateFormat:k.i.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:k.i.get("views.commitDetails.files"),indentGuides:k.i.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:k.i.getCore("workbench.tree.indent")}}onContextChanged(t){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(t)&&(this.updatePendingContext({orgSettings:this.getOrgSettings()}),this.updateState())}getOrgSettings(){return{ai:(0,_.wp)("gitlens:gk:organization:ai:enabled",!1),drafts:(0,_.wp)("gitlens:gk:organization:drafts:enabled",!1)}}onCommitSelected(t){if(null!=t.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===t.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==t.source)){if("wip"===this.mode){t.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(t.data.commit.repoPath));return}this._pinned&&"passive"===t.data.interaction?(this._commitStack.insert((0,m.K4)(t.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:t.data.preserveFocus},t.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if(this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:t}=this.container;this._lineTrackerDisposable=t.subscribe(this,t.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}createPatchFromWip(t){if(null==t.changes)return;let e={type:"wip",repository:{name:t.changes.repository.name,path:t.changes.repository.path,uri:t.changes.repository.uri},files:t.changes.files,revision:{to:l.Oy,from:"HEAD"},checked:t.checked};(0,g.A)({mode:"create",create:{changes:[e]}})}onActiveEditorLinesChanged(t){if(t.pending||null==t.editor||t.suspended)return;if("wip"===this.mode){let e=this.container.git.getBestRepositoryOrFirst(t.editor);this.updateWipState(e);return}let e=t.selections?.[0]?.active,i=null!=e?this.container.lineTracker.getState(e)?.commit:void 0;this.updateCommit(i)}_wipSubscription;get mode(){return this._pendingContext?.mode??this._context.mode}setMode(t,e){this.updatePendingContext({mode:t}),"commit"===t?(this._wipSubscription?.subscription.dispose(),this._wipSubscription=void 0,this.updateState(!0)):this.updateWipState(e??this.container.git.getBestRepositoryOrFirst())}async explainCommit(t){let e;try{let t=await this.container.ai.explainCommit(this._context.commit,{progress:{location:{viewId:this.host.id}}});if(null==t)throw Error("Error retrieving content");e={summary:t}}catch(t){e={error:{message:t.message}}}this.host.notify(j,e,t)}navigateStack(t){let e=this._commitStack.navigate(t);null!=e&&this.updateCommit(e,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(t){let e;if(null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=t.commit&&(e=await this.getDetailsModel(t.commit,t.formattedMessage),!t.richStateLoaded)){this._cancellationTokenSource=new s.CancellationTokenSource;let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateRichState(t,e)},100)}return(0,P.i)({...this.host.baseWebviewState,mode:t.mode,commit:e,navigationStack:t.navigationStack,pinned:t.pinned,preferences:t.preferences,includeRichContent:t.richStateLoaded,autolinkedIssues:t.autolinkedIssues?.map(p.Al),pullRequest:null!=t.pullRequest?(0,d.AX)(t.pullRequest):void 0,wip:t.wip,orgSettings:t.orgSettings})}async updateWipState(t){let e;if(null!=this._wipSubscription){let{repo:e,subscription:i}=this._wipSubscription;t?.path!==e.path&&(i.dispose(),this._wipSubscription=void 0)}if(null!=t&&(null==this._wipSubscription&&(this._wipSubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)}),e={changes:await this.getWipChange(t),repositoryCount:this.container.git.openRepositoryCount},null==this._pendingContext&&await this.host.notify($,{wip:e}))){this._context.wip=e;return}this.updatePendingContext({wip:e}),this.updateState(!0)}async updateRichState(t,e){let{commit:i}=t;if(null==i)return;let s=await this.container.git.getBestRemoteWithIntegration(i.repoPath);if(e.isCancellationRequested)return;let[o,n]=s?.provider!=null?await Promise.allSettled([k.i.get("views.commitDetails.autolinks.enabled")&&k.i.get("views.commitDetails.autolinks.enhanced")?(0,f.Gu)(i.getEnrichedAutolinks(s)):void 0,k.i.get("views.commitDetails.pullRequests.enabled")?i.getAssociatedPullRequest(s):void 0]):[];if(e.isCancellationRequested)return;let a=y.Cv(o)?.value,r=(0,y.Cv)(n),h=this.getFormattedMessage(i,s,a);this.updatePendingContext({richStateLoaded:!0,formattedMessage:h,autolinkedIssues:null!=a?[...(0,S.Gs)(a.values(),([t])=>t?.value)]:void 0,pullRequest:r}),this.updateState()}_repositorySubscription;async updateCommit(t,e){let i;if(!e?.force&&this._context.commit?.sha===t?.ref)return;if((0,c.S)(t))i=t;else if(null!=t){if("stash"===t.refType){let e=await this.container.git.getStash(t.repoPath);i=e?.commits.get(t.ref)}else i=await this.container.git.getCommit(t.repoPath,t.ref)}let s=this._pendingContext?.wip??this._context.wip;if(null!=this._repositorySubscription){let{repo:t,subscription:e}=this._repositorySubscription;i?.repoPath!==t.path&&(e.dispose(),this._repositorySubscription=void 0,s=void 0)}if(null==this._repositorySubscription&&null!=i){let t=await this.container.git.getOrOpenRepository(i.repoPath);null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)},"wip"===this.mode?this.updateWipState(t):s=void 0)}this.updatePendingContext({commit:i,richStateLoaded:!!i?.isUncommitted||!(0,_.wp)("gitlens:hasConnectedRemotes"),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:s},e?.force),e?.pinned!=null&&this.updatePinned(e?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=i&&(e?.skipStack||this._commitStack.add((0,m.K4)(i)),this.updateNavigation()),this.updateState(e?.immediate??!0)}subscribeToRepositoryWip(t){return s.Disposable.from(t.watchFileSystem(1e3),t.onDidChangeFileSystem(()=>this.onWipChanged(t)),t.onDidChange(e=>{e.changed(u.c7.Index,u.MR.Any)&&this.onWipChanged(t)}))}onWipChanged(t){this.updateWipState(t)}async getWipChange(t){let e=await this.container.git.getStatusForRepo(t.path);if(null==e)return;let i=[];for(let t of e.files){let e={repoPath:t.repoPath,path:t.path,status:t.status,originalPath:t.originalPath,staged:t.staged};i.push(e),t.staged&&t.wip&&i.push({...e,staged:!1})}return{repository:{name:t.name,path:t.path,uri:t.uri.toString()},branchName:e.branch,files:i}}updatePinned(t,e){t!==this._context.pinned&&(this._pinned=t,this.ensureTrackers(),this.updatePendingContext({pinned:t}),this.updateState(e))}updatePreferences(t){if(this._context.preferences?.autolinksExpanded===t.autolinksExpanded&&this._context.preferences?.files?.compact===t.files?.compact&&this._context.preferences?.files?.icon===t.files?.icon&&this._context.preferences?.files?.layout===t.files?.layout&&this._context.preferences?.files?.threshold===t.files?.threshold)return;let e={...this._context.preferences,...this._pendingContext?.preferences};null!=t.autolinksExpanded&&this._context.preferences?.autolinksExpanded!==t.autolinksExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:autolinksExpanded",t.autolinksExpanded),e.autolinksExpanded=t.autolinksExpanded),null!=t.files&&(this._context.preferences?.files?.compact!==t.files?.compact&&k.i.updateEffective("views.commitDetails.files.compact",t.files?.compact),this._context.preferences?.files?.icon!==t.files?.icon&&k.i.updateEffective("views.commitDetails.files.icon",t.files?.icon),this._context.preferences?.files?.layout!==t.files?.layout&&k.i.updateEffective("views.commitDetails.files.layout",t.files?.layout),this._context.preferences?.files?.threshold!==t.files?.threshold&&k.i.updateEffective("views.commitDetails.files.threshold",t.files?.threshold),e.files=t.files),this.updatePendingContext({preferences:e}),this.updateState()}updatePendingContext(t,e=!1){let[i,s]=(0,F.MD)(this._context,this._pendingContext,t,e);return i&&(this._pendingContext=s),i}_notifyDidChangeStateDebounced=void 0;updateState(t=!1){if(t){this.notifyDidChangeState();return}null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,C.Cu)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced()}updateNavigation(){let t=this._commitStack.get(this._commitStack.position-1)?.ref;null!=t&&(t=(0,m.c5)(t)),this.updatePendingContext({navigationStack:{count:this._commitStack.count,position:this._commitStack.position,hint:t}}),this.updateState()}async notifyDidChangeState(t=!1){let e;let i=(0,x.b1)();return this._notifyDidChangeStateDebounced?.cancel(),(!!t||null!=this._pendingContext)&&(null!=this._pendingContext?(e={...this._context,...this._pendingContext},this._context=e,this._pendingContext=void 0):e=this._context,s.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify(J,{state:await this.getState(e)})}catch(t){b.YJ.error(i,t)}}))}getBestCommitOrStash(){let t;if(!this._pinned){if("graph"!==this.options.attachedTo&&null!=s.window.activeTextEditor){let{lineTracker:e}=this.container,i=e.selections?.[0].active;null!=i&&(t=e.getState(i)?.commit)}else if(null==(t=this._pendingContext?.commit)){let e=this.container.events.getCachedEventArgs("commit:selected");t=e?.commit}return t}}async getDetailsModel(t,e){let[i,s,n]=await Promise.allSettled([t.hasFullDetails()?t:t.ensureFullDetails().then(()=>t),t.author.getAvatarUri(t,{size:32}),this.container.git.getBestRemoteWithIntegration(t.repoPath,{includeDisconnected:!0})]);t=(0,y.Cv)(i,t);let a=(0,y.Cv)(s),r=(0,y.Cv)(n);null==e&&(e=this.getFormattedMessage(t,r));let h=null!=t.message?this.container.autolinks.getAutolinks(t.message,r):void 0;return{repoPath:t.repoPath,sha:t.sha,shortSha:t.shortSha,author:{...t.author,avatar:a?.toString(!0)},message:e,parents:t.parents,stashNumber:"stash"===t.refType?t.number:void 0,files:t.files,stats:t.stats,autolinks:null!=h?[...(0,S.kH)(h.values(),o.X)]:void 0}}getFormattedMessage(t,e,i){let s=h.E.fromTemplate("${message}",t),o=s.indexOf("\n");return(-1!==o&&(s=`${s.substring(0,o)}\0
\0${s.substring(o+1)}`),k.i.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(s,"html",null!=e?[e]:void 0,i):s}async getFileCommitFromParams(t){let e;if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;if(null==t)return;e=await this.container.git.getCommit(s.Uri.parse(t),l.Oy)}else e=this._context.commit;return null!=(e=await e?.getCommitForFile(t.path,t.staged))?[e,e.file]:void 0}showAutolinkSettings(){(0,w.gf)(n.eq.ShowSettingsPageAndJumpToAutolinks)}showCommitPicker(){(0,a.s)({command:"log",state:{reference:"HEAD",repo:this._context.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,a.s)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this._context.commit||this._context.commit.isUncommitted||(0,r.o7)(this._context.commit)}async showFileActions(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.o7)(i,s)}switchMode(t){let e;if("wip"===t.mode){let{repoPath:i}=t;if(null==i){if(null==(e=this.container.git.getBestRepositoryOrFirst()))return;i=e.path}else e=this.container.git.getRepository(i)}this.setMode(t.mode,e)}async openFileComparisonWithWorking(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.i_)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileComparisonWithPrevious(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.t6)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.U5)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileOnRemote(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;(0,r.bY)(s,i)}async stageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.stageFile(i.repoPath,s.path)}async unstageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.unstageFile(i.repoPath,s.path)}getShowOptions(t){return t.showOptions}};Q([(0,v.u_)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),Q([(0,v.u_)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),Q([(0,v.u_)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateRichState",1)}};