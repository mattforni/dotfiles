exports.id=0,exports.ids=[0],exports.modules={876:(t,e,i)=>{i.d(e,{l:()=>n});var s=i(1398);function n(t){if(null!=t)try{return JSON.parse(JSON.stringify(t,function(t,e){if(e instanceof Date)return e.getTime();if(e instanceof Map||e instanceof Set)return[...e.entries()];if(e instanceof Function||e instanceof Error)return;if(e instanceof RegExp||e instanceof s.Uri)return e.toString();let i=this[t];return i instanceof Date?i.getTime():i instanceof s.Uri?i.toString():e}))}catch(t){throw t}}},1932:(t,e,i)=>{i.d(e,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var s=i(4839),n=i(1398),o=i(4502),a=i(4692),r=i(2251),h=i(1646),l=i(2710),c=i(9268),p=i(8085),u=i(8400),d=i(315),g=i(3339),m=i(3444),f=i(1582),w=i(5302),_=i(4931),x=i(5952),C=i(7747),v=i(2443),S=i(9258),k=i(4007),b=i(124),y=i(5270),R=i(4064),P=i(6450);let MRU=class MRU{constructor(t=10,e){this.maxSize=t,this.comparator=e}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let e=null!=this.comparator?this.stack.findIndex(e=>this.comparator(t,e)):this.stack.indexOf(t);-1!==e?this.stack.splice(e,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(t),this._position=0}get(t){if(null!=t){if(t<0||t>=this.stack.length)return;return this.stack[t]}return this.stack.length>0?this.stack[0]:void 0}insert(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(t),this._position++}navigate(t){if(!(this.stack.length<=1)){if("back"===t){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}};var D=i(471),q=i(3408),T=i(1499),F=i(8538),E=i(876),A=i(683),W=i(701),O=i(3503);let M="commitDetails",I=new O.Q2(M,"commit/suggestChanges"),H=new O.Q2(M,"commit/actions/execute"),Q=new O.Q2(M,"file/actions/execute"),U=new O.Q2(M,"file/open"),z=new O.Q2(M,"file/openOnRemote"),J=new O.Q2(M,"file/compareWorking"),L=new O.Q2(M,"file/comparePrevious"),N=new O.Q2(M,"file/stage"),V=new O.Q2(M,"file/unstage"),B=new O.Q2(M,"pickCommit"),$=new O.Q2(M,"searchCommit"),G=new O.Q2(M,"switchMode");new O.Q2(M,"autolinkSettings");let j=new O.Q2(M,"pin"),Y=new O.Q2(M,"navigate"),X=new O.Q2(M,"preferences/update"),Z=new O.Q2(M,"wip/createPatch"),K=new O.Q2(M,"wip/changeReviewMode"),tt=new O.Q2(M,"wip/showCodeSuggestion"),te=new O.Q2(M,"fetch"),ti=new O.Q2(M,"publish"),ts=new O.Q2(M,"push"),tn=new O.Q2(M,"pull"),to=new O.Q2(M,"switch"),ta=new O.Q2(M,"openPullRequestChanges"),tr=new O.Q2(M,"openPullRequestComparison"),th=new O.Q2(M,"openPullRequestOnRemote"),tl=new O.Q2(M,"openPullRequestDetails"),tc=new O.Oz(M,"explain"),tp=new O.Oz(M,"generate"),tu=new O.C1(M,"didChange",!0),td=new O.C1(M,"didChange/wip");new O.C1(M,"org/settings/didChange");let tg=new O.C1(M,"didChange/jira"),tm=new O.C1(M,"didChange/account"),tf=new O.C1(M,"didChange/patch");var tw=Object.defineProperty,t_=Object.getOwnPropertyDescriptor,tx=(t,e,i,s)=>{for(var n,o=s>1?void 0:s?t_(e,i):e,a=t.length-1;a>=0;a--)(n=t[a])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&tw(e,i,o),o};let CommitDetailsWebviewProvider=class CommitDetailsWebviewProvider{constructor(t,e,i){this.container=t,this.host=e,this.options=i,this._context={mode:"commit",inReview:!1,navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commit:void 0,richStateLoaded:!1,formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0,orgSettings:this.getOrgSettings(),hasConnectedJira:void 0,hasAccount:void 0},this._disposable=n.Disposable.from(T.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,F.wt)(this.onContextChanged,this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),t.integrations.onDidChangeConnectionState(this.onIntegrationConnectionStateChanged,this))}_bootstraping=!0;_context;_pendingContext;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,(t,e)=>t.ref===e.ref);dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}getTelemetryContext(){let t;if("wip"===this.mode){let e=this._context.wip?.repo;t={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":this._context.wip?.pullRequest!=null?1:0,"context.inReview":this._context.inReview,"context.codeSuggestions":this._context.wip?.codeSuggestions?.length??0,"context.repository.id":e?.idHash,"context.repository.scheme":e?.uri.scheme,"context.repository.closed":e?.closed,"context.repository.folder.scheme":e?.folder?.uri.scheme,"context.repository.provider.id":e?.provider.id}}else t={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":(null!=this._context.pullRequest?1:0)+(this._context.autolinkedIssues?.length??0),"context.pinned":this._context.pinned,"context.type":null==this._context.commit?void 0:(0,d.kk)(this._context.commit)?"stash":"commit","context.uncommitted":this._context.commit?.isUncommitted??!1};return t}_skipNextRefreshOnVisibilityChange=!1;_shouldRefreshPullRequestDetails=!1;async onShowing(t,e,...i){let[s]=i;return s?.type==="wip"?[await this.onShowingWip(s),this.getTelemetryContext()]:[await this.onShowingCommit(s,e),this.getTelemetryContext()]}get inReview(){return this._pendingContext?.inReview??this._context.inReview}async onShowingWip(t,e){this.updatePendingContext({source:t.source});let i=null!=t.inReview&&this.inReview!==t.inReview;return"wip"!==this.mode||null!=t.repository&&this._context.wip?.repo!==t.repository?(i&&this.updatePendingContext({inReview:t.inReview}),await this.setMode("wip",t.repository),i&&!0===t.inReview&&this.trackOpenReviewMode(t.source)):i&&await this.setInReview(t.inReview,t.source),(!e?.preserveVisibility||!!this.host.visible)&&("launchpad"===t.source&&this.host.visible&&(this._shouldRefreshPullRequestDetails=!0,this.onRefresh()),!0)}async onShowingCommit(t,e){let i,s;if((0,W.c)(t)){let{commit:e}=t.state;e?.repoPath!=null&&e?.sha!=null&&(i=null!=e.stashNumber?{commit:(0,f.kA)(e.sha,e.repoPath,{refType:"stash",name:e.message,number:e.stashNumber})}:{commit:(0,f.kA)(e.sha,e.repoPath,{refType:"revision",message:e.message})})}else i=null!=t&&"object"==typeof t?t:void 0;return null!=i&&(i.preserveFocus&&(null==e?e={preserveFocus:!0}:e.preserveFocus=!0),{commit:s,...i}=i),null!=s&&"wip"===this.mode&&i?.interaction!=="passive"&&await this.setMode("commit"),null!=s||this._pinned||(s=this.getBestCommitOrStash()),null==s||this._context.commit?.ref.startsWith(s.ref)||await this.updateCommit(s,{pinned:!1}),(!i?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}async trackOpenReviewMode(t){if(this._context.wip?.pullRequest==null)return;let e=this._context.wip.pullRequest.provider.id,i=await this.container.git.visibility(this._context.wip.repo.path),s=this._context.wip.changes?.files.length??0;this.container.telemetry.sendEvent("openReviewMode",{provider:e,"repository.visibility":i,repoPrivacy:i,source:t??"inspect",filesChanged:s})}includeBootstrap(){return this._bootstraping=!0,this._context={...this._context,...this._pendingContext},this._pendingContext=void 0,this.getState(this._context)}registerCommands(){return[(0,q.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))]}onFocusChanged(t){this._focused!==t&&(this._focused=t,t&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(t){switch(!0){case z.is(t):this.openFileOnRemote(t.params);break;case U.is(t):this.openFile(t.params);break;case J.is(t):this.openFileComparisonWithWorking(t.params);break;case L.is(t):this.openFileComparisonWithPrevious(t.params);break;case Q.is(t):this.showFileActions(t.params);break;case H.is(t):switch(t.params.action){case"graph":{let t;if(null==(t="wip"===this._context.mode?this._context.wip?.changes!=null?(0,f.kA)(_.SU,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this._context.commit?(0,f.rd)(this._context.commit):void 0))return;(0,q.RS)("graph"===this.options.attachedTo?r.d.ShowInCommitGraphView:r.d.ShowInCommitGraph,{ref:t});break}case"more":this.showCommitActions();break;case"scm":(0,q.S4)("workbench.view.scm");break;case"sha":null!=this._context.commit&&(t.params.alt?(0,q.RS)(r.d.CopyMessageToClipboard,{message:this._context.commit.message}):(0,d.kk)(this._context.commit)?n.env.clipboard.writeText(this._context.commit.stashName):(0,q.RS)(r.d.CopyShaToClipboard,{sha:this._context.commit.sha}))}break;case B.is(t):this.showCommitPicker();break;case $.is(t):this.showCommitSearch();break;case G.is(t):this.switchMode(t.params);break;case j.is(t):this.updatePinned(t.params.pin??!1,!0);break;case Y.is(t):this.navigateStack(t.params.direction);break;case X.is(t):this.updatePreferences(t.params);break;case tc.is(t):this.explainRequest(tc,t);break;case tp.is(t):this.generateRequest(tp,t);break;case N.is(t):this.stageFile(t.params);break;case V.is(t):this.unstageFile(t.params);break;case Z.is(t):this.createPatchFromWip(t.params);break;case te.is(t):this.fetch();break;case ti.is(t):this.publish();break;case ts.is(t):this.push();break;case tn.is(t):this.pull();break;case to.is(t):this.switch();break;case I.is(t):this.suggestChanges(t.params);break;case tt.is(t):this.showCodeSuggestion(t.params.id);break;case K.is(t):this.setInReview(t.params.inReview,"inspect-overview");break;case ta.is(t):this.openPullRequestChanges();break;case tr.is(t):this.openPullRequestComparison();break;case th.is(t):this.openPullRequestOnRemote();break;case tl.is(t):this.showPullRequestDetails()}}getEncodedEntityid(t=this._context.wip?.pullRequest){if(null==t)return;let e=(0,v.Dz)(t);if(null!=e)return s.EntityIdentifierUtils.encode(e)}async trackCreateCodeSuggestion(t,e){if(this._context.wip?.pullRequest==null)return;let i=this._context.wip.pullRequest.provider.id,s=await this.container.git.visibility(this._context.wip.repo.path);this.container.telemetry.sendEvent("codeSuggestionCreated",{provider:i,"repository.visibility":s,repoPrivacy:s,draftId:t.id,draftPrivacy:t.visibility,filesChanged:e,source:"reviewMode"},{source:"inspect-overview",detail:{reviewMode:!0}})}async suggestChanges(t){if(!await (0,S.G5)(this.container,"Code Suggestions are a Preview feature and require an account.",{source:"code-suggest",detail:"create"})||!await (0,S.l7)(this.container))return;let e=[],i=Object.entries(t.changesets),o=1===i.length,a=0;for(let[t,s]of i){if(!o&&!1===s.checked)continue;let t=this._context.wip.repo.id===s.repository.path?this._context.wip.repo:void 0;if(null==t)continue;let{checked:i}=s,n={to:_.SU,from:"HEAD"};"staged"===i&&(n={...n,to:_.id});let r=this.getEncodedEntityid();null!=r&&(s.files&&s.files.length>0&&("staged"===i?a+=s.files.filter(t=>!0===t.staged).length:a+=s.files.length),e.push({repository:t,revision:n,prEntityId:r}))}if(0!==e.length)try{let i=(0,v.Dz)(this._context.wip.pullRequest),o=s.EntityIdentifierUtils.encode(i),r={description:t.description,visibility:"provider_access",prEntityId:o},h=await this.container.drafts.createDraft("suggested_pr_change",t.title,e,r);(async function(){let t={title:"View Code Suggestions"},e={title:"Copy Link"},i=!1;for(;;){let s=await n.window.showInformationMessage(`Code Suggestion successfully created${i?"â€” link copied to the clipboard":""}`,t,e);if(s===e){n.env.clipboard.writeText(h.deepLinkUrl),i=!0;continue}s===t&&(0,C.X)({mode:"view",draft:h,source:"notification"});break}})(),this.setInReview(!1),this.trackCreateCodeSuggestion(h,a)}catch(t){n.window.showErrorMessage(`Unable to create draft: ${t.message}`)}}getRepoActionPath(){return"wip"===this._context.mode?this._context.wip?.repo.path:this._context.commit?.repoPath}fetch(){let t=this.getRepoActionPath();null!=t&&p.hd(t)}publish(){let t=this.getRepoActionPath();null!=t&&(0,q.wS)("git.publish",n.Uri.file(t))}push(){let t=this.getRepoActionPath();null!=t&&p.VC(t)}pull(){let t=this.getRepoActionPath();null!=t&&p.a$(t)}switch(){let t=this.getRepoActionPath();null!=t&&p.S_(t)}get pullRequestContext(){if("wip"===this.mode){if(this._context.wip?.pullRequest==null)return;return{repoPath:this._context.wip.repo.path,branch:this._context.wip.branch,pr:this._context.wip.pullRequest}}if(null!=this._context.pullRequest)return{repoPath:this._context.commit.repoPath,commit:this._context.commit,pr:this._context.pullRequest}}openPullRequestChanges(){if(null==this.pullRequestContext)return;let{repoPath:t,pr:e}=this.pullRequestContext;if(null==e.refs)return;let i=(0,m.tI)(t,e.refs);return(0,c.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${e.id}`})}openPullRequestComparison(){if(null==this.pullRequestContext)return;let{repoPath:t,pr:e}=this.pullRequestContext;if(null==e.refs)return;let i=(0,m.tI)(t,e.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async openPullRequestOnRemote(t){if(null==this.pullRequestContext)return;let{pr:{url:e}}=this.pullRequestContext;return(0,q.RS)(r.d.OpenPullRequestOnRemote,{pr:{url:e},clipboard:t})}async showPullRequestDetails(){if(null==this.pullRequestContext)return;let{pr:t,repoPath:e,branch:i,commit:s}=this.pullRequestContext;if(null!=t)return this.container.views.pullRequest.showPullRequest(t,s??i??e)}onRefresh(t){if(!this._pinned){if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=t?n.Uri.parse(t):void 0))}else{let t=this._pendingContext?.commit??this.getBestCommitOrStash();this.updateCommit(t,{immediate:!1})}}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(t){if(this.ensureTrackers(),!t)return;let e=this._skipNextRefreshOnVisibilityChange;if(e&&(this._skipNextRefreshOnVisibilityChange=!1),this._bootstraping){if(this._bootstraping=!1,null==this._pendingContext)return;this.updateState()}else e||this.onRefresh(),this.updateState(!0)}onAnyConfigurationChanged(t){(T.H.changed(t,["defaultDateFormat","defaultDateStyle","views.commitDetails.files","views.commitDetails.avatars"])||T.H.changedCore(t,"workbench.tree.renderIndentGuides")||T.H.changedCore(t,"workbench.tree.indent"))&&(this.updatePendingContext({preferences:{...this._context.preferences,...this._pendingContext?.preferences,...this.getPreferences()}}),this.updateState()),null!=this._context.commit&&T.H.changed(t,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&(this.updateCommit(this._context.commit,{force:!0}),this.updateState())}onSubscriptionChanged(t){this.updateCodeSuggestions(),this.updateHasAccount(t.current)}updateHasAccount(t){let e=null!=t.account;this._context.hasAccount!==e&&(this._context.hasAccount=e,this.host.notify(tm,{hasAccount:e}))}onIntegrationConnectionStateChanged(t){if("jira"===t.key){let e="connected"===t.reason;this._context.hasConnectedJira!==e&&(this._context.hasConnectedJira=e,this.host.notify(tg,{hasConnectedJira:this._context.hasConnectedJira}))}}async getHasJiraConnection(t=!1){if(null!=this._context.hasConnectedJira&&!t)return this._context.hasConnectedJira;let e=await this.container.integrations.get(h.tp.Jira);return null==e?this._context.hasConnectedJira=!1:this._context.hasConnectedJira=e.maybeConnected??await e.isConnected(),this._context.hasConnectedJira}async getHasAccount(t=!1){return(null==this._context.hasAccount||t)&&(this._context.hasAccount=(await this.container.subscription.getSubscription())?.account!=null),this._context.hasAccount}getPreferences(){return{autolinksExpanded:this.container.storage.getWorkspace("views:commitDetails:autolinksExpanded")??!0,pullRequestExpanded:this.container.storage.getWorkspace("views:commitDetails:pullRequestExpanded")??!0,avatars:T.H.get("views.commitDetails.avatars"),dateFormat:T.H.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",dateStyle:T.H.get("defaultDateStyle")??"relative",files:T.H.get("views.commitDetails.files"),indentGuides:T.H.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:T.H.getCore("workbench.tree.indent")}}onContextChanged(t){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(t)&&(this.updatePendingContext({orgSettings:this.getOrgSettings()}),this.updateState())}getOrgSettings(){return{ai:(0,F.SD)("gitlens:gk:organization:ai:enabled",!1),drafts:(0,F.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onCommitSelected(t){if(null!=t.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===t.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==t.source)){if("graph"===this.options.attachedTo){t.data.commit.ref===_.SU?"wip"!==this.mode?this.setMode("wip",this.container.git.getRepository(t.data.commit.repoPath)):t.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(t.data.commit.repoPath)):(this._pinned&&"passive"===t.data.interaction&&(this._commitStack.insert((0,f.rd)(t.data.commit)),this.updateNavigation()),"commit"!==this.mode&&this.setMode("commit",this.container.git.getRepository(t.data.commit.repoPath)),this._pinned&&"passive"===t.data.interaction||this.host.show(!1,{preserveFocus:t.data.preserveFocus},t.data));return}if("wip"===this.mode){t.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(t.data.commit.repoPath));return}this._pinned&&"passive"===t.data.interaction?(this._commitStack.insert((0,f.rd)(t.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:t.data.preserveFocus},t.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if(this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:t}=this.container;this._lineTrackerDisposable=t.subscribe(this,t.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}createPatchFromWip(t){if(null==t.changes)return;let e={type:"wip",repository:{name:t.changes.repository.name,path:t.changes.repository.path,uri:t.changes.repository.uri},files:t.changes.files,revision:{to:_.SU,from:"HEAD"},checked:t.checked};(0,C.X)({mode:"create",create:{changes:[e]}})}showCodeSuggestion(t){let e=this._context.wip?.codeSuggestions?.find(e=>e.id===t);null!=e&&(0,C.X)({mode:"view",draft:e,source:"inspect"})}onActiveEditorLinesChanged(t){if(t.pending||null==t.editor||t.suspended)return;if("wip"===this.mode){let e=this.container.git.getBestRepositoryOrFirst(t.editor);this.updateWipState(e,!0);return}let e=t.selections?.[0]?.active,i=null!=e?this.container.lineTracker.getState(e)?.commit:void 0;this.updateCommit(i)}_wipSubscription;get mode(){return this._pendingContext?.mode??this._context.mode}async setMode(t,e){this.updatePendingContext({mode:t}),"commit"===t?this.updateState(!0):await this.updateWipState(e??this.container.git.getBestRepositoryOrFirst()),this.updateTitle()}updateTitle(){if("commit"===this.mode){if(null==this._context.commit)this.host.title=this.host.originalTitle;else{let t="Commit Details";"stash"===this._context.commit.refType?t="Stash Details":this._context.commit.isUncommitted&&(t="Uncommitted Changes"),this.host.title=`${this.host.originalTitle}: ${t}`}}else this.host.title=`${this.host.originalTitle}: Overview`}async explainRequest(t,e){let i;try{let t=await (await this.container.ai)?.explainCommit(this._context.commit,{source:"inspect",type:d.kk(this._context.commit)?"stash":"commit"},{progress:{location:{viewId:this.host.id}}});if(null==t)throw Error("Error retrieving content");i={result:t}}catch(t){i={error:{message:t.message}}}this.host.respond(t,e,i)}async generateRequest(t,e){let i;let s=this._context.wip?.repo;if(!s){this.host.respond(t,e,{error:{message:"Unable to find changes"}});return}try{let t=await (await this.container.ai)?.generateDraftMessage(s,{source:"inspect",type:"suggested_pr_change"},{progress:{location:{viewId:this.host.id}}});if(null==t)throw Error("Error retrieving content");i={title:t.summary,description:t.body}}catch(t){i={error:{message:t.message}}}this.host.respond(t,e,i)}navigateStack(t){let e=this._commitStack.navigate(t);null!=e&&this.updateCommit(e,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(t){let e;if(null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=t.commit&&(e=await this.getDetailsModel(t.commit,t.formattedMessage),!t.richStateLoaded)){this._cancellationTokenSource=new n.CancellationTokenSource;let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateRichState(t,e)},100)}let i=t.wip;if(null==i&&this._repositorySubscription){null==this._cancellationTokenSource&&(this._cancellationTokenSource=new n.CancellationTokenSource);let t=this._cancellationTokenSource.token;setTimeout(()=>{t.isCancellationRequested||this.updateWipState(this._repositorySubscription?.repo)},100)}return null==t.hasConnectedJira&&(t.hasConnectedJira=await this.getHasJiraConnection()),null==t.hasAccount&&(t.hasAccount=await this.getHasAccount()),(0,E.l)({...this.host.baseWebviewState,mode:t.mode,commit:e,navigationStack:t.navigationStack,pinned:t.pinned,preferences:t.preferences,includeRichContent:t.richStateLoaded,autolinkedIssues:t.autolinkedIssues?.map(g.Vz),pullRequest:null!=t.pullRequest?(0,m.pf)(t.pullRequest):void 0,wip:tC(i),orgSettings:t.orgSettings,inReview:t.inReview,hasConnectedJira:t.hasConnectedJira,hasAccount:t.hasAccount})}async updateWipState(t,e=!1){let i;if(null!=this._wipSubscription){let{repo:i,subscription:s}=this._wipSubscription;if(t?.path!==i.path)s.dispose(),this._wipSubscription=void 0;else if(e)return}let s=this.inReview;if(null!=t){null==this._wipSubscription&&(this._wipSubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)});let e=await this.getWipChange(t);if(i={changes:e,repo:t,repositoryCount:this.container.git.openRepositoryCount},null!=e){let s=await this.getWipBranchDetails(t,e.branchName);null!=s&&(i.branch=s.branch,i.pullRequest=s.pullRequest,i.codeSuggestions=s.codeSuggestions)}if(i.pullRequest?.state!=="opened"&&(s=!1),this._shouldRefreshPullRequestDetails&&null!=i.pullRequest&&("launchpad"===this._context.source||this._pendingContext?.source==="launchpad")&&(this.container.views.pullRequest.showPullRequest(i.pullRequest,i.branch??t.path),this._shouldRefreshPullRequestDetails=!1),null==this._pendingContext&&await this.host.notify(td,(0,E.l)({wip:tC(i),inReview:s}))){this._context.wip=i,this._context.inReview=s;return}}this.updatePendingContext({wip:i,inReview:s}),this.updateState(!0)}async getWipBranchDetails(t,e){let i=await t.git.getBranch(e);if(null==i)return;if("commit"===this.mode)return{branch:i,pullRequest:void 0,codeSuggestions:[]};let s=await i.getAssociatedPullRequest({expiryOverride:3e5}),n=[];if(null!=s){let e=await this.getCodeSuggestions(s,t);e.length&&(n=e)}return{branch:i,pullRequest:s,codeSuggestions:n}}async canAccessDrafts(){return await this.getHasAccount()!==!1&&(0,F.SD)("gitlens:gk:organization:drafts:enabled",!1)}async getCodeSuggestions(t,e){if(!await this.canAccessDrafts())return[];let i=await this.container.drafts.getCodeSuggestions(t,e);for(let t of i){if(null!=t.author.avatarUri||null==t.organizationId)continue;let e=t.author.email;if(null==e){let i=await this.container.organizations.getMemberById(t.author.id,t.organizationId);e=i?.email}null!=e&&(t.author.avatarUri=(0,a.m_)(e))}return i}async updateCodeSuggestions(){if("wip"!==this.mode||this._context.wip?.pullRequest==null)return;let t=this._context.wip,{pullRequest:e,repo:i}=t;if(t.codeSuggestions=await this.getCodeSuggestions(e,i),null==this._pendingContext&&await this.host.notify(td,(0,E.l)({wip:tC(t)}))){this._context.wip=t;return}this.updatePendingContext({wip:t}),this.updateState(!0)}async updateRichState(t,e){let{commit:i}=t;if(null==i)return;let s=await this.container.git.getBestRemoteWithIntegration(i.repoPath);if(e.isCancellationRequested)return;let[n,o]=s?.provider!=null?await Promise.allSettled([T.H.get("views.commitDetails.autolinks.enabled")&&T.H.get("views.commitDetails.autolinks.enhanced")?(0,D.zu)(i.getEnrichedAutolinks(s)):void 0,T.H.get("views.commitDetails.pullRequests.enabled")?i.getAssociatedPullRequest(s):void 0]):[];if(e.isCancellationRequested)return;let a=D.Ro(n)?.value,r=(0,D.Ro)(o),h=this.getFormattedMessage(i,s,a);this.updatePendingContext({richStateLoaded:!0,formattedMessage:h,autolinkedIssues:null!=a?[...(0,y.x1)(a.values(),([t])=>t?.value)]:void 0,pullRequest:r}),this.updateState()}_repositorySubscription;async updateCommit(t,e){let i;if(!e?.force&&this._context.commit?.sha===t?.ref)return;if((0,d.WM)(t))i=t;else if(null!=t){if("stash"===t.refType){let e=await this.container.git.getStash(t.repoPath);i=e?.stashes.get(t.ref)}else i=await this.container.git.getCommit(t.repoPath,t.ref)}let s=this._pendingContext?.wip??this._context.wip;if(null!=this._repositorySubscription){let{repo:t,subscription:e}=this._repositorySubscription;i?.repoPath!==t.path&&(e.dispose(),this._repositorySubscription=void 0,s=void 0)}if(null==this._repositorySubscription&&null!=i){let t=await this.container.git.getOrOpenRepository(i.repoPath);null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)},"wip"===this.mode?this.updateWipState(t):s=void 0)}this.updatePendingContext({commit:i,richStateLoaded:!!i?.isUncommitted||(null!=i?!F.SD("gitlens:repos:withHostingIntegrationsConnected")?.includes(i.repoPath):!(0,F.SD)("gitlens:repos:withHostingIntegrationsConnected")),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:s},e?.force),e?.pinned!=null&&this.updatePinned(e?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=i&&(e?.skipStack||this._commitStack.add((0,f.rd)(i)),this.updateNavigation()),this.updateState(e?.immediate??!0),this.updateTitle()}subscribeToRepositoryWip(t){return n.Disposable.from(t.watchFileSystem(1e3),t.onDidChangeFileSystem(()=>this.onWipChanged(t)),t.onDidChange(e=>{e.changed(w.Z_.Index,w.Ti.Any)&&this.onWipChanged(t)}))}onWipChanged(t){this.updateWipState(t)}async getWipChange(t){let e=await this.container.git.getStatus(t.path);if(null==e)return;let i=[];for(let t of e.files){let e={repoPath:t.repoPath,path:t.path,status:t.status,originalPath:t.originalPath,staged:t.staged};i.push(e),t.staged&&t.wip&&i.push({...e,staged:!1})}return{repository:{name:t.name,path:t.path,uri:t.uri.toString()},branchName:e.branch,files:i}}updatePinned(t,e){t!==this._context.pinned&&(this._pinned=t,this.ensureTrackers(),this.updatePendingContext({pinned:t}),this.updateState(e))}updatePreferences(t){if(this._context.preferences?.autolinksExpanded===t.autolinksExpanded&&this._context.preferences?.pullRequestExpanded===t.pullRequestExpanded&&this._context.preferences?.files?.compact===t.files?.compact&&this._context.preferences?.files?.icon===t.files?.icon&&this._context.preferences?.files?.layout===t.files?.layout&&this._context.preferences?.files?.threshold===t.files?.threshold)return;let e={...this._context.preferences,...this._pendingContext?.preferences};null!=t.autolinksExpanded&&this._context.preferences?.autolinksExpanded!==t.autolinksExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:autolinksExpanded",t.autolinksExpanded).catch(),e.autolinksExpanded=t.autolinksExpanded),null!=t.pullRequestExpanded&&this._context.preferences?.pullRequestExpanded!==t.pullRequestExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:pullRequestExpanded",t.pullRequestExpanded).catch(),e.pullRequestExpanded=t.pullRequestExpanded),null!=t.files&&(this._context.preferences?.files?.compact!==t.files?.compact&&T.H.updateEffective("views.commitDetails.files.compact",t.files?.compact),this._context.preferences?.files?.icon!==t.files?.icon&&T.H.updateEffective("views.commitDetails.files.icon",t.files?.icon),this._context.preferences?.files?.layout!==t.files?.layout&&T.H.updateEffective("views.commitDetails.files.layout",t.files?.layout),this._context.preferences?.files?.threshold!==t.files?.threshold&&T.H.updateEffective("views.commitDetails.files.threshold",t.files?.threshold),e.files=t.files),this.updatePendingContext({preferences:e}),this.updateState()}updatePendingContext(t,e=!1){let[i,s]=(0,A.ql)(this._context,this._pendingContext,t,e);return i&&(this._pendingContext=s),i}_notifyDidChangeStateDebounced=void 0;updateState(t=!1){if(t){this.notifyDidChangeState();return}null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,b.sg)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced()}updateNavigation(){let t=this._commitStack.get(this._commitStack.position-1)?.ref;null!=t&&(t=(0,x.pV)(t)),this.updatePendingContext({navigationStack:{count:this._commitStack.count,position:this._commitStack.position,hint:t}}),this.updateState()}async setInReview(t,e){this.inReview!==t&&(null==this._pendingContext&&await this.host.notify(tf,{inReview:t})&&(this._context.inReview=t),this.updatePendingContext({inReview:t}),this.updateState(!0),t&&this.trackOpenReviewMode(e))}async notifyDidChangeState(t=!1){let e;let i=(0,P.dQ)();return this._notifyDidChangeStateDebounced?.cancel(),(!!t||null!=this._pendingContext)&&(null!=this._pendingContext?(e={...this._context,...this._pendingContext},this._context=e,this._pendingContext=void 0):e=this._context,n.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify(tu,{state:await this.getState(e)})}catch(t){R.Vy.error(t,i)}}))}getBestCommitOrStash(){let t;if(!this._pinned){if("graph"!==this.options.attachedTo&&null!=n.window.activeTextEditor){let{lineTracker:e}=this.container,i=e.selections?.[0].active;null!=i&&(t=e.getState(i)?.commit)}else if(null==(t=this._pendingContext?.commit)){let e=this.container.events.getCachedEventArgs("commit:selected");t=e?.commit}return t}}async getDetailsModel(t,e){let[i,s,n]=await Promise.allSettled([t.hasFullDetails()?t:t.ensureFullDetails().then(()=>t),t.author.getAvatarUri(t,{size:32}),this.container.git.getBestRemoteWithIntegration(t.repoPath,{includeDisconnected:!0})]);t=(0,D.Ro)(i,t);let a=(0,D.Ro)(s),r=(0,D.Ro)(n);null==e&&(e=this.getFormattedMessage(t,r));let h=null!=t.message?await this.container.autolinks.getAutolinks(t.message,r):void 0;return{repoPath:t.repoPath,sha:t.sha,shortSha:t.shortSha,author:{...t.author,avatar:a?.toString(!0)},message:e,parents:t.parents,stashNumber:"stash"===t.refType?t.number:void 0,files:t.files,stats:t.stats,autolinks:null!=h?[...(0,y.Tj)(h.values(),o.U8)]:void 0}}getFormattedMessage(t,e,i){let s=u.c.fromTemplate("${message}",t),n=s.indexOf("\n");return(-1!==n&&(s=`${s.substring(0,n)}\0
\0${s.substring(n+1)}`),T.H.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(s,"html",null!=e?[e]:void 0,i):s}async getFileCommitFromParams(t){let e;if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;if(null==t)return;e=await this.container.git.getCommit(n.Uri.parse(t),_.SU)}else e=this._context.commit;return null!=(e=await e?.getCommitForFile(t.path,t.staged))?[e,e.file]:void 0}showCommitPicker(){(0,l.b)({command:"log",state:{reference:"HEAD",repo:this._context.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,l.b)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this._context.commit||this._context.commit.isUncommitted||(0,c.G4)(this._context.commit)}async showFileActions(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,c.G4)(i,s)}switchMode(t){let e;if(this.mode===t.mode)return;let i=this.mode;if("wip"===t.mode){let{repoPath:i}=t;if(null==i){if(null==(e=this.container.git.getBestRepositoryOrFirst()))return;i=e.path}else e=this.container.git.getRepository(i)}this.setMode(t.mode,e),this.container.telemetry.sendEvent(`${this.options.attachedTo?"graphDetails":"commitDetails"}/mode/changed`,{...this.getTelemetryContext(),"mode.old":i,"mode.new":t.mode})}async openFileComparisonWithWorking(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,c.DD)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileComparisonWithPrevious(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,c.eX)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,c.Tq)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileOnRemote(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;(0,c.gV)(s,i)}async stageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.stageFile(i.repoPath,s.path)}async unstageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.unstageFile(i.repoPath,s.path)}getShowOptions(t){return t.showOptions}};function tC(t){if(null!=t)return{changes:t.changes,repositoryCount:t.repositoryCount,branch:function(t){if(null!=t)return{name:t.name,repoPath:t.repoPath,upstream:t.upstream,tracking:{ahead:t.state.ahead,behind:t.state.behind}}}(t.branch),repo:{uri:t.repo.uri.toString(),name:t.repo.name,path:t.repo.path},pullRequest:null!=t.pullRequest?(0,m.pf)(t.pullRequest):void 0,codeSuggestions:t.codeSuggestions?.map(t=>(0,E.l)({...t,changesets:void 0}))}}tx([(0,k.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),tx([(0,k.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),tx([(0,k.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateRichState",1)}};