exports.id=928,exports.ids=[928],exports.modules={7056:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var s=i(1398),o=i(4692),n=i(5811),r=i(2251),a=i(1646),h=i(2710),l=i(9268),u=i(8085),c=i(961),d=i(3444),p=i(1582),g=i(5416),v=i(5302),w=i(4931),f=i(5952),m=i(9808),b=i(9919),C=i(7747),y=i(2377),R=i(369),S=i(2981),P=i(4424),_=i(124),D=i(5270),k=i(471),B=i(3408),O=i(1499),I=i(8538),L=i(3156),q=i(3503);let W="home",E=new q.Oz(W,"launchpad/summary"),T=new q.Oz(W,"overview"),A=new q.Oz(W,"overviewFilter"),z=new q.Oz(W,"overview/repository/change"),$=new q.Q2(W,"previewEnabled/toggle"),F=new q.Q2(W,"section/collapse"),x=new q.Q2(W,"walkthrough/dismiss"),H=new q.Q2(W,"overview/filter/set"),M=new q.Q2(W,"openInGraph"),G=new q.C1(W,"repositories/didCompleteDiscovering"),Z=new q.C1(W,"previewEnabled/didChange"),U=new q.C1(W,"repository/wip/didChange"),N=new q.C1(W,"repositories/didChange"),Q=new q.C1(W,"walkthroughProgress/didChange"),V=new q.C1(W,"integrations/didChange"),X=new q.C1(W,"launchpad/didChange"),j=new q.C1(W,"subscription/didChange"),J=new q.C1(W,"org/settings/didChange"),K=new q.C1(W,"home/ownerFilter/didChange"),Y=new q.C1(W,"account/didFocus"),ee=Object.freeze({dispose:()=>{}});let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=s.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),s.workspace.isTrusted?ee:s.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,I.wt)(this.onContextChanged,this),this.container.integrations.onDidChangeConnectionState(this.onChangeConnectionState,this),this.container.walkthrough.onProgressChanged(this.onWalkthroughChanged,this),O.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onDidLaunchpadChange,this))}_disposable;_discovering;_etag;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[s]=i;if(s?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(Y,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._etag=await this._discovering,this._discovering=void 0,this.notifyDidCompleteDiscoveringRepositories())}onChangeConnectionState(){this.notifyDidChangeOnboardingIntegration()}async shouldNotifyRepositoryChange(){return this._etag!==this.container.git.etag&&(null==this._discovering||(this._etag=await this._discovering,this._etag!==this.container.git.etag))}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,P.oe)(`Switch Repository ${n.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);null!=i&&i!==e&&this.selectRepository(i.path)}async onRepositoriesChanged(){await this.shouldNotifyRepositoryChange()&&this.notifyDidChangeRepositories()}onWalkthroughChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){O.H.changed(e,"home.preview.enabled")&&this.notifyDidChangeConfig()}onDidLaunchpadChange(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,B.Lb)(`${this.host.id}.pull`,this.pull,this),(0,B.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,B.Lb)(`${this.host.id}.publishBranch`,this.push,this),(0,B.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,B.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,B.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,B.Lb)(`${this.host.id}.previewFeedback`,()=>(0,L.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,B.Lb)(`${this.host.id}.whatsNew`,()=>(0,L.CZ)(n.DS.releaseNotes),this),(0,B.Lb)(`${this.host.id}.help`,()=>(0,L.CZ)(n.DS.helpCenter),this),(0,B.Lb)(`${this.host.id}.issues`,()=>(0,L.CZ)(n.DS.githubIssues),this),(0,B.Lb)(`${this.host.id}.info`,()=>(0,L.CZ)(n.DS.helpCenterHome),this),(0,B.Lb)(`${this.host.id}.discussions`,()=>(0,L.CZ)(n.DS.githubDiscussions),this),(0,B.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,B.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,B.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,B.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,B.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,B.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,B.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,B.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,B.Lb)("gitlens.home.fetch",this.fetch,this),(0,B.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,B.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,B.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,B.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,B.Lb)("gitlens.home.startWork",this.startWork,this),(0,B.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(K,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case F.is(e):this.onCollapseSection(e.params);break;case x.is(e):this.dismissWalkthrough();break;case H.is(e):this.setOverviewFilter(e.params);break;case E.is(e):this.host.respond(E,e,await (0,S.n_)(this.container));break;case T.is(e):this.host.respond(T,e,await this.getBranchOverview());break;case A.is(e):this.host.respond(A,e,this._overviewBranchFilter);break;case z.is(e):await this.onChooseRepository(),this.host.respond(z,e,void 0);break;case $.is(e):this.onTogglePreviewEnabled();break;case M.is(e):this.openInGraph(e.params)}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(Y,void 0))}onVisibilityChanged(e){if(!e){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(),this.notifyDidChangeRepositories(!0)}openInGraph(e){let t;if(e?.type==="branch"){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=(0,p.iw)(i);if(null==s)return;(0,B.RS)(r.d.ShowInCommitGraph,{ref:s});return}if(null==e)t=this.getSelectedRepository();else{let i=this._repositoryBranches.get(e.repoPath);t=i?.repo}null!=t&&(0,B.RS)(r.d.ShowGraph,t)}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,B.RS)(r.d.GitCommands,{command:"branch",state:{subcommand:"create",suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}async mergeIntoCurrent(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.getBranch(e.branchId)))&&u.h1(t.repo,(0,p.iw)(i))}async rebaseCurrentOnto(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);(null!=i||null!=(i=await t?.repo?.git.getBranch(e.branchId)))&&u.RU(t.repo,(0,p.iw)(i))}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,B.RS)(r.d.StartWork,{command:"startWork",source:"home"})}async createCloudPatch(e){let t=await this.container.git.getStatus(e.repoPath);if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}let{repo:s}=this._repositoryBranches.get(e.repoPath),o={type:"wip",repository:{name:s.name,path:s.path,uri:s.uri.toString()},files:i,revision:{to:w.SU,from:"HEAD"}};(0,C.X)({mode:"create",create:{changes:[o]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),O.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return!!this.container.storage.get("home:walkthrough:dismissed")}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,I.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onContextChanged(e){"gitlens:gk:organization:drafts:enabled"===e&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){await this.notifyDidChangeSubscription(e.current),(0,y.k0)(e.current.state)!==(0,y.k0)(e.previous.state)&&this.onOverviewRepoChanged("repo")}async getState(e){let[t,i]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0)]);if("rejected"===t.status)throw t.reason;let s=(0,k.Ro)(i)??[],o=s.some(e=>e.connected);return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),integrations:s,hasAnyIntegrationConnected:o,walkthroughProgress:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},showWalkthroughProgress:!this.getWalkthroughDismissed(),previewEnabled:this.getPreviewEnabled(),newInstall:(0,I.SD)("gitlens:install:new",!1)}}getPreviewEnabled(){return O.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:s.workspace.isTrusted}}async getBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i=void 0!==this._invalidateOverview,s=function(e,t,i,s){let o,n;let{branches:r,worktreesByBranch:a}=e;if(0===r.length)return;let h={active:[],recent:[],stale:[]},l=new Map,u=new Map,d=new Map,g=new Map,v=new Map,w=new Map,f=Date.now(),m=f-et[i.recent.threshold];for(let e of r){let i=a.get(e.id),r=i?{name:i.name,uri:i.uri.toString()}:void 0,f=e.date?.getTime();if(e.current||i?.opened){let a=s?.forceActive?{force:!0}:void 0;s?.isPro!==!1&&(l.set(e.id,er(t,e,o)),u.set(e.id,e.getEnrichedAutolinks()),d.set(e.id,(0,c.GI)(t,e).then(e=>e.value)),v.set(e.id,t.git.getBranchContributorOverview(e.repoPath,e.ref)),e.current&&w.set(e.id,eo(t,e))),null!=i?g.set(e.id,i.getStatus(a)):(void 0===n&&(n=t.git.getStatus(e.repoPath)),g.set(e.id,n)),h.active.push({reference:(0,p.iw)(e),repoPath:e.repoPath,id:e.id,name:e.name,opened:!0,timestamp:f,state:e.state,status:e.status,upstream:e.upstream,worktree:r});continue}if(null!=f&&f>m){s?.isPro!==!1&&(l.set(e.id,er(t,e,o)),u.set(e.id,e.getEnrichedAutolinks()),d.set(e.id,(0,c.GI)(t,e).then(e=>e.value)),v.set(e.id,t.git.getBranchContributorOverview(e.repoPath,e.ref))),null!=i&&g.set(e.id,i.getStatus()),h.recent.push({reference:(0,p.iw)(e),repoPath:e.repoPath,id:e.id,name:e.name,opened:!1,timestamp:f,state:e.state,status:e.status,upstream:e.upstream,worktree:r});continue}}if(i?.stale?.show===!0){let e=f-et[i.stale.threshold];for(let i of((0,b.Xn)(r,{missingUpstream:!0,orderBy:"date:asc"}),r)){if(h.stale.length>9)break;if(h.active.some(e=>e.id===i.id)||h.recent.some(e=>e.id===i.id))continue;s?.isPro!==!1&&(u.set(i.id,i.getEnrichedAutolinks()),d.set(i.id,(0,c.GI)(t,i).then(e=>e.value)));let n=i.date?.getTime();if(i.upstream?.missing||null!=n&&n<e){let e=a.get(i.id),r=e?{name:e.name,uri:e.uri.toString()}:void 0;s?.isPro!==!1&&(i.upstream?.missing||l.set(i.id,er(t,i,o)),v.set(i.id,t.git.getBranchContributorOverview(i.repoPath,i.ref))),null!=e&&g.set(i.id,e.getStatus()),h.stale.push({reference:(0,p.iw)(i),repoPath:i.repoPath,id:i.id,name:i.name,opened:!1,timestamp:n,state:i.state,status:i.status,upstream:i.upstream,worktree:r});continue}}}return function(e,t,i,s,o,n,r,a){for(let h of[...e.active,...e.recent,...e.stale]){let l=e.active.includes(h);h.pr=t.get(h.id);let u=i.get(h.id);h.autolinks=u?.then(e=>ei(e));let c=s.get(h.id);h.issues=c?.then(e=>e?.map(e=>({id:e.id,title:e.title,state:e.state,url:e.url}))??[]),h.wip=ea(a,h,o.get(h.id),l);let d=n.get(h.id);h.contributors=es(a,d),h.mergeTarget=r.get(h.id)}}(h,l,u,d,g,v,w,t),h}(await this.getBranchesData(e,t),this.container,this._overviewBranchFilter,{forceActive:!!i||void 0,isPro:await this.isSubscriptionPro()});if(this._invalidateOverview=void 0,null!=s)return{repository:{...await this.formatRepository(e),branches:s}}}async formatRepository(e){let t=await e.git.getBestRemotesWithProviders(),i=t.find(e=>e.hasIntegration())??t[0];return{name:e.commonRepositoryName??e.name,path:e.path,provider:i?.provider?{name:i.provider.name,icon:"remote"===i.provider.icon?"cloud":i.provider.icon,url:i.provider.url({type:g.J.Repo})}:void 0}}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription=void 0),null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepository(t)}),t}stopRepositorySubscription(){null!=this._repositorySubscription&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0)}resumeRepositorySubscription(e=!1){null!=this._repositorySubscription&&(e||null==this._repositorySubscription.subscription)&&(this._repositorySubscription.subscription?.dispose(),this._repositorySubscription.subscription=void 0,this._repositorySubscription.subscription=this.subscribeToRepository(this._repositorySubscription.repo))}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible){this.stopRepositorySubscription();return}this.resumeRepositorySubscription(!0)}subscribeToRepository(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onOverviewRepoChanged("wip")),e.onDidChange(e=>{e.changed(v.Z_.Config,v.Z_.Head,v.Z_.Heads,v.Z_.Remotes,v.Z_.Status,v.Z_.Unknown,v.Ti.Any)&&this.onOverviewRepoChanged("repo")}))}onOverviewRepoChanged(e){"repo"!==this._invalidateOverview&&(this._invalidateOverview=e),this.host.visible&&("wip"===e?this.host.notify(U,void 0):this.notifyDidChangeRepositories())}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.repo}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)){let t=await e.git.getWorktrees()??[],i=(0,m.PU)(t,{includeDefault:!0}),[s]=await Promise.allSettled([e.git.getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,m.vJ)(i)}})]),o=k.Ro(s)?.values??[];this._repositoryBranches.set(e.path,{repo:e,branches:o,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,D.x1)(this.container.integrations.getLoaded(),async e=>(0,a.LT)(e.id)?{id:e.id,name:e.name,icon:`gl-provider-${e.icon}`,connected:e.maybeConnected??await e.isConnected(),supports:"hosting"===e.type?["prs","issues"]:"issues"===e.type?["issues"]:[]}:void 0),t=await Promise.allSettled(e),i=[...(0,D.x1)(t,e=>(0,k.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),i.push(...this._defaultSupportedCloudIntegrations.filter(e=>!i.some(t=>t.id===e.id))),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,y.k0)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),t=e.account?.email?(0,o.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(G,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(N,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(e){this.notifyDidChangeRepositoriesCore();return}null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,_.sg)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}notifyDidChangeProgress(){this.host.notify(Q,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify(Z,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed()})}notifyDidChangeLaunchpad(){this.host.notify(X,void 0)}async notifyDidChangeOnboardingIntegration(){let e=await this.getIntegrationStates(!0),t=e.some(e=>e.connected);t&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(V,{hasAnyIntegrationConnected:t,integrations:e})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(j,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(J,{orgSettings:this.getOrgSettings()})}async pullRequestCompare(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,d.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.findPullRequest(e);if(t?.refs?.base==null||null==t.refs.head)return;let i=(0,d.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.findPullRequest(e);null!=i&&(0,B.RS)(r.d.OpenPullRequestOnRemote,{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.findPullRequest(e);null!=t&&this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);if(null==i)return;let s=await i.getRemote();null!=s&&(0,B.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=s?{name:s.name,provider:null!=s.provider?{id:s.provider.id,name:s.provider.name,domain:s.provider.domain}:void 0,url:s.url}:void 0,branch:{name:i.name,upstream:i.upstream?.name,isRemote:i.remote}})}worktreeOpen(e){let t=this.findWorktree(e);null!=t&&(0,L.OH)(t.uri)}switchToBranch(e){let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&u.S_(t.repo,(0,p.iw)(i))}fetch(e){if(null==e){let e=this.getSelectedRepository();u.hd(e);return}let t=this._repositoryBranches.get(e.repoPath),i=t?.branches.find(t=>t.id===e.branchId);null!=i&&u.hd(t.repo,(0,p.iw)(i))}findBranch(e){let t=this._repositoryBranches.get(e.repoPath)?.branches;return t?.find(t=>t.id===e.branchId)}findWorktree(e){let t=this._repositoryBranches.get(e.repoPath);if(null==t)return;let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return t.worktreesByBranch.get(i.id)}async findPullRequest(e){let t=this.findBranch(e);if(null!=t)return t.getAssociatedPullRequest()}};let et={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};async function ei(e){return null==e?[]:(await Promise.allSettled((0,D.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function es(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.date?.getTime(),count:e.count,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eo(e,t){let i;let s=await (0,c.y1)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!s.targetBranch.paused&&s.targetBranch.value&&(i=s.targetBranch.value);let o=i??s.baseBranch??s.defaultBranch;if(null==o)return;let[n,r]=await Promise.allSettled([e.git.getLeftRightCommitCount(t.repoPath,(0,f.Xn)(o,t.ref,"..."),{excludeMerges:!0}),e.git.getPotentialMergeOrRebaseConflict(t.repoPath,t.name,o)]),a=(0,k.Ro)(n),h=null!=a?{ahead:a.right,behind:a.left}:void 0;return{repoPath:t.repoPath,name:o,status:h,potentialConflicts:(0,k.Ro)(r),targetBranch:i,baseBranch:s.baseBranch,defaultBranch:s.defaultBranch}}async function en(e,t,i){i??=e.launchpad.getCategorizedItems();let s=await i;if(null!=s.error)return;let o=s.items.find(e=>e.url===t.url);if(null==o){if(null!=(s=await e.launchpad.getCategorizedItems({search:[{pullRequest:t,reasons:[]}]})).error)return;o=s.items.find(e=>e.url===t.url)}if(null!=o)return{uuid:o.uuid,category:o.actionableCategory,groups:(0,R._v)(o),suggestedActions:o.suggestedActions,failingCI:o.failingCI,hasConflicts:o.hasConflicts,review:{decision:o.reviewDecision,reviews:o.reviews??[],counts:{approval:o.approvalReviewCount,changeRequest:o.changeRequestReviewCount,comment:o.commentReviewCount,codeSuggest:o.codeSuggestionsCount}},author:o.author,createdDate:o.createdDate,viewer:{...o.viewer,enrichedItems:void 0}}}async function er(e,t,i){let s=await t.getAssociatedPullRequest({avatarSize:64});if(null!=s)return{id:s.id,url:s.url,state:s.state,title:s.title,draft:s.isDraft,launchpad:en(e,s,i)}}async function ea(e,t,i,s){if(null==i)return;let[o,n,r]=await Promise.allSettled([i,s?e.git.getMergeStatus(t.repoPath):void 0,s?e.git.getRebaseStatus(t.repoPath):void 0]),a=(0,k.Ro)(o),h=(0,k.Ro)(n),l=(0,k.Ro)(r);return{workingTreeState:a?.getDiffStatus(),hasConflicts:a?.hasConflicts,conflictsCount:a?.conflicts.length,mergeStatus:h,rebaseStatus:l}}}};